% This file was created with JabRef 2.6.
% Encoding: UTF8

@inproceedings{desutter.etal+08,
  author    = {Bjorn De Sutter and
               Bertrand Anckaert and
               Jens Geiregat and
               Dominique Chanet and
               Koen De Bosschere},
  title     = {Instruction Set Limitation in Support of Software Diversity},
  booktitle = {ICISC},
  year      = {2008},
  pages     = {152-165},
  ee        = {http://dx.doi.org/10.1007/978-3-642-00730-9_10},
  crossref  = {DBLP:conf/icisc/2008},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@proceedings{DBLP:conf/icisc/2008,
  editor    = {Pil Joong Lee and
               Jung Hee Cheon},
  title     = {Information Security and Cryptology - ICISC 2008, 11th International
               Conference, Seoul, Korea, December 3-5, 2008, Revised Selected
               Papers},
  booktitle = {ICISC},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {5461},
  year      = {2009},
  isbn      = {978-3-642-00729-3},
  ee        = {http://dx.doi.org/10.1007/978-3-642-00730-9},
  bibsource = {DBLP, http://dblp.uni-trier.de}
} 

@inproceedings{larsen.etal+14,
  author = {Per Larsen and Andrei Homescu and Stefan Brunthaler and Michael Franz},
  title = {SoK: Automated Software Diversity},
  year = {2014},
  booktitle = {IEEE Symposium on Security and Privacy}
}

@misc{fsecure,
  author = {Jarkko Turkulainen},
  title = {Reverse Engineering Malware Binary Obfuscation and Protection},
  year = {2014},
  note = {\url{https://noppa.aalto.fi/noppa/kurssi/t-110.6220/luennot/T-110_6220_binary_obfuscation_and_protection.pdf}}
}

@misc{pandasecurity,
  author = {Pedro Bustamante},
  title = {Packer (r)evolution},
  year = {2008},
  note = {\url{http://research.pandasecurity.com/packer-revolution}}
}

@misc{aspack,
  author = {{StarForce Technologies}},
  title = {Aspack Executable File Compressor},
  note = {\url{http://www.aspack.com}},
  year = {2013},
}

@misc{themida,
  author = {{Oreans Technologies}},
  title = {Themida Advanced Windows Software Protection System},
  note = {\url{http://www.oreans.com/themida.php}},
  year = {2013},
}

@INPROCEEDINGS{elkhalil04icics,
  author = {Rakan El-khalil and Angelos D. Keromytis},
  title = {Hydan: Hiding Information in Program Binaries},
  booktitle = {ICICS'04: Int. Conf. on Information and Communications Security},
  year = {2004},
  owner = {Mathias Payer},
  timestamp = {2012.04.16}
}

@INPROCEEDINGS{szor.ferrie+01,
  author = {P{\'e}ter Sz{\"o}r and Peter Ferrie},
  title = {Hunting for Metamorphic},
  booktitle = {In Proceedings of the Virus Bulletin Conference, 2001 (VB~'01)},
  pages = {123--144},
  year = {2001}
}

@article{okane.etal+11,
  author    = {Philip O'Kane and
               Sakir Sezer and
               Kieran McLaughlin},
  title     = {{Obfuscation: The Hidden Malware}},
  journal   = {IEEE Security {\&} Privacy},
  volume    = {9},
  number    = {5},
  year      = {2011},
  pages     = {41--47},
  doi        = {http://doi.ieeecomputersociety.org/10.1109/MSP.2011.98},
}

@INPROCEEDINGS{ccs05erlingsson,
  author = {Abadi, Mart\'{\i}n and Budiu, Mihai and Erlingsson, \'{U}lfar and
	Ligatti, Jay},
  title = {Control-flow integrity},
  booktitle = {CCS'05},
  abstract = {Current software attacks often build on exploits that subvert machine-code
	execution. The enforcement of a basic safety property, Control-Flow
	Integrity (CFI), can prevent such attacks from arbitrarily controlling
	program behavior. CFI enforcement is simple, and its guarantees can
	be established formally, even with respect to powerful adversaries.
	Moreover, CFI enforcement is practical: it is compatible with existing
	software and can be efficiently implemented using software rewriting
	in commodity systems. Finally, CFI provides a useful foundation for
	enforcing further security policies, such as policies that constrain
	the use of data memory.},
  acmid = {1102165},
  doi = {http://doi.acm.org/10.1145/1102120.1102165},
  isbn = {1-59593-226-7},
  keywords = {binary rewriting, control-flow graph, inlined reference monitors,
	vulnerabilities},
  location = {Alexandria, VA, USA},
  numpages = {14},
  owner = {Mathias Payer},
  timestamp = {2011.05.05},
  url = {http://doi.acm.org/10.1145/1102120.1102165}
}

@INPROCEEDINGS{abadi2009transactional,
  author = {Abadi, M. and Harris, T. and Mehrara, M.},
  title = {{Transactional memory with strong atomicity using off-the-shelf memory
	protection hardware}},
  year = {2009},
  volume = {44},
  number = {4},
  pages = {185--196},
  publisher = {ACM},
  abstract = {This paper introduces a new way to provide strong atomicity in an
	implementation of transactional memory. Strong atomicity lets us
	offer clear semantics to programs, even if they access the same locations
	inside and outside transactions. It also avoids differences between
	hardware-implemented transactions and software-implemented ones.
	Our approach is to use off-the-shelf page-level memory protection
	hardware to detect conflicts between normal memory accesses and transactional
	ones. This page-level mechanism ensures correctness but gives poor
	performance because of the costs of manipulating memory protection
	settings and receiving notifications of access violations. However,
	in practice, we show how a combination of careful object placement
	and dynamic code update allows us to eliminate almost all of the
	protection changes. Existing implementations of strong atomicity
	in software rely on detecting conflicts by conservatively treating
	some non-transactional accesses as short transactions. In contrast,
	our page-level mechanism lets us be less conservative about how non-transactional
	accesses are treated; we avoid changes to non-transactional code
	until a possible conflict is detected dynamically, and we can respond
	to phase changes where a given instruction sometimes generates conflicts
	and sometimes does not. We evaluate our implementation with C# versions
	of many of the STAMP benchmarks, and show how it performs within
	25% of an implementation with weak atomicity on all the benchmarks
	we have studied. It avoids pathological cases in which other implementations
	of strong atomicity perform poorly.},
  journal = {ACM SIGPLAN Notices},
  keywords = {STM, TM},
  owner = {Mathias Payer},
  review = {offers strong atomicity (instead of weak atomicity)


	Shadow heap for TX (pagetable mappings)

	mprotext if in tx

	-> ACCESS VIOLATIONS on conflict

	-> recover},
  timestamp = {2010.09.27}
}

@INPROCEEDINGS{acharya00mapbox,
  author = {Acharya, Anurag and Raje, Mandar},
  title = {{MAPbox}: using parameterized behavior classes to confine untrusted
	applications},
  booktitle = {SSYM'00: Proc. 9th Conf. USENIX Security Symp.},
  year = {2000},
  pages = {1--17},
  abstract = {Designing a suitable confinement mechanism to confine untrusted applications
	is challenging as such a mechanism needs to satisfy conflicting requirements.
	The main trade-off is between ease of use and flexibility. In this
	paper, we present the design, implementation and evaluation of MAPbox,
	a confinement mechanism that retains the ease of use of application-class-specific
	sandboxes such as the Java applet sandbox and the Janus document
	viewer sandbox while providing significantly more flexibility. The
	key idea is to group application behaviors into classes based on
	their expected functionality and the resources required to achieve
	that functionality. Classification of application behavior provides
	a set of labels (e.g., compiler, reader, netclient) that can be used
	to concisely communicate the expected functionality of programs between
	the provider and the users. This is similar to MIME-types which are
	widely used to concisely describe the expected format of data files.
	An end-user lists the set of application behaviors she is willing
	to allow in a file. With each label, she associates a sandbox that
	limits access to the set of resources needed to achieve the corresponding
	behavior. When an untrusted application is to be run, this file is
	consulted. If the label (or the MAP-type) associated with the application
	is not found in this file, it is not allowed to run. Else, the MAP-type
	is used to automatically locate and instantiate the appropriate sandbox.
	We believe that this may be an acceptable level of user interaction
	since a similar technique (i.e., MIME-types) has been fairly successful
	for handling documents with different formats. In this paper, we
	present a set of application behavior classes that we have identified
	based on a study of a diverse suite of applications that includes
	CGI scripts, programs downloaded from well-known web repositories
	and applications from the Solaris 5.6 distribution. We describe the
	implementation and usage of MAPbox. We evaluate MAPbox from two different
	perspectives: its effectiveness (how well it is able to confine a
	suite of untrusted applications) and effciency (what is the overhead
	introduced). Finally, we describe our experience with MAPbox and
	discuss potential limitations of this approach.},
  location = {Denver, Colorado},
  owner = {Mathias Payer},
  review = {ptrace system catches system calls, adds policy},
  timestamp = {2010.10.19}
}

@INPROCEEDINGS{1168860,
  author = {Keith Adams and Ole Agesen},
  title = {A comparison of software and hardware techniques for x86 virtualization},
  booktitle = {ASPLOS-XII: Proceedings of the 12th international conference on Architectural
	support for programming languages and operating systems},
  year = {2006},
  pages = {2--13},
  abstract = {Until recently, the x86 architecture has not permitted classical trap-and-emulate
	virtualization. Virtual Machine Monitors for x86, such as VMware
	Â® Workstation and Virtual PC, have instead used binary translation
	of the guest kernel code. However, both Intel and AMD have now introduced
	architectural extensions to support classical virtualization.We compare
	an existing software VMM with a new VMM designed for the emerging
	hardware support. Surprisingly, the hardware VMM often suffers lower
	performance than the pure software VMM. To determine why, we study
	architecture-level events such as page table updates, context switches
	and I/O, and find their costs vastly different among native, software
	VMM and hardware VMM execution.We find that the hardware support
	fails to provide an unambiguous performance advantage for two primary
	reasons: first, it offers no support for MMU virtualization; second,
	it fails to co-exist with existing software techniques for MMU virtualization.
	We look ahead to emerging techniques for addressing this MMU virtualization
	problem in the context of hardware-assisted virtualization.},
  doi = {http://doi.acm.org/10.1145/1168857.1168860},
  isbn = {1-59593-451-0},
  keywords = {hardware, software, virtualization, vmm},
  location = {San Jose, California, USA},
  owner = {Mathias Payer},
  review = {Software VMM vs. Hardware VMM -> written by VMWare

	- Software VMM is better -> more detailed information available and
	flexible and adaptive

	- emulated (software) is faster than spezial HW instructions (overhead)


	print -> 1},
  timestamp = {2007.10.04}
}

@INPROCEEDINGS{MISSISSIPPI-DELTA,
  author = {Ali-Reza Adl-Tabatabai and Richard L. Hudson and Mauricio J. Serrano
	and Sreenivas Subramoney},
  title = {Prefetch injection based on hardware monitoring and object metadata},
  booktitle = {Proc. of the ACM Conf. on Programming Language Design and Implementation
	(PLDI~2004)},
  year = {2004},
  pages = {267--276},
  doi = {http://doi.acm.org/10.1145/996841.996873},
  isbn = {1-58113-807-5},
  location = {Washington DC, USA}
}

@INPROCEEDINGS{aggarwal06issre,
  author = {Aggarwal, A. and Jalote, P.},
  title = {Monitoring the Security Health of Software Systems},
  booktitle = {ISSRE'06: 17th Int'l Symp. Software Reliability Engineering},
  year = {2006},
  pages = {146 -158},
  month = {nov.},
  abstract = {Detecting security bugs during the development cycle of a software
	is extremely difficult as effective testing approaches for such bugs
	do not exist. Applications are often deployed without being tested
	for security vulnerabilities even though the application domain demands
	highly secure software. Hence there is a need to develop systems
	which can monitor such applications for security violations and take
	immediate actions if any violation occurs. In this paper we describe
	an approach for monitoring the security health of a software system.
	Our methodology involves an agent based approach which communicates
	with the health monitoring system running as an independent process.
	We make this agent a part of the application (binary) and modify
	the binary at appropriate locations to transfer the control to the
	agent attached. The agent sends critical information regarding the
	execution to the monitoring system. The monitoring system analyzes
	the data and takes suitable actions. Currently our system monitors
	the following security bugs uffer overflow, race conditions (time
	of check to time to use vulnerability), random number vulnerability
	and can be extended for other vulnerabilities also},
  doi = {10.1109/ISSRE.2006.32},
  issn = {1071-9458},
  keywords = {agent based approach;buffer overflow;random number vulnerability;security
	bug detection;security health monitoring;security violations;security
	vulnerability;software development;software systems;program debugging;security
	of data;software agents;system monitoring;},
  owner = {Mathias Payer},
  review = {Static binary translation is used to add additional monitors that
	are executed at runtime.},
  timestamp = {2011.05.09}
}

@INPROCEEDINGS{spaa10opennesting,
  author = {Agrawal, Kunal and Lee, I-Ting Angelina and Sukha, Jim},
  title = {Safe open-nested transactions through ownership},
  booktitle = {SPAA '08},
  year = {2008},
  pages = {110--112},
  publisher = {ACM},
  abstract = {Researchers in transactional memory (TM) have proposed open-nested
	transactions for increasing concurrency. The idea is to ignore "low-level"
	memory operations of the open-nested transaction when detecting conflicts
	for its parent transaction, and instead perform abstract concurrency
	control for the "high-level" operation that nested transaction represents.
	Unfortunately, because the TM runtime is unaware of the different
	levels of memory, an unconstrained use of open-nested commits can
	lead to anomalous program behavior.


	We propose ownership-aware transactional memory (OATM) which explicitly
	incorporates the notion of modules into the TM system, and requires
	that transactions and data be associated with specific transactional
	modules or Xmodules. When a transaction in the OATM commits, the
	TM system uses this information about Xmodules and commits a piece
	of data differently depending on whether the current Xmodule owns
	the data or not. We call this commit mechanism ownership-aware commit,
	and it is a hybrid between an open-nested and closed-nested commit.
	Moreover, we give a set of precise constraints on interactions and
	sharing of data among the Xmodules based on familiar notions of abstractions.
	We prove that OATM has has clean memory-level semantics and can guarantee
	serializability by modules, which is an adaptation of multilevel
	serializability from databases to TM. Finally, we prove that if transactions
	in the process of aborting obey restrictions on their memory footprint,
	the OATM is free from semantic deadlock.},
  doi = {http://doi.acm.org/10.1145/1378533.1378553},
  isbn = {978-1-59593-973-9},
  keywords = {STM, TM},
  location = {Munich, Germany},
  owner = {Mathias Payer},
  review = {integrate transactional modules (Xmodules) and ownership into the
	TM system},
  timestamp = {2010.09.27}
}

@BOOK{Aho06,
  title = {Compilers: Principles, Techniques, and Tools (2nd Edition)},
  publisher = {Addison Wesley},
  year = {2006},
  author = {Alfred V. Aho and Monica S. Lam and Ravi Sethi and Jeffrey D. Ullman},
  abstract = {This book provides the foundation for understanding the theory and
	pracitce of compilers. Revised and updated, it reflects the current
	state of compilation.

	Every chapter has been completely revised to reflect developments
	in software engineering, programming languages, and computer architecture
	that have occurred since 1986, when the last edition published. The
	authors, recognizing that few readers will ever go on to construct
	a compiler, retain their focus on the broader set of problems faced
	in software design and software development.

	Computer scientists, developers, and aspiring students that want to
	learn how to build, maintain, and execute a compiler for a major
	programming language.},
  isbn = {0321486811},
  keywords = {compiler, extensible-syntax, parsing},
  owner = {Mathias Payer},
  timestamp = {2009.05.26}
}

@INPROCEEDINGS{aljaroodi02djvm,
  author = {Jameela Al-Jaroodi and Nader Mohamed and Hong Jiang and David Swanson},
  title = {A Comparative Study of Parallel and Distributed Java Projects for
	Heterogeneous Systems},
  booktitle = {IPDPS '02: Proceedings of the 16th International Parallel and Distributed
	Processing Symposium},
  year = {2002},
  pages = {2},
  abstract = {During the last few years, the concepts of cluster computing and heterogeneous
	networked systems have received increasing interest. The popularity
	of using Java for developing parallel and distributed applications
	that run on heterogeneous distributed systems has also grown rapidly.
	This paper is a survey of the current projects in parallel and distributed
	Java. These projects' main common objective is to utilize the available
	heterogeneous systems to provide high performance computing using
	Java. These projects were studied, compared and classified based
	on the approaches used. The study shows three major approaches. One
	is to develop a system that replaces the Java virtual machine (JVM)
	or utilizes the available parallel infrastructure such as MPI or
	PVM. Another is to provide seamless parallelization of multi-threaded
	applications. The third is to provide a pure Java implementation
	by adding classes and features that support parallel Java programming.
	In addition, a number of open issues are identified and discussed
	in this paper.},
  isbn = {0-7695-1573-8},
  owner = {Mathias Payer},
  review = {print -> 1},
  timestamp = {2008.08.10}
}

@ARTICLE{Aleph1,
  author = {Aleph1},
  title = {Smashing The Stack For Fun And Profit},
  journal = {Phrack},
  year = {1996},
  volume = {7},
  pages = {\url{http://phrack.com/issues.html?issue=49&id=14}},
  number = {49},
  month = nov,
  abstract = {`smash the stack` [C programming] n. On many C implementations it
	is possible to corrupt the execution stack by writing past the end
	of an array declared auto in a routine. Code that does this is said
	to smash the stack, and can cause return from the routine to jump
	to a random address. This can produce some of the most insidious
	data-dependent bugs known to mankind. Variants include trash the
	stack, scribble the stack, mangle the stack; the term mung the stack
	is not used, as this is never done intentionally. See spam; see also
	alias bug, fandango on core, memory leak, precedence lossage, overrun
	screw.},
  chapter = {14},
  citeulike-article-id = {3467779},
  citeulike-linkout-0 = {http://phrack.com/issues.html?issue=49\&\#38;id=14\#article},
  day = {08},
  keywords = {buffer-overflow, c, security, software, vulnerability},
  owner = {Mathias Payer},
  posted-at = {2008-10-31 08:49:51},
  priority = {5},
  url = {http://phrack.com/issues.html?issue=49\&\#38;id=14\#article}
}

@misc{alexandrov99consh,
  author = {Albert Alexandrov and Paul Kmiec and Klaus Schauser},
  title = {Consh: Confined Execution Environment for Internet Computations},
  howpublished = {\url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.488}},
  year = {1999},
  abstract = {The recent rapid growth of the Internet made a vast pool of resources
	available globally and enabled new kinds of applications raising
	the need for transparent remote access and for protected computing.
	Currently users need specialized software such as web browsers or
	FTP clients to access global resources. It is desirable to instead
	provide OS support for transparent access to these resources so that
	they can be accessed through standard applications such as text editors
	or command shells. The new applications made possible by the expanding
	Internet require provisions for safe and protected computing. For
	example, global computing projects harness the power of thousands
	of idle machines to solve complex problems and, similarly, and highly-flexible
	servers allow users to upload and execute their code on the server
	to perform otherwise difficult tasks. In both cases, users or servers
	need to execute applications which they cannot trust completely.
	Such untrusted applications could poten...},
  doi = {10.1.1.57.488},
  owner = {Mathias Payer},
  timestamp = {2010.10.19},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.488}
}

@INPROCEEDINGS{JALAPENO-alpern99,
  author = {Bowen Alpern and C. Richard Attanasio and John J. Barton and Anthony
	Cocchi and Susan Flynn Hummel and Derek Lieber and Ton Ngo and Mark
	F. Mergen and Janice C. Shepherd and Stephen Smith},
  title = {Implementing {J}alapeno in {J}ava},
  booktitle = {Proc. of the {ACM} Conf. on Object-Oriented Programming, Systems,
	Languages, and Applications (OOPLSA~1999)},
  year = {1999},
  pages = {314-324},
  url = {citeseer.ist.psu.edu/alpern99implementing.html}
}

@ARTICLE{jalapenoibmsj,
  author = {Bowen Alpern and Dick Attanasio and John Barton and Michael Burke
	and Perry Cheng and Jong-Deok Choi and Anthony Cocchi and Stephen
	Fink and David Grove and Michael Hind and Susan Flynn Hummel and
	Derek Lieber and Vassily Litvinov and Ton Ngo and Mark Mergen and
	Vivek Sarkar and Mauricio Serrano and Janice Shepherd and Stephen
	Smith and V. C. Sreedhar and Harini Srinivasan and John Whaley},
  title = {The {Jalapeno} Virtual Machine},
  journal = {{IBM} Systems Journal, {Java} Performance Issue},
  year = {2000},
  volume = {39},
  pages = {28},
  number = {1},
  url = {http://www.research.ibm.com/journal/sj/391/alpern.pdf}
}

@INPROCEEDINGS{altekar05opus,
  author = {Gautam Altekar and Ilya Bagrak and Paul Burstein and Andrew Schultz},
  title = {OPUS: Online Patches and Updates for Security},
  booktitle = {SSYM'05: In 14th USENIX Security Symp.},
  abstract = {We present OPUS, a tool for dynamic software patching capable of applying
	fixes to a C program at runtime. OPUSâs primary goal is to enable
	application of security patches to interactive applications that
	are a frequent target of security exploits. By restricting the type
	of patches admitted by our system, we are able to significantly reduce
	any additional burden on the programmer beyond what would normally
	be required in developing and testing a conventional stop-and-restart
	patch. We hand-tested 26 real CERT [1] vulnerabilities, of which
	22 were dynamically patched with our current OPUS prototype, doing
	so with negligible runtime overhead and no prior knowledge of the
	toolâs existence on the patch programmerâs part.},
  owner = {Mathias Payer},
  timestamp = {2012.01.27}
}

@INPROCEEDINGS{ammons97,
  author = {Glenn Ammons and Thomas Ball and James R. Larus},
  title = {Exploiting hardware performance counters with flow and context sensitive
	profiling},
  booktitle = {Proc. of the ACM SIGPLAN 1997 conference on Programming Language
	Design and Implementation (PLDI~1997)},
  year = {1997},
  pages = {85--96},
  doi = {http://doi.acm.org/10.1145/258915.258924},
  isbn = {0-89791-907-6},
  location = {Las Vegas, Nevada, United States}
}

@ARTICLE{Appel:GC,
  author = {A. W. Appel},
  title = {Simple generational garbage collection and fast allocation},
  journal = {Softw. Pract. Exper.},
  year = {1989},
  volume = {19},
  pages = {171--183},
  number = {2},
  issn = {0038-0644},
  publisher = {John Wiley \& Sons, Inc.}
}

@ARTICLE{CVE-2009-3586,
  author = {Patroklos Argyroudis},
  title = {{CVE-2009-3586}: {CoreHTTP} web server off-by-one buffer overflow
	vulnerability},
  journal = {\url{http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3586}},
  year = {2009},
  owner = {gannimo},
  timestamp = {2012.01.26}
}

@INPROCEEDINGS{arnold09ksplice,
  author = {Jeff Arnold and M. Frans Kaashoek},
  title = {Ksplice: automatic rebootless kernel updates},
  booktitle = {EuroSys'09},
  ee = {http://doi.acm.org/10.1145/1519065.1519085}
}

@INPROCEEDINGS{JikesAOS,
  author = {Matthew Arnold and Stephen Fink and David Grove and Michael Hind
	and Peter F. Sweeney},
  title = {Adaptive optimization in the {J}alapeno JVM},
  booktitle = {Proc. of the 15th ACM SIGPLAN conference on Object-Oriented Programming,
	Systems, Languages, and Applications (OOPSLA~2000)},
  year = {2000},
  pages = {47--65},
  doi = {http://doi.acm.org/10.1145/353171.353175},
  isbn = {1-58113-200-X},
  location = {Minneapolis, Minnesota, United States}
}

@INPROCEEDINGS{Arnold:JavaFDO,
  author = {Matthew Arnold and Michael Hind and Barbara G. Ryder},
  title = {Online feedback-directed optimization of Java},
  booktitle = {Proceedings of the 17th ACM SIGPLAN conference on Object-Oriented
	Programming, Systems, Languages, and Applications (OOPSLA~2002)},
  year = {2002},
  pages = {111--129},
  doi = {http://doi.acm.org/10.1145/582419.582432},
  isbn = {1-58113-471-1},
  location = {Seattle, Washington, USA}
}

@INPROCEEDINGS{attanasio01comparative,
  author = {C. Attanasio and D. Bacon and A. Cocchi and S. Smith},
  title = {A Comparative Evaluation of Parallel Garbage Collectors},
  booktitle = {Fourteenth Annual {WOrkshop} on Languages and Compilers for Parallel
	Computing},
  year = {2001},
  abstract = {While uniprocessor garbage collection is relatively well understood,
	experience with collectors for large multiprocessor servers is limited
	and it is unknown which techniques best scale with large memories
	and large numbers of processors. In order to explore these issues
	we designed a modular

	garbage collection framework in the IBM Jalapeno Java virtual machine
	and implemented five different parallel garbage collectors: non-generational
	and generational versions of mark-and-sweep and semi-space copying
	collectors, as well as a hybrid of the two. We describe the optimizations
	necessary to achieve good performance across all of the collectors,
	including load balancing, fast synchronization, and inter-processor
	sharing of free lists. We then quantitatively compare the different
	collectors to find their asymptotic performance both with respect
	to how fast they can run applications as well as how little memory
	they can run them in. All of our collectors scale linearly up to
	sixteen processors. The least memory is usually required by the hybrid
	mark-sweep collector that uses a copying collector for its nursery,
	although sometimes the non-generational mark-sweep collector requires
	less memory. The fastest execution is more application-dependent.
	Our only application with a large working set performed best using
	the mark-sweep collector; with one exception, the rest of the applications
	ran fastest with one of the generational collectors.},
  citeseerurl = {citeseer.ist.psu.edu/attanasio01comparative.html},
  keywords = {mark and sweep, copy space, garbage collection, jikes rvm, generational,
	non-generational, parallel tracing},
  review = {Mark & Sweep - and CopySpace GC compared for JikesRVM (both gen &
	non-gen).


	-> All support parallel tracing

	-> Jikes MxN multiplexing helps to find safe points faster


	printed -> 1},
  url = {citeseer.ist.psu.edu/attanasio01comparative.html}
}

@INPROCEEDINGS{avgerinos11ndss,
  author = {Thanassis Avgerinos and Sang Kil Cha and Brent Lim Tze Hao and David
	Brumley},
  title = {AEG: Automatic Exploit Generation},
  booktitle = {NDSS'11},
  abstract = {The automatic exploit generation challenge is givena program, automatically
	find vulnerabilities and gener-ate exploits for them. In this paper
	we present AEG, thefirst end-to-end system for fully automatic exploit
	gener-ation. We used AEG to analyze 14 open-source projectsand successfully
	generated 16 control flow hijacking ex-ploits. Two of the generated
	exploits (expect-5.43 and htget-0.93) are zero-day exploits against
	unknown vul-nerabilities. Our contributions are: 1) we show howexploit
	generation for control flow hijack attacks can bemodeled as a formal
	verification problem, 2) we pro-pose preconditioned symbolic execution,
	a novel tech-nique for targeting symbolic execution, 3) we present
	ageneral approach for generating working exploits oncea bug is found,
	and 4) we build the first end-to-end sys-tem that automatically finds
	vulnerabilities and gener-ates exploits that produce a shell.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://www.isoc.org/isoc/conferences/ndss/11/pdf/5_5.pdf},
  owner = {Mathias Payer},
  timestamp = {2012.01.25}
}

@INPROCEEDINGS{bala00dynamo,
  author = {Vasanth Bala and Evelyn Duesterwald and Sanjeev Banerjia},
  title = {{Dynamo}: a transparent dynamic optimization system},
  booktitle = {PLDI '00},
  year = {2000},
  pages = {1--12},
  isbn = {1-58113-199-2},
  journal = {ACM SIG{\-}PLAN Notices},
  owner = {Mathias Payer},
  review = {- binary tanslation

	- extracts and executes traces

	- for hp pa-8000 workstations},
  timestamp = {2008.02.08},
  url = {citeseer.ist.psu.edu/bala00dynamo.html}
}

@INPROCEEDINGS{balzarotti10ndss,
  author = {Davide Balzarotti and Marco Cova and Christoph Karlberger and Engin
	Kirda and Christopher Kruegel and Giovanni Vigna},
  title = {Efficient Detection of Split Personalities in Malware},
  booktitle = {NDSS'10: Proc. Network and Distributed System Security Symp.},
  year = {2010},
  ee = {http://www.isoc.org/isoc/conferences/ndss/10/pdf/24.pdf},
  owner = {Mathias Payer},
  timestamp = {2012.04.26}
}

@MISC{barabash03mostly,
  author = {K. Barabash and Y. Ossia and E. Petrank},
  title = {Mostly concurrent garbage collection revisited},
  year = {2003},
  abstract = {The mostly concurrent garbage collection was presented in

	the seminal paper of Boehm et al. With the deployment of

	Java as a portable, secure and concurrent programming language,

	the mostly concurrent garbage collector turned out

	to be an excellent solution for Java's garbage collection task.

	The use of this collector is reported for several modern production

	Java Virtual Machines and it has been investigated

	further in academia.},
  keywords = {parallel gc, boehm, concurrent, java},
  owner = {Mathias Payer},
  review = {extends boehms mostly concurrent gc


	boehm:sync get roots & mark them concurrently, cords/pages get dirt
	& are then cleaned. Sync cleaning of last cards & sweep (concurrently)


	extension: if a page is dirty, then do not scan the object on this
	page in the first scan phase because it will be rescanned anyway


	print -> 1},
  text = {Katherine Barabash, Yoav Ossia, and Erez Petrank. Mostly concurrent
	garbage collection revisited. In Object-Oriented Programming, Systems,
	Languages, and Applications (OOPSLA), 2003.},
  timestamp = {2007.10.04},
  url = {citeseer.ist.psu.edu/barabash03mostly.html}
}

@INPROCEEDINGS{libsafelibverify00baratloo,
  author = {Baratloo, Arash and Singh, Navjot and Tsai, Timothy},
  title = {Transparent run-time defense against stack smashing attacks},
  booktitle = {Proc. Usenix ATC},
  year = {2000},
  pages = {251--262},
  abstract = {The exploitation of buffer overflow vulnerabilities in process stacks
	constitutes a significant portion of security attacks. We present
	two new methods to detect and handle such attacks. In contrast to
	previous work, the new methods work with any existing pre-compiled
	executable and can be used transparently per-process as well as on
	a system-wide basis. The first method intercepts all calls to library
	functions known to be vulnerable. A substitute version of the corresponding
	function implements the original functionality, but in a manner that
	ensures that any buffer overflows are contained within the current
	stack frame. The second method uses binary modification of the process
	memory to force verification of critical elements of stacks before
	use. We have implemented both methods on Linux as dynamically loadable
	libraries and shown that both libraries detect several known attacks.
	The performance overhead of these libraries range from negligible
	to 15%.},
  location = {San Diego, California},
  owner = {Mathias Payer},
  timestamp = {2010.10.28}
}

@INPROCEEDINGS{xen03barham,
  author = {Paul Barham and Boris Dragovic and Keir Fraser and Steven Hand and
	Tim Harris and Alex Ho and Rolf Neugebauer and Ian Pratt and Andrew
	Warfield},
  title = {Xen and the art of virtualization},
  booktitle = {SOSP'03},
  abstract = {Numerous systems have been designed which use virtualization to subdivide
	the ample resources of a modern computer. Some require specialized
	hardware, or cannot support commodity operating systems. Some target
	100% binary compatibility at the expense of performance. Others sacrifice
	security or functionality for speed. Few offer resource isolation
	or performance guarantees; most provide only best-effort provisioning,
	risking denial of service.This paper presents Xen, an x86 virtual
	machine monitor which allows multiple commodity operating systems
	to share conventional hardware in a safe and resource managed fashion,
	but without sacrificing either performance or functionality. This
	is achieved by providing an idealized virtual machine abstraction
	to which operating systems such as Linux, BSD and Windows XP, can
	be ported with minimal effort.Our design is targeted at hosting up
	to 100 virtual machine instances simultaneously on a modern server.
	The virtualization approach taken by Xen is extremely efficient:
	we allow operating systems such as Linux and Windows XP to be hosted
	simultaneously for a negligible performance overhead --- at most
	a few percent compared with the unvirtualized case. We considerably
	outperform competing commercial and freely available solutions in
	a range of microbenchmarks and system-wide tests.},
  doi = {http://doi.acm.org/10.1145/945445.945462},
  isbn = {1-58113-757-5},
  keywords = {xen, virtualization, vmm, para-virtualization},
  location = {Bolton Landing, NY, USA},
  owner = {Mathias Payer},
  review = {Paravirtualizaton


	general article about xen

	-> virtualization on different rings and guest-kernel adaptation


	ring 0: xen

	ring 1: guest os

	ring 3: app


	+ fast, low overhead, simple

	- modification of guest, guest in ring 1 (not 0!), security leaks?


	print -> 1},
  timestamp = {2007.10.04}
}

@ARTICLE{barrantes05tiss,
  author = {Elena Gabriela Barrantes and David H. Ackley and Stephanie Forrest
	and Darko StefanoviÄ},
  title = {Randomized instruction set emulation},
  journal = {ACM Transactions on Information System Security},
  year = {2005},
  volume = {8},
  pages = {3--40},
  abstract = {Injecting binary code into a running program is a common form of attack.
	Most defenses employ a âguard the doors â approach, blocking known
	mechanisms of code injection. Randomized instruction set emulation
	(RISE) is a complementary method of defense, one that performs a
	hidden randomization of an applicationâs machine code. If foreign
	binary code is injected into a program running under RISE, it will
	not be executable because it will not know the proper randomization.
	The paper describes and analyzes RISE, describing a proof-of-concept
	implementation built on the open-source Valgrind IA32-to-IA32 translator.
	The prototype effectively disrupts binary code injection attacks,
	without requiring recompilation, linking, or access to application
	source code. Under RISE, injected code (attacks) essentially executes
	random code sequences. Empirical studies and a theoretical model
	are reported which treat the effects of executing random code on
	two different architectures (IA32 and PowerPC). The paper discusses
	possible extensions and applications of the RISE technique in other
	contexts.}
}

@INPROCEEDINGS{andre:piranha,
  author = {Luiz Andre; Barroso and Kourosh Gharachorloo and Robert McNamara
	and Andreas Nowatzyk and Shaz Qadeer and Barton Sano and Scott Smith
	and Robert Stets and Ben Verghese},
  title = {Piranha: a scalable architecture based on single-chip multiprocessing},
  booktitle = {ISCA '00: Proceedings of the 27th annual international symposium
	on Computer architecture},
  year = {2000},
  pages = {282--293},
  doi = {http://doi.acm.org/10.1145/339647.339696},
  isbn = {1-58113-232-8},
  location = {Vancouver, British Columbia, Canada}
}

@ARTICLE{apparmor06,
  author = {Bauer, Mick},
  title = {Paranoid penguin: an introduction to {Novell} {AppArmor}},
  journal = {Linux J.},
  year = {2006},
  volume = {2006},
  pages = {13},
  number = {148},
  issn = {1075-3583},
  owner = {Mathias Payer},
  publisher = {Specialized Systems Consultants, Inc.},
  timestamp = {2010.10.28}
}

@ARTICLE{baug08iosyscallsintm,
  author = {Baugh, L. and Zilles, C.},
  title = {An Analysis of I/O And Syscalls In Critical Sections And Their Implications
	For Transactional Memory},
  journal = {Performance Analysis of Systems and software, 2008. ISPASS 2008.
	IEEE International Symposium on},
  year = {2008},
  pages = {54-62},
  month = {April},
  abstract = {Transactional memory (TM) is a scalable and concurrent way to build
	atomic sections. One aspect of TM that remains unclear is how side-effecting
	operations - that is, those which cannot be transparently undone
	by a TM system - should be handled. This uncertainty poses a significant
	barrier to the general applicability and acceptance of TM. Further,
	the absence of transactional workloads makes it difficult to study
	this aspect In this paper, we characterize the usage of I/O, and
	in particular system calls, within critical sections in two large
	applications, exploring both the actions performed and the characteristics
	of the critical sections in which they are performed. Shared memory
	programs employing critical sections are the closest approximation
	available to transactional workloads, so using this characterization,
	we attempt to reason about how the behavior we observed relates to
	the previous proposals for handling side-effecting operations within
	transactions. We find that the large majority of syscalls performed
	within critical sections can be handled with a range of existing
	techniques in a way transparent to the application developer. We
	also find that while side-effecting critical sections are rare, they
	tend to be quite long-lasting, and that many of these critical sections
	perform their first syscall (and thus become side-effecting) relatively
	early in their execution. Finally, we show that while these long-lived,
	side-effecting critical sections tend to execute concurrently with
	many critical sections on other threads, we observe little concurrency
	between side-effecting critical sections.},
  doi = {10.1109/ISPASS.2008.4510738},
  keywords = {STM, TM, I/O, syscall},
  owner = {Mathias Payer},
  review = {how to handle side-effects in tranactions?


	outlaw (no real work), defer (txn need results), supertxn (commit
	token 'stalls' other txns) -> do not work!

	compensate -> works


	need for lib-code that handles compensate


	syscalls hould not be executed transactionally (high overhead - 21)

	txn safe system libs & tnx-fs as solution!


	print -> 1},
  timestamp = {2008.08.10}
}

@INPROCEEDINGS{qemu05bellard,
  author = {Fabrice Bellard},
  title = {{QEMU}, a fast and portable dynamic translator},
  booktitle = {Proc. Usenix ATC},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@INPROCEEDINGS{Berndl2003,
  author = {Berndl, M. and Hendren, L.},
  title = {Dynamic profiling and trace cache generation},
  booktitle = {Code Generation and Optimization, 2003. CGO 2003. International Symposium
	on},
  year = {2003},
  pages = {276--285},
  month = {23-26 March},
  doi = {10.1109/CGO.2003.1191552},
  file = {01191552.pdf:http\://ieeexplore.ieee.org/iel5/8475/26704/01191552.pdf:PDF},
  keywords = {dynamic translation, traces for an interpreting jvm},
  owner = {Mathias Payer},
  review = {extracts traces for an interpreting jvm


	print -> 1},
  timestamp = {2007.10.04}
}

@INPROCEEDINGS{bhatkar03addressobfuscation,
  author = {Eep Bhatkar and Daniel C. Duvarney and R. Sekar},
  title = {Address obfuscation: an efficient approach to combat a broad range
	of memory error exploits},
  booktitle = {SSYM'03: Proc. 12th USENIX Security Symp.},
  year = {2003},
  pages = {105--120},
  abstract = {Attacks which exploit memory programming errors (such as buffer overflows)
	are one of todayâs most seri ous security threats. These attacks
	require an attacker to have an in-depth understanding of the internal
	details of a victim program, including the locations of critical
	data and/or code. Program obfuscation is a general technique for
	securing programs by making it difficult for attackers to acquire
	such a detailed understanding. This paper de- velops a systematic
	study of a particular kind of obfusca- tion called address obfuscation
	that randomizes the loca- tion of victim program data and code. We
	discuss differ- ent implementation strategies to randomize the absolute
	locations of data and code, as well as relative distances between
	data locations. We then present our implemen- tation that transforms
	object files and executables at link- time and load-time. It requires
	no changes to the OS ker- nel or compilers, and can be applied to
	individual appli- cations without affecting the rest of the system.
	It can be implemented with low runtime overheads. Address ob- fuscation
	can reduce the probability of successful attacks to be as low as
	a small fraction of a percent for most memory-error related attacks.
	Moreover, the random- ization ensures that an attack that succeeds
	against one victim will likely not succeed against another victim,
	or even for a second time against the same victim. Each failed attempt
	will typically crash the victim program, thereby making it easy to
	detect attack attempts. These aspects make it particularly effective
	against large-scale attacks such as Code Red, since each infection
	attempt requires significantly more resources, thereby slowing down
	the propagation rate of such attacks.},
  owner = {Mathias Payer},
  timestamp = {2010.10.19}
}

@INPROCEEDINGS{bhatkar05efficientaslr,
  author = {Sandeep Bhatkar and Eep Bhatkar and R. Sekar and Daniel C. Duvarney},
  title = {Efficient Techniques for Comprehensive Protection from Memory Error
	Exploits},
  booktitle = {SSYM'05: Proc. 14th USENIX Security Symp.},
  year = {2005},
  pages = {255--270},
  owner = {Mathias Payer},
  timestamp = {2010.10.19}
}

@TECHREPORT{bishop95tr,
  author = {Matt Bishop},
  title = {Checking for race conditions in file accesses},
  institution = {University of California at Davis},
  year = {1995},
  abstract = {A pernicious type of security problem, race conditions create a timing
	interval in which the manipulation of resources allows an attacker
	to gain privileges, read and alter protected files, and violate the
	security policy of the site. The majority of these conditions found
	on applications and system programs in the UNIX operating system
	arise during file system manipulation and file accesses. This paper
	discusses why race conditions arise, presents some examples, and
	explores ways to alleviate the problem of their occurrence in programs,
	both through modification of system calls and careful programming.
	A tool to scan for potential race conditions, as well as a library
	function to analyze the environment dynamically at run time (and
	thus detect such conditions) are presented.},
  owner = {Mathias Payer},
  timestamp = {2011.05.10}
}

@ARTICLE{bishop96cs,
  author = {Matt Bishop and Michael Dilger},
  title = {Checking for Race Conditions in File Accesses},
  journal = {Journal for Computing Systems},
  year = {1996},
  pages = {131--152},
  abstract = {Flaws due to race conditions in which the binding of a name to an
	object changes between repeated references occur in many programs.
	We examine one type of this flaw in the UNIX operating system, and
	describe a semantic method for detecting possible instances of this
	problem. We present the results of one such analysis in which a previously
	undiscovered race condition flaw was found.},
  owner = {Mathias Payer},
  review = {Defines TOCTTOU for files, early foundation paper},
  timestamp = {2011.05.10}
}

@INPROCEEDINGS{GCIMPACT-BLACKBURN04,
  author = {Stephen M. Blackburn and Perry Cheng and Kathryn S. McKinley},
  title = {Myths and realities: the performance impact of garbage collection},
  booktitle = {SIGMETRICS 2004/PERFORMANCE 2004: Proceedings of the joint international
	conference on Measurement and modeling of computer systems},
  year = {2004},
  pages = {25--36},
  doi = {http://doi.acm.org/10.1145/1005686.1005693},
  isbn = {1-58113-873-3},
  location = {New York, NY, USA}
}

@INPROCEEDINGS{Jikes-MMTk,
  author = {Stephen M. Blackburn and Perry Cheng and Kathryn S. McKinley},
  title = {Oil and Water? High Performance Garbage Collection in Java with MMTk},
  booktitle = {ICSE '04: Proceedings of the 26th International Conference on Software
	Engineering},
  year = {2004},
  pages = {137--146},
  isbn = {0-7695-2163-0}
}

@INPROCEEDINGS{1029891,
  author = {Stephen M. Blackburn and Antony L. Hosking},
  title = {Barriers: friend or foe?},
  booktitle = {ISMM '04: Proceedings of the 4th international symposium on Memory
	management},
  year = {2004},
  pages = {143--151},
  doi = {http://doi.acm.org/10.1145/1029873.1029891},
  isbn = {1-58113-945-4},
  location = {Vancouver, BC, Canada}
}

@TECHREPORT{blackburn04dacapo,
  author = {S. M. Blackburn and K. S. McKinley and J. E. B. Moss and S. Augart
	and E. D. Berger and P. Cheng a nd A. Diwan and S. Guyer and M. Hirzel
	and C. Hoffman and A. Hosking and X. Huang and A. Khan and P. McGachey
	and D. Stefanovic and B. Wiedermann},
  title = {The DaCapo benchmarks},
  institution = {DaCapo group},
  year = {2004},
  url = {http://ali-www.cs.umass.edu/DaCapo/Benchmarks}
}

@ARTICLE{blackngel10malloc,
  author = {blackngel},
  title = {The House Of Lore: Reloaded},
  journal = {Phrack},
  year = {2010},
  volume = {14},
  pages = {http://phrack.com/issues.html?issue=67\&id=8},
  number = {67},
  month = nov,
  chapter = {8},
  keywords = {buffer-overflow, c, security, software, vulnerability},
  owner = {Mathias Payer},
  review = {The House of Lore describes a set of attacks against the ptmalloc
	memory allocator. Depending on a sequence of free/malloc calls and
	some buffer overflows (or random writes to memory) malloc can be
	tricked to execute arbitrary code.},
  url = {http://phrack.com/issues.html?issue=67\&id=8\#article}
}

@INPROCEEDINGS{blelloch99bounding,
  author = {Guy E. Blelloch and Perry Cheng},
  title = {On Bounding Time and Space for Multiprocessor Garbage Collection},
  booktitle = {{SIGPLAN} Conference on Programming Language Design and Implementation},
  year = {1999},
  pages = {104-117},
  abstract = {This paper presents the first multiprocessor garbage collection

	algorithm with provable bounds on time and

	space. The algorithm is a real-time shared-memory

	copying collector. We prove that the algorithm requires

	at most 2(R(1 + 2=k) + N + 5PD) memory locations,

	where P is the number of processors, R is the maximum

	reachable space during a computation (number of locations

	accessible from the root set), N is the maximum

	number of reachable objects, D is the maximum depth

	of any data object, and k is a parameter specifying how

	many locations are copied each time a location is allocated.

	Furthermore we show that client threads are

	never stopped for more than time proportional to k nonblocking

	machine instructions. The bounds are guaranteed

	even with arbitrary length arrays. The collector

	only requires write-barriers (reads are unaffected by

	the collector), makes few assumptions about the threads

	that are generating the garbage, and allows them to run

	mostly asynchronously.},
  keywords = {multiprocessor garbage collection},
  owner = {Mathias Payer},
  review = {Copy, but time & space bounded

	-> Multiprocessor => Parallel collection, interleaved with application


	print -> 1},
  timestamp = {2007.10.04},
  url = {citeseer.ist.psu.edu/blelloch99bounding.html}
}

@INPROCEEDINGS{bletsch11asiaccs,
  author = {Bletsch, Tyler and Jiang, Xuxian and Freeh, Vince W. and Liang, Zhenkai},
  title = {Jump-oriented programming: a new class of code-reuse attack},
  booktitle = {ASIACCS'11: Proc. 6th ACM Symp. on Information, Computer and Communications
	Security},
  year = {2011},
  pages = {30--40},
  abstract = {Return-oriented programming is an effective code-reuse attack in which
	short code sequences ending in a ret instruction are found within
	existing binaries and executed in arbitrary order by taking control
	of the stack. This allows for Turing-complete behavior in the target
	program without the need for injecting attack code, thus significantly
	negating current code injection defense efforts (e.g., WâX). On the
	other hand, its inherent characteristics, such as the reliance on
	the stack and the consecutive execution of return-oriented gadgets,
	have prompted a variety of defenses to detect or prevent it from
	happening.


	In this paper, we introduce a new class of code-reuse attack, called
	jump-oriented programming. This new attack eliminates the reliance
	on the stack and ret instructions (including ret-like instructions
	such as pop+jmp) seen in return-oriented programming without sacrificing
	expressive power. This attack still builds and chains functional
	gadgets, each performing certain primitive operations, except these
	gadgets end in an indirect branch rather than ret. Without the convenience
	of using ret to unify them, the attack relies on a dispatcher gadget
	to dispatch and execute the functional gadgets. We have successfully
	identified the availability of these jump-oriented gadgets in the
	GNU libc library. Our experience with an example shellcode attack
	demonstrates the practicality and effectiveness of this technique.},
  acmid = {1966919},
  doi = {http://doi.acm.org/10.1145/1966913.1966919},
  isbn = {978-1-4503-0564-8},
  location = {Hong Kong, China},
  numpages = {11},
  owner = {Mathias Payer},
  review = {jump oriented programming (successor of return oriented programming)


	was already known and used in hacker culture when it was published},
  timestamp = {2011.07.13},
  url = {http://doi.acm.org/10.1145/1966913.1966919}
}

@ARTICLE{bloomfilter,
  author = {Bloom, Burton H.},
  title = {Space/time trade-offs in hash coding with allowable errors},
  journal = {Commun. ACM},
  year = {1970},
  volume = {13},
  number = {7},
  doi = {http://doi.acm.org/10.1145/362686.362692},
  issn = {0001-0782},
  owner = {Mathias Payer},
  publisher = {ACM},
  timestamp = {2009.05.27}
}

@INPROCEEDINGS{boehmtm,
  author = {Boehm, Hans-J.},
  title = {Transactional memory should be an implementation technique, not a
	programming interface},
  booktitle = {HotPar'09: Proceedings of the First USENIX conference on Hot topics
	in parallelism},
  year = {2009},
  pages = {15--15},
  abstract = {Transactional memory is often advocated as an easier to use replacement
	for locks that avoids any possibility of deadlock. Recently, as more
	care has been exercised in precisely specifying its semantics, a
	number of researchers have observed that probably the most attractive
	semantics for transactional memory systems is based on "single global
	lock atomicity", i.e. on the semantics of a single global lock. We
	argue that this should be taken one step further: The synchronization
	operations seen by the programmer should really just be locks, possibly
	with some syntactic sugar for easier programming with a single global
	lock.


	Use as a deadlock-free lock replacement does not require any rollback
	primitive, or any other constructs that expose properties of the
	implementation. And it appears that such extensions add considerable
	complexity. Instead, the implementation should strive to optimize
	coarse-grain locks, for example by implementing them using transactional
	techniques.},
  keywords = {TM},
  location = {Berkeley, California},
  owner = {Mathias Payer},
  timestamp = {2010.09.27}
}

@INPROCEEDINGS{borisov05usenix,
  author = {Nikita Borisov and Rob Johnson and Naveen Sastry and David Wagner},
  title = {Fixing races for fun and profit: how to abuse atime},
  booktitle = {SSYM'05: 14th USENIX Security Symp.},
  year = {2005},
  pages = {303--314},
  abstract = {Dean and Hu proposed a probabilistic countermeasure to the classic
	access(2)/open(2) TOCTTOU race condition in privileged Unix programs
	[4]. In this paper, we describe an attack that succeeds with very
	high probability against their countermeasure. We then consider a
	stronger randomized variant of their defense and show that it, too,
	is broken. We conclude that access(2) must never be used in privileged
	Unix programs. The tools we develop can be used to attack other filesystem
	races, underscoring the importance of avoiding such races in secure
	software. 1},
  owner = {Mathias Payer},
  timestamp = {2011.09.09}
}

@ARTICLE{briggs98practical,
  author = {Preston Briggs and Keith D. Cooper and Timothy J. Harvey and L. Taylor
	Simpson},
  title = {Practical Improvements to the Construction and Destruction of Static
	Single Assignment Form},
  journal = {Software: Practice and Experience},
  year = {1998},
  volume = {28},
  pages = {859--881},
  number = {8},
  url = {citeseer.nj.nec.com/briggs98practical.html}
}

@misc{brown11breakingloader,
  author = {Tim Brown},
  title = {Breaking the links: Exploiting the linker},
  institution = {nth-dimension},
  year = {2011},
  abstract = {The recent discussion relating to insecure library loading on the
	Microsoft Windows platform provoked a signicant amount of debate
	as to whether GNU/Linux and UNIX variants could be vulnerable to
	similar attacks. Whilst the general consensus of the Slashdot herd
	appeared to be that this was just another example of Microsoft doing
	things wrong, I felt this was unfair and responded with a blog post[1]
	that sought to highlight an example of where POSIX style linkers
	get things wrong. Based on the feedback I received to that post,
	I decided to investigate the issue a little further. This paper is
	an amalgamation of what I learnt. As such it contains my own research,
	the discoveries of others and POSIX lore.},
  howpublished = {\url{http://www.nth-dimension.org.uk/pub/BTL.pdf}},
  owner = {Mathias Payer},
  timestamp = {2011.05.10}
}

@INPROCEEDINGS{bruening05codecache,
  author = {Derek Bruening and Saman Amarasinghe},
  title = {Maintaining Consistency and Bounding Capacity of Software Code Caches},
  booktitle = {CGO '05},
  year = {2005},
  pages = {74--85},
  doi = {http://dx.doi.org/10.1109/CGO.2005.19},
  isbn = {0-7695-2298-X},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@INPROCEEDINGS{bruening00design,
  author = {D. Bruening and E. Duesterwald and S. Amarasinghe},
  title = {Design and implementation of a dynamic optimization framework for
	{W}indows},
  booktitle = {ACM Workshop Feedback-directed Dyn. Opt. (FDDO-4)},
  year = {2001},
  owner = {Mathias Payer},
  timestamp = {2008.07.30},
  url = {citeseer.ist.psu.edu/bruening00design.html}
}

@INPROCEEDINGS{bruening03dynamorio,
  author = {Derek Bruening and Timothy Garnett and Saman Amarasinghe},
  title = {An infrastructure for adaptive dynamic optimization},
  booktitle = {CGO '03},
  isbn = {0-7695-1913-X},
  location = {San Francisco, California},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@INPROCEEDINGS{bruening06threadshared,
  author = {Derek Bruening and Vladimir Kiriansky and Timothy Garnett and Sanjeev
	Banerji},
  title = {Thread-Shared Software Code Caches},
  booktitle = {CGO '06},
  year = {2006},
  pages = {28--38},
  doi = {http://dx.doi.org/10.1109/CGO.2006.36},
  isbn = {0-7695-2499-0},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@INPROCEEDINGS{brumley08sp,
  author = {David Brumley and Pongsin Poosankam and Dawn Xiaodong Song and Jiang
	Zheng},
  title = {Automatic Patch-Based Exploit Generation is Possible: Techniques
	and Implications},
  booktitle = {IEEE S\&P'08},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://doi.ieeecomputersociety.org/10.1109/SP.2008.17},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@MISC{vmware04patent,
  author = {Edouard Bugnion},
  title = {Dynamic binary translator with a system and method for updating and
	maintaining coherency of a translation cache},
  howpublished = {US Patent 6704925},
  month = {March},
  year = {2004},
  owner = {Mathias Payer},
  timestamp = {2008.09.01}
}

@ARTICLE{265930,
  author = {Edouard Bugnion and Scott Devine and Kinshuk Govil and Mendel Rosenblum},
  title = {Disco: running commodity operating systems on scalable multiprocessors},
  journal = {ACM Trans. Comput. Syst.},
  year = {1997},
  volume = {15},
  pages = {412--447},
  number = {4},
  abstract = {In this article we examine the problem of extending modern operating
	systems to run efficiently on large-scale shared-memory multiprocessors
	without a large implementation effort. Our approach brings back an
	idea popular in the 1970s: virtual machine monitors. We use virtual
	machines to run multiple commodity operating systems on a scalable
	multiprocessor. This solution addresses many of the challenges facing
	the system software for these machines. We demonstrate our approach
	with a prototype called Disco that runs multiple copies of Silicon
	Graphics' IRIX operating system on a multiprocessor. Our experience
	shows that the overheads of the monitor are small and that the approach
	provides scalability as well as the ability to deal with the nonuniform
	memory access time of these systems. To reduce the memory overheads
	associated with running multiple operating systems, virtual machines
	transparently share major data structures such as the program code
	and the file system buffer cache. We use the distributed-system support
	of modern operating systems to export a partial single system image
	to the users. The overall solution achieves most of the benefits
	of operating systems customized for scalable multiprocessors, yet
	it can be achieved with a significantly smaller implementation effort.},
  doi = {http://doi.acm.org/10.1145/265924.265930},
  issn = {0734-2071},
  keywords = {virtualization, slim os},
  owner = {Mathias Payer},
  review = {Multiprocessor machine -> special OS ('Disco')

	UMA simulated, resources and memory sharing

	-> split processes to different VMs, special SW-TLB and add phys2hw
	mem-mapping table

	Traps go to VMM

	Changes to guest os & slim special guest OS


	only 4GB ram per VM (no virtual memory)


	similar to exokernel, but virtualize resources rather than multiplexing


	print -> 1},
  timestamp = {2007.10.04}
}

@INPROCEEDINGS{JikesOptCompiler,
  author = {Michael Burke and Jong-Deok Choi and Stephen Fink and David Grove
	and Michael Hind and Vivek Sarkar and Mauricio Serrano and V.C. Sreedhar
	and Harini Srinivasan},
  title = {The {Jalapeno} Dynamic Optimizing Compiler for Java},
  booktitle = {1999 ACM Java Grande Conference, San Francisco, June 12-14, 1999},
  year = {1999}
}

@INPROCEEDINGS{stamp,
  author = {Cao Minh, Chi and Chung, JaeWoong and Kozyrakis, Christos and Olukotun,
	Kunle},
  title = {{STAMP}: Stanford Transactional Applications for Multi-Processing},
  booktitle = {IISWC'08},
  year = {2008},
  month = {Sept.},
  owner = {Mathias Payer},
  timestamp = {2009.07.07}
}

@ARTICLE{cascaval08stmresearchtoy,
  author = {Calin Cascaval and Colin Blundell and Maged Michael and Harold W.
	Cain and Peng Wu and Stefanie Chiras and Siddhartha Chatterjee},
  title = {Software Transactional Memory: why is it only a research toy?},
  journal = {Queue},
  year = {2008},
  volume = {6},
  pages = {46--58},
  number = {5},
  abstract = {STM is sometimes touted as the way forward for developing concurrent
	software, but is it ready for use in real-world applications? The
	authors built an STM runtime system and compiler framework, the IBM
	STM, and compared its performance to other similar products by Intel
	and Sun. They conclude that from both performance and productivity
	standpoints, STM still has a long way to go before it can be viable
	in the real world.},
  doi = {http://doi.acm.org/10.1145/1454456.1454466},
  issn = {1542-7730},
  owner = {Mathias Payer},
  publisher = {ACM},
  review = {Controversal article, that stm is only valid for research and not
	for real programming.


	Too slow, too expensive, too complicated, too unsure! (they say)},
  timestamp = {2008.11.13}
}

@INPROCEEDINGS{chari10ndss,
  author = {Suresh Chari and Shai Halevi and Wietse Venema},
  title = {Where Do You Want to Go Today? Escalating Privileges by Pathname
	Manipulation},
  booktitle = {NDSS},
  year = {2010},
  abstract = {We analyze filename-based privilege escalation attacks, where an attacker
	creates filesystem links, thereby âtrickingâ a victim program into
	opening unintended files. We develop primitives for a POSIX environment,
	providing assurance that files in âsafe directories â (such as /etc/passwd)
	cannot be opened by looking up a file by an âunsafe pathname â (such
	as a pathname that resolves through a symbolic link in a world-writable
	directory). In todayâs UNIX systems, solutions to this problem are
	typically built into (some) applications and use applicationspecific
	knowledge about (un)safety of certain directories. In contrast, we
	seek solutions that can be implemented in the filesystem itself (or
	a library on top of it), thus providing protection to all applications.
	Our solution is built around the concept of pathname manipulators,
	which are roughly the users that can influence the result of a file
	lookup operation. For each user, we distinguish unsafe pathnames
	from safe pathnames according to whether or not the pathname has
	any manipulators other than that user or root. We propose a safe-open
	procedure that keeps track of the safety of the current pathname
	as it resolves it, and that takes extra precautions while opening
	files with unsafe pathnames. We prove that our solution can prevent
	a common class of filename-based privilege escalation attacks, and
	describe our implementation of the safe-open procedure as a library
	function over the POSIX filesystem interface. We tested our implementation
	on several UNIX variants to evaluate its implications for systems
	and applications. Our experiments suggest that this solution can
	be deployed in a portable way without breaking existing systems,
	and that it is effective against this class of pathname resolution
	attacks.},
  ee = {http://www.isoc.org/isoc/conferences/ndss/10/pdf/19.pdf},
  owner = {Mathias Payer},
  timestamp = {2012.01.03}
}

@INPROCEEDINGS{chase:pointerAnalysis,
  author = {David R. Chase and Mark Wegman and F. Kenneth Zadeck},
  title = {Analysis of pointers and structures},
  booktitle = {PLDI '90: Proceedings of the ACM SIGPLAN 1990 conference on Programming
	language design and implementation},
  year = {1990},
  pages = {296--310},
  doi = {http://doi.acm.org/10.1145/93542.93585},
  isbn = {0-89791-364-7},
  location = {White Plains, New York, United States}
}

@INPROCEEDINGS{checkoway10ccs,
  author = {Stephen Checkoway and Lucas Davi and Alexandra Dmitrienko and Ahmad-Reza
	Sadeghi and Hovav Shacham and Marcel Winandy},
  title = {Return-Oriented Programming without Returns},
  booktitle = {CCS'10: Proceedings of CCS 2010},
  year = {2010},
  editor = {Angelos Keromytis and Vitaly Shmatikov},
  pages = {559-572},
  publisher = {ACM Press},
  abstract = {We show that on both the x86 and ARM architectures it is possible
	to mount return-oriented programming attacks without using return
	instructions. Our attacks instead make use of certain instruction
	sequences that behave like a return, which occur with sufficient
	frequency in large libraries on (x86) Linux and (ARM) Android to
	allow creation of Turing-complete gadget sets.


	Because they do not make use of return instructions, our new attacks
	have negative implications for several recently proposed classes
	of defense against return-oriented programming: those that detect
	the too-frequent use of returns in the instruction stream; those
	that detect violations of the last-in, first-out invariant normally
	maintained for the return-address stack; and those that modify compilers
	to produce code that avoids the return instruction.},
  owner = {Mathias Payer},
  review = {implementing return oriented programming without return instructions},
  timestamp = {2011.08.09},
  url = {https://cs.ucsd.edu/~scheckow/papers/noret_ccs2010.html}
}

@INPROCEEDINGS{chen06vee,
  author = {Chen, Haibo and Chen, Rong and Zhang, Fengzhe and Zang, Binyu and
	Yew, Pen-Chung},
  title = {Live updating operating systems using virtualization},
  booktitle = {VEE'06},
  abstract = {Many critical IT infrastructures require non-disruptive operations.
	However, the operating systems thereon are far from perfect that
	patches and upgrades are frequently applied, in order to close vulnerabilities,
	add new features and enhance performance. To mitigate the loss of
	availability, such operating systems need to provide features such
	as live update through which patches and upgrades can be applied
	without having to stop and reboot the operating system. Unfortunately,
	most current live updating approaches cannot be easily applied to
	existing operating systems: some are tightly bound to specific design
	approaches (e.g. object-oriented); others can only be used under
	particular circumstances (e.g. quiescence states).In this paper,
	we propose using virtualization to provide the live update capability.
	The proposed approach allows a broad range of patches and upgrades
	to be applied at any time without the requirement of a quiescence
	state. Moreover, such approach shares good portability for its OS-transparency
	and is suitable for inclusion in general virtualization systems.
	We present a working prototype, LUCOS, which supports live update
	capability on Linux running on Xen virtual machine monitor. To demonstrate
	the applicability of our approach, we use real-life kernel patches
	from Linux kernel 2.6.10 to Linux kernel 2.6.11, and apply some of
	those kernel patches on the fly. Performance measurements show that
	our implementation incurs negligible performance overhead: a less
	than 1% performance degradation compared to a Xen-Linux. The time
	to apply a patch is also very minimal.},
  acmid = {1134767},
  doi = {http://doi.acm.org/10.1145/1134760.1134767},
  isbn = {1-59593-332-8},
  keywords = {availability, live update, operating system, virtualization},
  location = {Ottawa, Ontario, Canada},
  numpages = {10},
  owner = {Mathias Payer},
  timestamp = {2012.01.27},
  url = {http://doi.acm.org/10.1145/1134760.1134767}
}

@INPROCEEDINGS{chen02mops,
  author = {Hao Chen and David Wagner},
  title = {{MOPS}: an Infrastructure for Examining Security Properties of Software},
  booktitle = {CCS'02: Proc. 9th ACM Conf. Computer and Communications Security},
  year = {2002},
  pages = {235--244},
  owner = {Mathias Payer},
  review = {Use FSA (graphs) to describe program properties (based on system calls).
	Approach extracts system calls from programs and verifies them according
	to given criteria.},
  timestamp = {2011.05.09}
}

@INPROCEEDINGS{chen07polus,
  author = {Haibo Chen and Jie Yu and Rong Chen and Binyu Zang and Pen-chung
	Yew},
  title = {POLUS: A POwerful live updating system},
  booktitle = {ICSE'07},
  abstract = {This paper presents POLUS, a software maintenance tool capable of
	iteratively evolving running software into newer versions. POLUSâs
	primary goal is to increase the dependability of contemporary server
	software, which is frequently disrupted either by external attacks
	or by scheduled upgrades. To render POLUS both practical and powerful,
	we design and implement POLUS aiming to retain backward binary compatibility,
	support for multithreaded software and recover already tainted state
	of running software, yet with good usability and very low runtime
	overhead. To demonstrate the applicability of POLUS, we report our
	experience in using POLUS to dynamically update three prevalent server
	applications: vsftpd, sshd and apache HTTP server. Performance measurements
	show that POLUS incurs negligible runtime overhead: a less than 1%
	performance degradation (but 5 % for one case). The time to apply
	an update is also minimal.},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@INPROCEEDINGS{ping11asiaccs,
  author = {Chen, Ping and Xing, Xiao and Mao, Bing and Xie, Li and Shen, Xiaobin
	and Yin, Xinchun},
  title = {Automatic construction of jump-oriented programming shellcode (on
	the x86)},
  booktitle = {ASIACCS'11: Proc. 6th ACM Symp. on Information, Computer and Communications
	Security},
  year = {2011},
  pages = {20--29},
  publisher = {ACM},
  abstract = {Return-Oriented Programming (ROP) is a technique which leverages the
	instruction gadgets in existing libraries/executables to construct
	Turing complete programs. However, ROP attack is usually composed
	with gadgets which are ending in ret instruction without the corresponding
	call instruction. Based on this fact, several defense mechanisms
	have been proposed to detect the ROP malicious code. To circumvent
	these defenses, Return-Oriented Programming without returns has been
	proposed recently, which uses the gadgets ending in jmp instruction
	but with much diversity. In this paper, we propose an improved ROP
	techniques to construct the ROP shellcode without returns. Meanwhile
	we implement a tool to automatically construct the real-world Return-Oriented
	Programming without returns shellcode, which as demonstrated in our
	experiment can bypass most of the existing ROP defenses.},
  acmid = {1966918},
  doi = {http://doi.acm.org/10.1145/1966913.1966918},
  isbn = {978-1-4503-0564-8},
  numpages = {10},
  owner = {Mathias Payer},
  timestamp = {2011.08.09},
  url = {http://doi.acm.org/10.1145/1966913.1966918}
}

@MISC{chen11windows,
  author = {Raymond Chen},
  title = {Why do Windows functions all begin with a pointless MOV EDI, EDI
	instruction?},
  howpublished = {\url{http://blogs.msdn.com/b/oldnewthing/archive/2011/09/21/10214405.aspx}},
  month = {Sept.},
  year = {2011},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@ARTICLE{chen09instructiongrainlifeguards,
  author = {Chen, S. and Kozuch, M. and Gibbons, P.B. and Ryan, M. and Strigkos,
	T. and Mowry, T.C. and Ruwase, O. and Vlachos, E. and Falsafi, B.
	and Ramachandran, V.},
  title = {Flexible Hardware Acceleration for Instruction-Grain Lifeguards},
  journal = {Micro, IEEE},
  year = {2009},
  volume = {29},
  pages = {62-72},
  number = {1},
  month = {Jan.-Feb. },
  abstract = {Instruction-grain lifeguards monitor executing programs at the granularity
	of individual instructions to quickly detect bugs and security attacks,
	but their fine-grain nature incurs high monitoring overheads. This
	article identifies three common sources of these overheads and proposes
	three techniques that together constitute a general-purpose hardware
	acceleration framework for lifeguards.},
  doi = {10.1109/MM.2009.6},
  issn = {0272-1732},
  keywords = {program debugging, program diagnostics, security of data, software
	reliabilitybug detection, flexible hardware acceleration, instruction-grain
	lifeguard, program monitoring, security attack detection},
  owner = {Mathias Payer},
  review = {Detect mem-access violations, data races, security exploits

	Damage containment, on-site diagnosis, on-the-fly fixes and recovery


	++

	Folder BT},
  timestamp = {2009.05.31}
}

@INPROCEEDINGS{chen09instructiongrainprogrammonitoring,
  author = {Chen, S. and Kozuch, M. and Strigkos, T. and Falsafi, B. and Gibbons,
	P.B. and Mowry, T.C. and Ramachandran, V. and Ruwase, O. and Ryan,
	M. and Vlachos, E.},
  title = {Flexible Hardware Acceleration for Instruction-Grain Program Monitoring},
  year = {2008},
  pages = {377-388},
  month = {June},
  abstract = {Instruction-grain program monitoring tools, which check and analyze
	executing programs at the granularity of individual instructions,
	are invaluable for quickly detecting bugs and security attacks and
	then limiting their damage (via containment and/or recovery). Unfortunately,
	their fine-grain nature implies very high monitoring overheads for
	software-only tools, which are typically based on dynamic binary
	instrumentation. Previous hardware proposals either focus on mechanisms
	that target specific bugs or address only the cost of binary instrumentation.
	In this paper, we propose a flexible hardware solution for accelerating
	a wide range of instruction-grain monitoring tools. By examining
	a number of diverse tools (for memory checking, security tracking,
	and data race detection), we identify three significant common sources
	of overheads and then propose three novel hardware techniques for
	addressing these overheads: Inheritance Tracking, Idempotent Filters,
	and Metadata-TLBs. Together, these constitute a general-purpose hardware
	acceleration framework. Experimental results show our framework reduces
	overheads by 2-3X over the previous state-of-the-art, while supporting
	the needed flexibility.},
  doi = {10.1109/ISCA.2008.20},
  issn = {1063-6897},
  journal = {ISCA '08},
  keywords = {program debugging, program diagnostics, security of datadynamic binary
	instrumentation, flexible hardware acceleration, flexible hardware
	solution, instruction-grain program monitoring, security attacks,
	software-only tools},
  owner = {Mathias Payer},
  review = {3 HW techniques to reduce monitoring (bt) overhead:

	- inheritance tracking (in HW) - where does data come from?

	- idempotent filters - cache recent events

	- metadata TLBs - configurable table lookup for metadata


	++

	folder BT},
  timestamp = {2009.05.31}
}

@INPROCEEDINGS{Chen:GC-LocalityOptimization,
  author = {Wen-ke Chen and Sanjay Bhansali and Trishul Chilimbi and Xiaofeng
	Gao and Weihaw Chuang},
  title = {Profile-guided proactive garbage collection for locality optimization},
  booktitle = {PLDI'06},
  year = {2006},
  pages = {332--340},
  doi = {http://doi.acm.org/10.1145/1133981.1134021},
  isbn = {1-59593-320-4},
  location = {Ottawa, Ontario, Canada}
}

@INPROCEEDINGS{chen08dsn,
  author = {Xu Chen and Jon Andersen and Z. Morley Mao and Michael Bailey and
	Jose Nazario},
  title = {{Towards an Understanding of Anti-Virtualization and Anti-Debugging
	Behavior in Modern Malware}},
  booktitle = {DSN'08: Proc. 38th Annual IEEE Int. Conf. on Dependable Systems and
	Networks},
  year = {2008},
  pages = {177--186},
  month = {June},
  owner = {Mathias Payer},
  review = {VMM detection taxonomy},
  timestamp = {2012.04.26}
}

@INPROCEEDINGS{chen2008overshadow,
  author = {Chen, X. and Garfinkel, T. and Lewis, E.C. and Subrahmanyam, P. and
	Waldspurger, C.A. and Boneh, D. and Dwoskin, J. and Ports, D.R.K.},
  title = {{Overshadow: a virtualization-based approach to retrofitting protection
	in commodity operating systems}},
  booktitle = {Proceedings of the 13th international conference on Architectural
	support for programming languages and operating systems},
  year = {2008},
  pages = {2--13},
  organization = {ACM},
  abstract = {Commodity operating systems entrusted with securing sensitive data
	are remarkably large and complex, and consequently, frequently prone
	to compromise. To address this limitation, we introduce a virtual-machine-based
	system called Overshadow that protects the privacy and integrity
	of application data, even in the event of a total OScompromise. Overshadow
	presents an application with a normal view of its resources, but
	the OS with an encrypted view. This allows the operating system to
	carry out the complex task of managing an application's resources,
	without allowing it to read or modify them. Thus, Overshadow offers
	a last line of defense for application data.


	Overshadow builds on multi-shadowing, a novel mechanism that presents
	different views of "physical" memory, depending on the context performing
	the access. This primitive offers an additional dimension of protection
	beyond the hierarchical protection domains implemented by traditional
	operating systems and processor architectures.


	We present the design and implementation of Overshadow and show how
	its new protection semantics can be integrated with existing systems.
	Our design has been fully implemented and used to protect a wide
	range of unmodified legacy applications running on an unmodified
	Linux operating system. We evaluate the performance of our implementation,
	demonstrating that this approach is practical.},
  owner = {Mathias Payer},
  review = {OS is untrusted, enable secure applications under that OS. App communicates
	with VMM/Hypervizor. A lot of os functionality must be reimplemented
	in the VMM. Uses VMWare


	OS view of application memory is encrypted.},
  timestamp = {2011.02.03}
}

@ARTICLE{fx3298chernoff,
  author = {Anton Chernoff and Mark Herdeg and Ray Hookway and Chris Reeve and
	Norman Rubin and Tony Tye and S. Bharadwaj Yadavalli and John Yates},
  title = {FX!32: A Profile-Directed Binary Translator},
  journal = {IEEE Micro},
  year = {1998},
  volume = {18},
  pages = {56--64},
  number = {2},
  doi = {http://dx.doi.org/10.1109/40.671403},
  issn = {0272-1732},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@INPROCEEDINGS{chess02sp,
  author = {Brian V. Chess},
  title = {Improving Computer Security using Extended Static Checking},
  booktitle = {S\&P'02: IEEE Symp. on Security and Privacy},
  year = {2002},
  abstract = {We describe a method for finding security flaws in source code by
	way of static analysis. The method is notable because it allows a
	user to specify a wide range of security properties while also leveraging
	a set of predefined common flaws. It works by using an automated
	theorem prover to analyze verification conditions generated from
	C source code and a set of specifications that define security properties.
	We demonstrate that the method can be used to identify real vulnerabilities
	in real programs.},
  owner = {Mathias Payer},
  review = {Statically finding errors and bugs in c programs using some formal
	specification and theorem proving.


	Use file race conditions in daemons as a motivating example},
  timestamp = {2011.05.09}
}

@INPROCEEDINGS{FIELDREORDERING-PLDI99,
  author = {Trishul M. Chilimbi and Bob Davidson and James R. Larus},
  title = {Cache-conscious structure definition},
  booktitle = {Proc.~of the ACM SIGPLAN'99 Conf. on Programming Language Design
	and Implementation (PLDI~1999)},
  year = {1999},
  pages = {13--24},
  doi = {http://doi.acm.org/10.1145/301618.301635},
  isbn = {1-58113-094-5},
  location = {Atlanta, Georgia, United States}
}

@INPROCEEDINGS{choi93efficient,
  author = {Jong-Deok Choi and Michael Burke and Paul Carini},
  title = {Efficient Flow-Sensitive Interprocedural Computation of Pointer-Induced
	Aliases and Side Effects},
  booktitle = {Conference Record of the Twentieth Annual {ACM} {SIGPLAN}-{SIGACT}
	Symposium on Principles of Programming Languages},
  year = {1993},
  pages = {232--245},
  url = {citeseer.nj.nec.com/choi93efficient.html}
}

@TECHREPORT{choi95incrementalssa,
  author = {Jong-Deok Choi and Vivek Sarkar and Edith Schonberg},
  title = {Incremental Computation of Static Single Assignment Form},
  institution = {IBM Application Development Technology Institute},
  year = {1995}
}

@INPROCEEDINGS{chow2008decoupling,
  author = {Chow, J. and Garfinkel, T. and Chen, P.M.},
  title = {{Decoupling dynamic program analysis from execution in virtual environments}},
  booktitle = {Proc. USENIX ATC},
  year = {2008},
  pages = {1--14},
  abstract = {Analyzing the behavior of running programs has a wide variety of compelling
	applications, from intrusion detection and prevention to bug discovery.
	Unfortunately, the high runtime overheads imposed by complex analysis
	techniques makes their deployment impractical in most settings. We
	present a virtual machine based architecture called Aftersight ameliorates
	this, providing a flexible and practical way to run heavyweight analyses
	on production workloads.


	Aftersight decouples analysis from normal execution by logging nondeterministic
	VM inputs and replaying them on a separate analysis platform. VM
	output can be gated on the results of an analysis for intrusion prevention
	or analysis can run at its own pace for intrusion detection and best
	effort prevention. Logs can also be stored for later analysis offline
	for bug finding or forensics, allowing analyses that would otherwise
	be unusable to be applied ubiquitously. In all cases, multiple analyses
	can be run in parallel, added on demand, and are guaranteed not to
	interfere with the running workload.


	We present our experience implementing Aftersight as part of the VMware
	virtual machine platform and using it to develop a realtime intrusion
	detection and prevention system, as well as an an offline system
	for bug detection, which we used to detect numerous novel and serious
	bugs in VMware ESX Server, Linux, and Windows applications.},
  owner = {Mathias Payer},
  review = {Aftersight uses VMWare store and replay to safe information about
	a security relevant events. Events can be replayed and analyzed in
	QEMU},
  timestamp = {2011.02.03}
}

@MISC{chris-supporting,
  author = {Jeremy Singer Chris},
  title = {Supporting Higher-Order Virtualization},
  abstract = {Virtualization is ubiquitous, with the global availability of

	the Java Virtual Machine and other similar virtual machine platforms.

	Higher-order virtualization involves building a stack of virtual machine

	layers. This provides obvious advantages such as: flexibility; separation

	of concerns; reuse of existing functionality; support for legacy platforms.

	However, the benefits of higher-order virtualization come at a price
	in

	terms of efficiency. This paper examines different techniques to increase

	the efficiency of higher-order virtualization on chip multiprocessor
	ar-

	chitectures. These techniques embrace hardware, software and virtual

	machine interaction. Some techniques (such as just-in-time compilation)

	are employed in existing virtual machine systems. Other techniques
	(such

	as hints-based speculative parallelism) have not been previously consid-

	ered. We examine how to use these performance-enhancing techniques
	in

	the context of stacked virtual machine layers.},
  owner = {Mathias Payer},
  review = {all parts of CFG (extended bblocks) are executed in speculatively

	=> online decision if resources are available


	print -> 1},
  timestamp = {2007.10.04},
  url = {citeseer.ist.psu.edu/745798.html}
}

@INPROCEEDINGS{woong99hlrc,
  author = {Jae Woong Chung and Byeong Hag Seong and Kyu Ho Park and Daeyeon
	Park},
  title = {Moving Home-Based Lazy Release Consistency for Shared Virtual Memory
	Systems},
  booktitle = {ICPP '99: Proceedings of the 1999 International Conference on Parallel
	Processing},
  year = {1999},
  pages = {282},
  abstract = {While Shared Virtual Memory is a cost-effective way to provide an
	illusion of shared memory to programmers, the performance of the
	system is limited by its inherent overheads. Several protocols such
	as Lazy Release Consistency (LRC) and Home-based LRC(HLRC) have been
	suggested to overcome the overheads.In this paper, we propose a new
	all-software protocol, Moving Home-based LRC(MHLRC). Its main contribution
	is to introduce a new concept, Moving Home. Using it, our protocol
	provides 4 efficient functionalities: a) providing migration mechanism,
	b) eliminating the duty of updating the home copy at the end of an
	interval, c) providing an adaptive home locating scheme, and d) simplifying
	the update procedure on a stale copy. To evaluate our protocol, we
	implemented a prototype of MHLRC. The experiment with 4 benchmarks
	showed that our protocol improved the performance of the system by
	on the average 10% over LRC, and by up to 96% over HLRC. From the
	detailed analysis, we found that the improvement mainly comes from
	the reduction of the coherence action overhead. Our protocol reduced
	the number of diff operations executed during computation up to 64%(FFT)
	~ 0.4%(SOR) against LRC and 56%(FFT) ~ 0.3%(SOR) against HLRC. It
	also reduces the requirement for memory and network bandwidth.},
  isbn = {0-7695-0350-0},
  keywords = {STM, TM, Consistency},
  owner = {Mathias Payer},
  review = {extension to home-based lrc

	-> home moves if conditions are met


	print -> 1},
  timestamp = {2008.08.10}
}

@INPROCEEDINGS{DYNAMICOPT-CIERNIAK00,
  author = {Michal Cierniak and Guei-Yuan Lueh and James M. Stichnoth},
  title = {Practicing JUDO: Java under dynamic optimizations},
  booktitle = {Proc.~of the ACM Conf.~ on Programming Language Design and Implementation
	(PLDI~2000)},
  year = {2000},
  pages = {13--26},
  doi = {http://doi.acm.org/10.1145/349299.349306},
  isbn = {1-58113-199-2},
  location = {Vancouver, British Columbia, Canada}
}

@INPROCEEDINGS{clabes:power5design,
  author = {Joachim Clabes and Joshua Friedrich and Mark Sweet and Jack DiLullo
	and Sam Chu and Donald Plass and James Dawson and Paul Muench and
	Larry Powell and Michael Floyd and Balaram Sinharoy and Mike Lee
	and Michael Goulet and James Wagoner and Nicole Schwartz and Steve
	Runyon and Gary Gorman and Phillip Restle and Ronald Kalla and Joseph
	McGill and Steve Dodson},
  title = {Design and implementation of the POWER5 microprocessor},
  booktitle = {DAC '04: Proceedings of the 41st annual conference on Design automation},
  year = {2004},
  pages = {670--672},
  doi = {http://doi.acm.org/10.1145/996566.996749},
  isbn = {1-58113-828-8},
  location = {San Diego, CA, USA}
}

@ARTICLE{clausenSideeffect,
  author = {Lars Raeder Clausen},
  title = {A Java Bytecode Optimizer Using Side-effect Analysis},
  journal = {Concurrency: Prac\-tice and Experience},
  year = {1997},
  volume = {9},
  pages = {1031--1045},
  number = {11},
  abstract = {This paper describes Cream, an optimizer for Java bytecode

	using side-effect analysis to improve the optimizations.

	Dead code elimination and loop invariant removal

	is implemented and tested, as well as several variations

	of the side-effect analysis. The optimizer is tested on

	real-world applications such as itself and JavaSoft's Java

	compiler. Results show that the optimizations benefit

	a lot from the side-effect analysis. The best side-effect

	analysis gives five to ten times as many optimizations

	as without an analysis, and, in one case, makes a sped

	increase of 25 % possible.


	1 Introduction


	Java, being a relatively young language, doesn't yet

	have as sophisticated optimizing compilers as other,

	more mature languages like C and Fortran. When designing

	the optimizers needed to improve Java's speed

	towards a more acceptable level, one must carefully consider

	the special traits of the language. In contrast with

	C programs, Java programs have many small method

	invocations, many structu...},
  url = {http://citeseer.ist.psu.edu/update/115752}
}

@INPROCEEDINGS{coady06VMDSAL,
  author = {Yvonne Coady and Celina Gibbs and Michael Haupt and Jan Vitek and
	Hiroshi Yamauchi},
  title = {Towards a Domain-Specific Aspect Language for Virtual Machines},
  booktitle = {DSAL'06: Proc. AOSD workshop on Domain-Specific Aspect Languages},
  year = {2006},
  abstract = { High-level language virtual machines, e. g., for the Java programming
	language, offer a unique and challenging domain for aspects. This
	position paper motivates the need for an aspect-oriented language
	designed precisely for this domain. We start by overviewing examples
	of some of the crosscutting concerns we have refactored as aspects
	in VMs, and then demonstrate how mainstream aspectoriented programming
	languages need to be augmented in order to elegantly implement these
	and similar concerns. We believe current join point and advice models
	are not expressive enough for this domain. Predominantly this is
	due to the fact that the concept of a point in the execution of the
	VM requires the ability to explicitly specify subtle issues regarding
	system state and services. Finally, the paper outlines, based on
	a design view on virtual machines, the shape of a possible domain-specific
	aspect language for the implementation of such systems. 1. },
  acmid = {1404932},
  keywords = {domain-specific aspect language, object layout, virtual machine},
  numpages = {4}
}

@ARTICLE{cohen93csec,
  author = {Cohen, Frederick B.},
  title = {Operating system protection through program evolution},
  journal = {Comput. Secur.},
  year = {1993},
  volume = {12},
  pages = {565--584},
  number = {6},
  doi = {10.1016/0167-4048(93)90054-9},
  issn = {0167-4048},
  keywords = {computational complexity, operating systems, program evolution, trusted
	systems},
  owner = {Mathias Payer},
  timestamp = {2012.04.16},
  url = {http://dx.doi.org/10.1016/0167-4048(93)90054-9}
}

@ARTICLE{exploiddb10610,
  author = {Aaron Conole},
  title = {{CoreHTTP} Arbitrary Command Execution Vulnerability},
  journal = {\url{http://www.exploit-db.com/exploits/10610/}},
  year = {2009},
  owner = {gannimo},
  timestamp = {2012.01.26}
}

@ARTICLE{constantinou:multicoreperformance,
  author = {Theofanis Constantinou and Yiannakis Sazeides and Pierre Michaud
	and Damien Fetis and Andre Seznec},
  title = {Performance implications of single thread migration on a chip multi-core},
  journal = {SIGARCH Comput. Archit. News},
  year = {2005},
  volume = {33},
  pages = {80--91},
  number = {4},
  doi = {http://doi.acm.org/10.1145/1105734.1105745},
  issn = {0163-5964}
}

@INPROCEEDINGS{formatguard01cowan,
  author = {Cowan, Crispin and Barringer, Matt and Beattie, Steve and Kroah-Hartman,
	Greg and Frantzen, Mike and Lokier, Jamie},
  title = {FormatGuard: automatic protection from printf format string vulnerabilities},
  booktitle = {SSYM'01: Proc. 10th USENIX Security Symp.},
  year = {2001},
  abstract = {In June 2000, a major new class of vulnerabilities called "format
	bugs" was discovered when an vulnerability in WU-FTP appeared that
	acted almost like a buffer overflow, but wasn't. Since then, dozens
	of format string vulnerabilities have appeared. This paper describes
	the format bug problem, and presents FormatGuard: our proposed solution.
	FormatGuard is a small patch to glibc that provides general protection
	against format bugs. We show that FormatGuard is effective in protecting
	several real programs with format vulnerabilities against live exploits,
	and we show that FormatGuard imposes minimal compatibility and performance
	costs.},
  location = {Washington, D.C.},
  owner = {Mathias Payer},
  review = {Static BT, check control flow transfers, use static BT to add guards
	for control flow transfers},
  timestamp = {2010.10.28}
}

@INPROCEEDINGS{pointguard03cowan,
  author = {Cowan, Crispin and Beattie, Steve and Johansen, John and Wagle, Perry},
  title = {{PointguardTM}: protecting pointers from buffer overflow vulnerabilities},
  booktitle = {SSYM'03: Proc. 12th USENIX Security Symp.},
  year = {2003},
  abstract = {Despite numerous security technologies crafted to resist buffer overflow
	vulnerabilities, buffer overflows continue to be the dominant form
	of software security vulnerability. This is because most buffer overflow
	defenses provide only partial coverage, and the attacks have adapted
	to exploit problems that are not well-defended, such as heap overflows.
	This paper presents PointGuard, a compiler technique to defend against
	most kinds of buffer overflows by encrypting pointers when stored
	in memory, and decrypting them only when loaded into CPU registers.
	We describe the PointGuard implementation, show that PointGuard's
	overhead is low when protecting real security-sensitive applications
	such as OpenSSL, and show that PointGuard is effective in defending
	against buffer overflow vulnerabilities that are not blocked by previous
	defenses.},
  location = {Washington, DC},
  owner = {Mathias Payer},
  timestamp = {2010.10.28}
}

@INPROCEEDINGS{subdomain00cowan,
  author = {Cowan, Crispin and Beattie, Steve and Kroah-Hartman, Greg and Pu,
	Calton and Wagle, Perry and Gligor, Virgil},
  title = {{SubDomain}: Parsimonious Server Security},
  booktitle = {Proc. 14th USENIX Conf. System Administration},
  year = {2000},
  pages = {355--368},
  abstract = {Internet security incidents have shown that while network cryptography
	tools like SSL are valuable to Internet service, the hard problem
	is to protect the server itself from attack. The host security problem
	is important because attackers know to attack the weakest link, which
	is vulnerable servers. The problem is hard because securing a server
	requires securing every piece of software on the server that the
	attacker can access, which can be a very large set of software for
	a sophisticated server. Sophisticated security architectures that
	protect against this class of problem exist, but because they are
	either complex, expensive, or incompatible with existing application
	software, most Internet server operators have not chosen to use them.This
	paper presents SubDomain: an OS extension designed to provide sufficient
	security to prevent vulnerability rot in Internet server platforms,
	and yet simple enough to minimize the performance, administrative,
	and implementation costs. SubDomain does this by providing a least
	privilege mechanism for programs rather than for users. By orienting
	itself to programs rather than users, SubDomain simplifies the security
	administrator's task of securing the server.This paper describes
	the problem space of securing Internet servers, and presents the
	SubDomain solution to this problem. We describe the design, implementation,
	and operation of SubDomain, and provide working examples and performance
	metrics for services such as HTTP, SMTP, POP, and DNS protected with
	SubDomain.},
  location = {New Orleans, Louisiana},
  owner = {Mathias Payer},
  timestamp = {2010.10.28}
}

@INPROCEEDINGS{cowan01raceguard,
  author = {Crispin Cowan and Steve Beattie and Chris Wright and Greg Kroah-hartman},
  title = {{RaceGuard}: Kernel Protection from Temporary File Race Vulnerabilities},
  booktitle = {SSYM'01: Proc. 10th USENIX Security Symp.},
  year = {2001},
  pages = {12},
  abstract = {Temporary file race vulnerabilities occur when privileged programs
	attempt to create temporary files in an unsafe manner. "Unsafe" means
	"non-atomic with respect to an attacker's activities." There is no
	portable standard for safely (atomically) creating temporary files,
	and many operating systems have no safe temporary file creation at
	all. As a result, many programs continue to use unsafe means to create
	temporary files, resulting in widespread vulnerabilities. This paper
	presents RaceGuard: a kernel enhancement that detects attempts to
	exploit temporary file race vulnerabilities, and does so with sufficient
	speed and precision that the attack can be halted before it takes
	effect. RaceGuard has been implemented, tested, and measured. We
	show that RaceGuard is effective at stopping temporary file race
	attacks, preserves compatibility (no legitimate software is broken),
	and preserves performance (overhead is minimal).},
  owner = {Mathias Payer},
  review = {RaceGuard adds an in-kernel cache of file accesses to detect file
	races and TOCTTOU attacks:

	* Non-existent file: note name and keep in cache

	* If file creation says file exists and cache hit then race attack,
	flag and abort

	* if file creation succeeds without conflicts and matches the name
	in the cache then remove the name from the cache


	Defends against probe; create; probe


	To defend against dangling symlinks RaceGuard resolves the name twice,
	once with symlink allowed once with symlinks disallwoed. If both
	names do not resolve to the same name and the file is in the cache
	then it is a race attack.


	RaceGuard does not defent against file swap attacks.},
  timestamp = {2011.05.10}
}

@INPROCEEDINGS{stackguard98cowan,
  author = {Cowan, Crispin and Pu, Calton and Maier, Dave and Hintony, Heather
	and Walpole, Jonathan and Bakke, Peat and Beattie, Steve and Grier,
	Aaron and Wagle, Perry and Zhang, Qian},
  title = {{StackGuard}: automatic adaptive detection and prevention of buffer-overflow
	attacks},
  booktitle = {SSYM'98: Proc. 7th USENIX Security Symp.},
  year = {1998},
  abstract = {This paper presents a systematic solution to the persistent problem
	of buffer overflow attacks. Buffer overflow attacks gained notoriety
	in 1988 as part of the Morris Worm incident on the Internet. While
	it is fairly simple to fix individual buffer overflow vulnerabilities,
	buffer overflow attacks continue to this day. Hundreds of attacks
	have been discovered, and while most of the obvious vulnerabilities
	have now been patched, more sophisticated buffer overflow attacks
	continue to emerge.


	We describe StackGuard: a simple compiler technique that virtually
	eliminates buffer overflow vulnerabilities with only modest performance
	penalties. Privileged programs that are recompiled with the StackGuard
	compiler extension no longer yield control to the attacker, but rather
	enter a fail-safe state. These programs require no source code changes
	at all, and are binary-compatible with existing operating systems
	and libraries. We describe the compiler technique (a simple patch
	to gcc), as well as a set of variations on the technique that trade-off
	between penetration resistance and performance. We present experimental
	results of both the penetration resistance and the performance impact
	of this technique.},
  location = {San Antonio, Texas},
  owner = {Mathias Payer},
  timestamp = {2010.10.28}
}

@INPROCEEDINGS{cox06usenix,
  author = {Cox, Benjamin and Evans, David and Filipi, Adrian and Rowanhill,
	Jonathan and Hu, Wei and Davidson, Jack and Knight, John and Nguyen-Tuong,
	Anh and Hiser, Jason},
  title = {N-variant systems: a secretless framework for security through diversity},
  booktitle = {Proceedings of the 15th conference on USENIX Security Symposium -
	Volume 15},
  year = {2006},
  series = {USENIX-SS'06},
  articleno = {9},
  owner = {Mathias Payer},
  timestamp = {2012.04.16},
  url = {http://dl.acm.org/citation.cfm?id=1267336.1267344}
}

@ARTICLE{cytron91efficiently,
  author = {Ron Cytron and Jeanne Ferrante and Barry K. Rosen and Mark N. Wegman
	and F. Kenneth Zadeck},
  title = {Efficiently Computing Static Single Assignment Form and the Control
	Dependence Graph},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {1991},
  volume = {13},
  pages = {451--490},
  number = {4},
  month = {October},
  url = {citeseer.nj.nec.com/cytron91efficiently.html}
}

@ARTICLE{10.1109/99.660313,
  author = {Leonardo Dagum and Ramesh Menon},
  title = {OpenMP: An Industry-Standard API for Shared-Memory Programming},
  journal = {IEEE Computational Science and Engineering},
  year = {1998},
  volume = {05},
  pages = {46-55},
  number = {1},
  abstract = {At its most elemental level, OpenMP is a set of compiler directives
	and callable runtime library routines that extend Fortran (and separately,
	C and C++ to express shared memory parallelism. It leaves the base
	language unspecified, and vendors can implement OpenMP in any Fortran
	compiler. Naturally, to support pointers and allocatables, Fortran
	90 and Fortran 95 require the OpenMP implementation to include additional
	semantics over Fortran 77. OpenMP leverages many of the X3H5 concepts
	while extending them to support coarse grain parallelism. The standard
	also includes a callable runtime library with accompanying environment
	variables},
  doi = {http://doi.ieeecomputersociety.org/10.1109/99.660313},
  issn = {1070-9924},
  owner = {Mathias Payer},
  review = {print -> 1},
  timestamp = {2007.10.04}
}

@misc{CVE-2011-1658,
  author = {Vincent Danen},
  title = {{CVE-2011-1658}: ld.so {ORIGIN} expansion combined with {RPATH}},
  year = {2010},
  howpublished = {\url{https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2011-1658}},
  owner = {gannimo},
  timestamp = {2011.06.12}
}

@INPROCEEDINGS{sign08kiwi,
  author = {David Greaves, Satnam Singh},
  title = {Kiwi: Synthesis of FPGA Circuits from Parallel Programs},
  year = {2008},
  abstract = {We describe the Kiwi parallel programming library and its associated
	synthesis system which is used to transform C# parallel programs
	into circuits for realization on FPGAs. The Kiwi system is targeted
	at making reconfigurable computing technology accessible to software
	engineers that are willing to express their computations as parallel
	programs. Although there has been much work on compiling sequential
	C-like programs to hardware by automatically âdiscoveringâ parallelism,
	we work by exploiting the parallel architecture communicated by the
	designer through the choice of parallel and concurrent programming
	language constructs. Specifically, we describe a system that takes
	.NET assembly language with suitable custom attributes as input and
	produces Verilog output which is mapped to FPGAs. We can then choose
	to apply analysis and verification techniques to either the highlevel
	representation in C# or other .NET languages or to the generated
	RTL netlists. A distinctive aspect of our approach is the exploitation
	of existing language constructs for concurrent programming and synchronization
	which contrasts with other schemes which introduce specialized concurrency
	control constructs to extend a sequential language.},
  owner = {Mathias Payer},
  review = {All funtionality and limitations contained in the library.


	Only channles in the lib can be used for communication => No aliasing
	side effects!


	Use C# instead of VHDL. But C# is highly limited!},
  timestamp = {2008.11.13}
}

@INPROCEEDINGS{dean04ssym,
  author = {Dean, Drew and Hu, Alan J.},
  title = {Fixing races for fun and profit: how to use access(2)},
  booktitle = {SSYM'04: Proc. 13th USENIX Security Symp.},
  year = {2004},
  series = {SSYM'04},
  pages = {14--14},
  abstract = {It is well known that it is insecure to use the access(2) system call
	in a setuid program to test for the ability of the program's executor
	to access a file before opening said file. Although the access(2)
	call appears to have been designed exactly for this use, such use
	is vulnerable to a race condition. This race condition is a classic
	example of a time-of-check-to-time-of-use (TOCTTOU) problem. We prove
	the "folk theorem" that no portable, deterministic solution exists
	without changes to the system call interface, we present a probabilistic
	solution, and we examine the effect of increasing CPU speeds on the
	exploitability of the attack.},
  acmid = {1251389},
  numpages = {1},
  owner = {Mathias Payer},
  review = {Fix for file-based race conditions (TOCTTOU) (later broken by borisov
	et al)},
  timestamp = {2011.09.09},
  url = {http://dl.acm.org/citation.cfm?id=1251375.1251389}
}

@INPROCEEDINGS{PROFILEME,
  author = {Jeffrey Dean and James E. Hicks and Carl A. Waldspurger and William
	E. Weihl and George Chrysos},
  title = {ProfileMe: hardware support for instruction-level profiling on out-of-order
	processors},
  booktitle = {Proc. of the 30th annual ACM/IEEE international symposium on Microarchitecture},
  year = {1997},
  pages = {292--302},
  isbn = {0-8186-7977-8},
  location = {Research Triangle Park, North Carolina, United States}
}

@MISC{pompImplementation,
  author = {Luiz DeRose and Bernd Mohr and Seetharami Seelam},
  title = {An Implementation of the POMP Performance Monitoring Interface for
	OpenMP Based on Dynamic Probes},
  abstract = {OpenMP has emerged as the standard for shared memory parallel programming.

	Unfortunately, it does not provide a standardized performance monitoring
	interface, such that

	users and tools builders could write portable libraries for performance
	measurement of OpenMP

	programs. In this paper we present an implementation of a performance
	monitoring interface for

	OpenMP, based on the POMP proposal, which is built on top of DPCL,
	an infrastructure for binary

	and dynamic instrumentation. We also present overhead measurements
	of our implementation

	and show examples of utilization with two versions of POMP compliant
	libraries.},
  keywords = {openmp, parallelization, dynamic probes},
  owner = {Mathias Payer},
  review = {- dynamic code changes to monitor OpenMP programs (binary injection)

	- PMI information can be saved & analyzed externally


	print -> 1},
  timestamp = {2007.10.04},
  url = {http://www.rz.rwth-aachen.de/ewomp03/omptalks/Tuesday/Session6/T16p.pdf}
}

@INPROCEEDINGS{deutsch84smalltalk80,
  author = {L. Peter Deutsch and Allan M. Schiffman},
  title = {Efficient implementation of the smalltalk-80 system},
  booktitle = {POPL '84},
  year = {1984},
  pages = {297--302},
  doi = {http://doi.acm.org/10.1145/800017.800542},
  isbn = {0-89791-125-3},
  location = {Salt Lake City, Utah, United States},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@MISC{vmware02patent,
  author = {Scott W. Devine and Edouard Bugnion and Mendel Rosenblum},
  title = {Virtualization system including a virtual machine monitor for a computer
	with a segmented architecture},
  year = {2002},
  howpublished = {US Patent 6397242},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@ARTICLE{dewitt:threadlevelspec,
  author = {Anthony DeWitt and Thomas Gross},
  title = {The potential of thread-level speculation based on value profiling},
  journal = {SIGARCH Computer Architecture News},
  year = {1999},
  volume = {27},
  pages = {22},
  number = {1},
  doi = {http://doi.acm.org/10.1145/309758.309765},
  issn = {0163-5964},
  keywords = {speculation, specmt, multithreading, value profiling},
  owner = {Mathias Payer},
  review = {instructions from basic blocks are separated into different threads

	-> dependence analysis inside these blocks

	-> blocks form trace, split these traces to threads based on indivi
	instructions and dependences


	print -> 1},
  timestamp = {2007.10.04},
  url = {citeseer.ist.psu.edu/292100.html}
}

@INPROCEEDINGS{shavit08tl2,
  author = {Dave Dice and O. Shalev and Nir Shavit},
  title = {Transactional Locking {II}},
  booktitle = {DISC'06},
  year = {2006},
  pages = {194--208},
  owner = {Mathias Payer},
  site = {Stockholm, Sweden},
  timestamp = {2008.10.16}
}

@INPROCEEDINGS{dice07tradeoffsstm,
  author = {Dave Dice and Nir Shavit},
  title = {Understanding Tradeoffs in Software Transactional Memory},
  booktitle = {CGO '07},
  year = {2007},
  pages = {21--33},
  abstract = {There has been a flurry of recent work on the design of high performance
	software and hybrid hardware/software transactional memories (STMs
	and HyTMs). This paper reexamines the design decisions behind several
	of these stateof- the-art algorithms, adopting some ideas, rejecting
	others, all in an attempt to make STMs faster. We created the transactional
	locking (TL) framework of STM algorithms and used it to conduct a
	range of comparisons of the performance of non-blocking, lock-based,
	and Hybrid STM algorithms versus fine-grained hand-crafted ones.
	We were able to make several illuminating observations regarding
	lock acquisition order, the interaction of STMs with memory management
	schemes, and the role of overheads and abort rates in STM performance.},
  doi = {http://dx.doi.org/10.1109/CGO.2007.38},
  isbn = {0-7695-2764-7},
  keywords = {STM, TM, TL2},
  owner = {Mathias Payer},
  review = {different optimization possibilities for stms


	TL framework

	- use lock based STMs

	- use commit time locking

	- sophisticated contention management

	-> comparison of different stms (DSTM, OSTM, Fraser, Ennals)


	print -> 1},
  timestamp = {2008.08.10}
}

@INPROCEEDINGS{DS06,
  author = {D. Dice and N. Shavit},
  title = {What Really Makes Transactions Faster?},
  booktitle = {TRANSACT'06},
  year = {2006},
  owner = {Mathias Payer},
  site = {Ottawa, Canada},
  timestamp = {2009.05.26}
}

@INCOLLECTION{discolo08stmhaskell,
  author = {Discolo, Anthony and Harris, Tim and Marlow, Simon and Jones, Simon
	and Singh, Satnam},
  title = {Lock Free Data Structures Using STM in Haskell},
  year = {2006},
  pages = {65--80},
  abstract = {This paper explores the feasibility of re-expressing concurrent algorithms
	with explicit locks in terms of lock free code written using Haskellâs
	implementation of software transactional memory. Experimental results
	are presented which show that for multi-processor systems the simpler
	lock free implementations offer superior performance when compared
	to their corresponding lock based implementations.},
  citeulike-article-id = {2293658},
  doi = {10.1007/11737414\_6},
  journal = {Functional and Logic Programming},
  keywords = {haskell, stm, TM},
  owner = {Mathias Payer},
  posted-at = {2008-07-08 19:01:12},
  priority = {2},
  review = {stm language extension for haskell


	print -> 1},
  timestamp = {2008.08.10},
  url = {http://dx.doi.org/10.1007/11737414\_6}
}

@INPROCEEDINGS{158611,
  author = {Damien Doligez and Xavier Leroy},
  title = {A concurrent, generational garbage collector for a multithreaded
	implementation of ML},
  booktitle = {POPL '93: Proceedings of the 20th ACM SIGPLAN-SIGACT symposium on
	Principles of programming languages},
  year = {1993},
  pages = {113--123},
  abstract = {This paper presents the design and implementation of a âquasi real-timeâ
	garbage collector for Concurrent Caml Light, an implementation of
	ML with threads. This two-generation system combines a fast, asynchronous
	copying collector on the young generation with a non-disruptive concurrent
	marking collector on the old generation. This design crucially relies
	on the ML compile-time distinction between mutable and immutable
	objects.},
  doi = {http://doi.acm.org/10.1145/158511.158611},
  isbn = {0-89791-560-7},
  keywords = {generational, copy, garbage collector},
  location = {Charleston, South Carolina, United States},
  owner = {Mathias Payer},
  review = {GenCopyMS

	Copy -> Stop the world (minor collection)

	Mark & Sweep -> Parallel

	Garbage can be generated faster than collected

	1 main controller -> scaling problems


	print -> 1},
  timestamp = {2007.10.04}
}

@INPROCEEDINGS{swisstm,
  author = {Dragojevi\'{c}, Aleksandar and Guerraoui, Rachid and Kapalka, Michal},
  title = {Stretching transactional memory},
  booktitle = {PLDI'09},
  year = {2009},
  pages = {155--165},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1542476.1542494},
  isbn = {978-1-60558-392-1},
  keywords = {STM, TM, swissTM},
  location = {Dublin, Ireland},
  owner = {Mathias Payer},
  timestamp = {2010.01.13}
}

@misc{dreppersharedlibs,
  author = {Ulrich Drepper},
  title = {How To Write Shared Libraries},
  howpublished = {\url{http://www.akkadia.org/drepper/dsohowto.pdf}},
  year = {2010},
  month = {Dec.},
  abstract = {Today, shared libraries are ubiquitous. Developers use them for multiple
	reasons and create

	them just as they would create application code. This is a problem,
	though, since on many

	platforms some additional techniques must be applied even to generate
	decent code. Even more

	knowledge is needed to generate optimized code. This paper introduces
	the required rules and

	techniques. In addition, it introduces the concept of ABI (Application
	Binary Interface) stability

	and shows how to manage it.},
  owner = {Mathias Payer},
  review = {Extensive information about the ELF format and implementation},
  timestamp = {2011.02.01},
  url = {http://www.akkadia.org/drepper/dsohowto.pdf}
}

@ARTICLE{duesterwald05dynamorio,
  author = {Duesterwald, E.},
  title = {Design and Engineering of a Dynamic Binary Optimizer},
  journal = {Proc. of the IEEE'05},
  abstract = {In today's software, which increasingly utilizes dynamic class loading,
	shared libraries, and interconnected components, the power and reach
	of static compiler optimization is diminishing. An exciting new paradigm
	of transparent dynamic binary optimization is emerging, aimed at
	improving the performance of a program while it executes. Recently,
	several dynamic binary optimization systems have appeared in the
	literature. They all share a fundamental property: the ability to
	observe and modify instructions of the executing program immediately
	before they run. Importantly, recent advances allow this capability
	to be offered without having to pay the price of performance degradation.
	This paper describes the intricacies of a dynamic binary optimizer
	and how to build the core functionalities of observing and modifying
	executing instructions. We illustrate the major design decisions
	and tradeoffs and point to the important engineering challenges.},
  doi = {10.1109/JPROC.2004.840302},
  issn = {0018-9219},
  keywords = {binary codes, instruction sets, optimising compilers, software engineeringdynamic
	binary optimization, dynamic class loading, interconnected components,
	shared libraries, static compiler optimization},
  owner = {Mathias Payer},
  review = {DynamoRIO paper

	* code cache

	* fragment linking -> JMP & ind. branches

	* fragment selection -> PC sampling

	* fragment optimization


	includes exception (signal) handling


	++

	Folder BT},
  timestamp = {2009.05.31}
}

@INPROCEEDINGS{dullien05symp,
  author = {Thomas Dullien and Rolf Rolles},
  title = {Graph-based comparison of executable objects},
  booktitle = {SYMP'05},
  abstract = {A method to construct an optimal isomorphism between the sets of instructions,
	sets of basic blocks and sets of functions in two differing but similar
	executables is presented. This isomorphism can be used for porting
	recovered information between different disassemblies, recover changes
	made by security updates and detect code theft.


	The most interesting applications in the realm of security are in
	malware analysis where the analysis of a family of trojans or viruses
	can be reduced to analyzing the differences between the variants,
	and in recovering the details of ï¬xed vulnerabilities when the vendor
	of the security patch refuses to disclose details.


	A framework implementing the described methods is presented, along
	with empirical data about itâs performance when analyzing multiple
	variants of the same malware and recovering vulnerability details
	from security updates.},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@INPROCEEDINGS{224076,
  author = {D. R. Engler and M. F. Kaashoek and J. O'Toole, Jr.},
  title = {Exokernel: an operating system architecture for application-level
	resource management},
  booktitle = {SOSP '95: Proceedings of the fifteenth ACM symposium on Operating
	systems principles},
  year = {1995},
  pages = {251--266},
  doi = {http://doi.acm.org/10.1145/224056.224076},
  isbn = {0-89791-715-4},
  location = {Copper Mountain, Colorado, United States},
  owner = {Mathias Payer},
  review = {all resources are exported to userspace

	-> like minix


	many processes that use and offer physical resources

	-> hw is managed on app-level


	print -> 1},
  timestamp = {2007.10.04}
}

@TECHREPORT{ennals:efficient-stm:tr:2005,
  author = {Ennals, Robert},
  title = {Efficient Software Transactional Memory},
  institution = {Intel Research Cambridge Tech Report},
  year = {2005},
  number = {IRC-TR-05-051},
  month = {Jan},
  file = {051_Rob_Ennals.pdf:http\://www.cs.wisc.edu/trans-memory/misc-papers/051_Rob_Ennals.pdf:PDF},
  owner = {Mathias Payer},
  timestamp = {2009.05.25}
}

@ARTICLE{erlingsson2007low,
  author = {Erlingsson, {\'U}.},
  title = {{Low-level software security: Attacks and defenses}},
  journal = {FOSAD'07: Foundations of security analysis and design},
  year = {2007},
  pages = {92--134},
  abstract = {This tutorial paper considers the issues of low-level software security
	from a language-based perspective, with the help of concrete examples.
	Four examples of low-level software attacks are covered in full detail;
	these examples are representative of the major types of attacks on
	C and C++ software that is compiled into machine code. Six examples
	of practical defenses against those attacks are also covered in detail;
	these defenses are selected because of their effectiveness, wide
	applicability, and low enforcement overhead.},
  owner = {Mathias Payer},
  publisher = {Springer},
  review = {Long article about different attacks and defenses},
  timestamp = {2011.02.03},
  url = {http://research.microsoft.com/pubs/64363/tr-2007-153.pdf}
}

@INPROCEEDINGS{osdi06erlingsson,
  author = {{\'U}lfar Erlingsson and Mart\'{\i}n Abadi and Michael Vrable and
	Mihai Budiu and George C. Necula},
  title = {{XFI}: Software Guards for System Address Spaces},
  booktitle = {OSDI'06},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://www.usenix.org/events/osdi06/tech/erlingsson.html},
  owner = {Mathias Payer}
}

@MISC{cesa2009001,
  author = {Chris Evans},
  title = {Linux syscall interception technologies partial bypass},
  year = {2009},
  howpublished = {http://scary.beasts.org/security/CESA-2009-001.html},
  owner = {Mathias Payer},
  timestamp = {2011.02.07},
  url = {http://scary.beasts.org/security/CESA-2009-001.html}
}

@MISC{seccompbug,
  author = {Chris Evans},
  title = {Linux kernel "seccomp" facility minor vulnerability},
  year = {2009},
  howpublished = {CESA-2009-004},
  owner = {Mathias Payer},
  review = {Mixing 32-bit and 64-bit system calls is dangerous, especially when
	a montior expecs a 32bit system call but a 64bit syscall was issued},
  timestamp = {2010.11.26},
  url = {http://scary.beasts.org/security/CESA-2009-004.html}
}

@INPROCEEDINGS{Factor2004,
  author = {Factor, M. and Schuster, A. and Shagin, K.},
  title = {A distributed runtime for Java: yesterday and today},
  booktitle = {Parallel and Distributed Processing Symposium, 2004. Proceedings.
	18th International},
  year = {2004},
  pages = {159},
  month = {26-30 April},
  abstract = {Summary form only given. Since the introduction of the Java language
	less then a decade ago, there have been several attempts to create
	a runtime system for distributed execution of multithreaded Java
	applications. The goal of these attempts was to gain increased computational
	power while preserving Java's convenient parallel programming paradigm.
	This paper gives a detailed overview of the existing distributed
	runtime systems for Java and presents a new approach, implemented
	in a system called JavaSplit. Unlike previous works, which either
	forfeit Java's portability or introduce unconventional programming
	constructs, Java-Split is able to execute standard multithreaded
	Java while preserving portability. JavaSplit works by rewriting the
	bytecodes of a given parallel application, transforming it into a
	distributed application that incorporates all the runtime logic.
	Each runtime node carries out its part of the resulting distributed
	computation using nothing but its local standard (unmodified) Java
	virtual machine (JVM).},
  doi = {10.1109/IPDPS.2004.1303149},
  keywords = {distributed jvm, javasplit},
  owner = {Mathias Payer},
  review = {rewrites bytecode (static & dynamic)

	distributed shared memory

	transparent multithreading over multiple nodes


	problems: i/o speed, heap access (shared)


	print -> 1},
  timestamp = {2007.10.04}
}

@INPROCEEDINGS{faith97khepera,
  author = {Rickard E. Faith and Lars S. Nyland and Jan Prins},
  title = {KHEPERA: A System for Rapid Implementation of Domain Specific Languages},
  booktitle = {DSL},
  year = {1997},
  pages = {{243--255}},
  abstract = { The KHEPERA system is a toolkit for the rapid implementation and
	long-term maintenance of domain specific languages (DSLs). Our viewpoint
	is that DSLs are most easily implemented via source-to-source translation
	from the DSL into another language and that this translation should
	be based on simple parsing, sophisticated tree-based analysis and
	manipulation, and source generation using pretty-printing techniques.
	KHEPERA emphasizes the use of familiar, pre-existing tools and provides
	support for transformation replay and debugging for the DSL processor
	and end-user programs. In this paper, we present an overview of our
	approach, including implementation details and a short example. },
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://www.usenix.org/publications/library/proceedings/dsl97/faith.html}
}

@INPROCEEDINGS{felber2007tanger,
  author = {Pascal Felber and Christof Fetzer and Ulrich M\"uller and Torvald
	Riegel and Martin S\"u{\ss}kraut and Heiko Sturzrehm},
  title = {Transactifying Applications using an Open Compiler Framework},
  booktitle = {TRANSACT'07},
  year = {2007},
  month = {August},
  abstract = {Transactional memory dramatically reduces the complexity of writing
	concurrent

	code. Yet, seamless integration of transactional constructs in application
	code

	typically comes with a significant performance penalty. Recent studies
	have

	shown that compiler support allows producing highly efficient STM-based

	applications without putting the hassle on the programmer. So far,
	STM

	integration has been partially implemented in custom, proprietary
	compiler

	infrastructures. In this paper, we propose and evaluate the use of
	the LLVM

	open compiler framework to generate efficient concurrent applications
	using

	word-based STM libraries. Since LLVM uses the GCC compiler suite as
	front-end,

	it can process code written in C or C++ (with partial support for
	other

	languages). We also present a tool that allows ``transactifying''
	assembly code

	and can complement LLVM for legacy code and libraries. Experiments
	using a

	lightweight C word-based STM library show that LLVM integration performs
	as

	well as hand-optimized calls to the STM library and better than assembly
	code

	instrumentation of the application code.},
  keywords = {tinySTM, multithreaded stm, fast, c, native, TM},
  owner = {Mathias Payer},
  review = {Tanger: GCC Phase for transactions (C/C++ extension) - high level
	transformation

	Tarifa: Static instrumentation (x86) -> Many push/pops to Stack (slow)

	tinySTM: C Implementention of a fast STM


	print -> 1},
  timestamp = {2007.10.05},
  url = {http://www.cs.rochester.edu/meetings/TRANSACT07/papers/felber.pdf}
}

@INPROCEEDINGS{dynamicSTMperformance08,
  author = {Felber, Pascal and Fetzer, Christof and Riegel, Torvald},
  title = {Dynamic performance tuning of word-based software transactional memory},
  booktitle = {PPoPP '08},
  year = {2008},
  pages = {237--246},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1345206.1345241},
  isbn = {978-1-59593-795-7},
  keywords = {STM, TM},
  location = {Salt Lake City, UT, USA},
  owner = {Mathias Payer},
  review = {Adaptive: global lock array (size) & #shifts for global lock (hash
	function)},
  timestamp = {2009.05.26}
}

@ARTICLE{ferrie06symantec,
  author = {Peter Ferrie},
  title = {Attacks on Virtual Machine Emulators},
  journal = {\url{http://www.symantec.com/avcenter/reference/Virtual_Machine_Threats.pdf}},
  year = {2006},
  owner = {Mathias Payer},
  timestamp = {2012.04.26}
}

@INPROCEEDINGS{switchblade08,
  author = {Fetzer, Christof and Suesskraut, Martin},
  title = {Switchblade: enforcing dynamic personalized system call models},
  booktitle = {{EuroSys}'08: Proc. 3rd Europ. Conf. Computer Systems},
  year = {2008},
  pages = {273--286},
  abstract = {System call interposition is a common approach to restrict the power
	of applications and to detect code injections. It enforces a model
	that describes what system calls and/or what sequences thereof are
	permitted. However, there exist various issues like concurrency vulnerabilities
	and incomplete models that restrict the power of system call interposition
	approaches. We present a new system, SwitchBlade, that uses randomized
	and personalized fine-grained system call models to increase the
	probability of detecting code injections. However, using a fine-grain
	system call model, we cannot exclude the possibility that the model
	is violated during normal program executions. To cope with false
	positives, SwitchBlade uses on-demand taint analysis to update a
	system call model during runtime.},
  doi = {http://doi.acm.org/10.1145/1352592.1352621},
  isbn = {978-1-60558-013-5},
  location = {Glasgow, Scotland UK},
  owner = {Mathias Payer},
  timestamp = {2010.02.02}
}

@INPROCEEDINGS{flake04dimva,
  author = {Halvar Flake},
  title = {Structural Comparison of Executable Objects},
  booktitle = {DIMVA'04},
  abstract = {A method to heuristically construct an isomorphism between the sets
	of functions in two similar but differing versions of the same executable
	file is presented. Such an isomorphism has multiple practical applications,
	specifically the ability to detect programmatic changes between the
	two executable versions. Moreover, information (function names) which
	is available for one of the two versions can also be made available
	for the other . A framework implementing the described methods is
	presented, along with empirical data about its performance when used
	to analyze patches to recent security vulnerabilities. As a more
	practical example, a security update which fixes a critical vulnerability
	in an H.323 parsing component is analyzed, the relevant vulnerability
	extracted and the implications of the vulnerability and the fix discussed.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://subs.emis.de/LNI/Proceedings/Proceedings46/article2970.html},
  owner = {Mathias Payer},
  review = {http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/d/Dullien:Thomas.html},
  timestamp = {2012.01.24}
}

@INPROCEEDINGS{08fordvx32,
  author = {Ford,, Bryan and Cox,, Russ},
  title = {Vx32: lightweight user-level sandboxing on the x86},
  booktitle = {USENIX ATC'08},
  abstract = {Code sandboxing is useful for many purposes, but most sandboxing techniques
	require kernel modifications, do not completely isolate guest code,
	or incur substantial performance costs. Vx32 is a multipurpose user-level
	sandbox that enables any application to load and safely execute one
	or more guest plug-ins, confining each guest to a system call API
	controlled by the host application and to a restricted memory region
	within the host's address space. Vx32 runs guest code efficiently
	on several widespread operating systems without kernel extensions
	or special privileges; it protects the host program from both reads
	and writes by its guests; and it allows the host to restrict the
	instruction set available to guests. The key to vx32's combination
	of portability, flexibility, and efficiency is its use of x86 segmentation
	hardware to sandbox the guest's data accesses, along with a lightweight
	instruction translator to sandbox guest instructions.


	We evaluate vx32 using microbenchmarks and whole system benchmarks,
	and we examine four applications based on vx32: an archival storage
	system, an extensible public-key infrastructure, an experimental
	user-level operating system running atop another host OS, and a Linux
	system call jail. The first three applications export custom APIs
	independent of the host OS to their guests, making their plug-ins
	binary-portable across host systems. Compute-intensive workloads
	for the first two applications exhibit between a 30\% slowdown and
	a 30\% speedup on vx32 relative to native execution; speedups result
	from vx32's instruction translator improving the cache locality of
	guest code. The experimental user-level operating system allows the
	use of the guest OS's applications alongside the host's native applications
	and runs faster than whole-system virtual machine monitors such as
	VMware and QEMU. The Linux system call jail incurs up to 80\% overhead
	but requires no kernel modifications and is delegation-based, avoiding
	concurrency vulnerabilities present in other interposition mechanisms.},
  location = {Boston, Massachusetts},
  owner = {Mathias Payer},
  review = {user space virtualization

	- expensive call/ret -> no opt

	- no guards for specific syscalls


	int, syscall, sysenter and illegal instructions are converted into
	traps and passed to a user supplied library},
  timestamp = {2009.05.04}
}

@INPROCEEDINGS{forrest97hotos,
  author = {Stephanie Forrest and Anil Somayaji and David H. Ackley},
  title = {Building Diverse Computer Systems},
  booktitle = {Workshop on Hot Topics in Operating Systems},
  year = {1997},
  pages = {67-72},
  owner = {Mathias Payer},
  timestamp = {2012.04.16}
}

@INPROCEEDINGS{frantzen01security,
  author = {Michael Frantzen and Michael Shuey},
  title = {{StackGhost}: Hardware Facilitated Stack Protection},
  booktitle = {SSYM'01: Proc 10th USENIX Security Symp.},
  year = {2001},
  ee = {http://www.usenix.org/publications/library/proceedings/sec01/frantzen.html}
}

@INPROCEEDINGS{franz10npsw,
  author = {Franz, Michael},
  title = {E unibus pluram: massive-scale software diversity as a defense mechanism},
  booktitle = {Proc. 2010 workshop on New security paradigms},
  year = {2010},
  series = {NSPW '10},
  pages = {7--16},
  doi = {10.1145/1900546.1900550},
  isbn = {978-1-4503-0415-3},
  keywords = {compiler-generated software diversity, dynamic patching of software
	vulnerabilities, reverse engineering of security patches, service
	computing architectures, software vulnerabilities},
  numpages = {10},
  owner = {Mathias Payer},
  timestamp = {2012.04.16},
  url = {http://doi.acm.org/10.1145/1900546.1900550}
}

@PHDTHESIS{fraser:practical:thesis:2003,
  author = {Fraser, Keir},
  title = {Practical lock freedom},
  school = {Cambridge University Computer Laboratory},
  year = {2003},
  note = {Also available as Technical Report UCAM-CL-TR-579},
  owner = {Mathias Payer},
  timestamp = {2009.05.25}
}

@INPROCEEDINGS{vtds09gadaleta,
  author = {Gadaleta, Francesco and Younan, Yves and Jacobs, Bart and Joosen,
	Wouter and De Neve, Erik and Beosier, Nils},
  title = {Instruction-level countermeasures against stack-based buffer overflow
	attacks},
  booktitle = {VDTS '09: Proceedings of the 1st EuroSys Workshop on Virtualization
	Technology for Dependable Systems},
  year = {2009},
  pages = {7--12},
  publisher = {ACM},
  abstract = {In this paper, we examine the possibility of using virtualization
	to implement a countermeasure that protects against buffer overflow
	attacks. The countermeasure works by adding a few extra instructions
	to the architecture that are emulated by the hypervisor. After running
	performance benchmarks, a high overhead was observed. Our proof-of-concept
	software implementation illustrates that the proposed approach is
	feasible and that the hardware implementation confirms a negligible
	overhead.},
  doi = {http://doi.acm.org/10.1145/1518684.1518686},
  isbn = {978-1-60558-473-7},
  location = {Nuremberg, Germany},
  owner = {Mathias Payer},
  review = {Introduced special instructions callx/retx (called in function prolog/epilog)
	that save/restore the RIP to a (HW) guarded page.

	Overwriting RIP not possible as it is restored before the ret instruction.


	(looks like BT with a shadow return stack that is forced)


	they have very high overhead!


	--


	Folder BT},
  timestamp = {2009.09.09}
}

@BOOK{gamma95designpatterns,
  title = {Design Patterns},
  publisher = {Addison-Wesley Publishing Co.},
  year = {1995},
  author = {Erich Gamma and Richard Helm and Ralph Johnson and John Vlissides}
}

@INPROCEEDINGS{gao08icis,
  author = {Debin Gao and Michael K. Reiter and Dawn Song},
  title = {{BinHunt}: Automatically Finding Semantic Differences in Binary Programs},
  booktitle = {Proc. 4th Int. Conf. on Information Systems Security},
  abstract = {We introduce BinHunt, a novel technique for ï¬nding semantic diï¬erences
	in binary programs. Semantic diï¬erences between two binary ï¬les contrast
	with syntactic diï¬erences in that semantic diï¬erences correspond
	to changes in the program functionality. Semantic diï¬erences are
	diï¬cult to ï¬nd because of the noise from syntactic diï¬erences caused
	by, e.g., diï¬erent register allocation and basic block re-ordering.
	BinHunt bases its analysis on the control ï¬ow of the programs using
	a new graph isomorphism technique, symbolic execution, and theorem
	proving. We implement a system based on BinHunt and demonstrate the
	application of the system with three case studies in which BinHunt
	manages to identify the semantic diï¬erences between an executable
	and its patched version, revealing the vulnerability that the patch
	eliminates.},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@INPROCEEDINGS{garfinkel03trapsandpitfalls,
  author = {Tal Garfinkel},
  title = {Traps and Pitfalls: Practical Problems in System Call Interposition
	Based Security Tools},
  booktitle = {NDSS'03: Proc. Network and Distributed Systems Security Symp.},
  year = {2003},
  pages = {163--176},
  abstract = {System call interposition is a powerful method for regulating and
	monitoring application behavior. In recent years, a wide variety
	of security tools have been developed that use this technique. This
	approach brings with it a host of pitfalls for the unwary implementer
	that if overlooked can allow his tool to be easily circumvented.
	To shed light on these problems, we present the lessons we learned
	in the course of several design and implementation cycles with our
	own system call interposition-based sandboxing tool. We first present
	some of the problems and pitfalls we encountered, including incorrectly
	replicating OS semantics, overlooking indirect paths to resources,
	race conditions, incorrectly subsetting a complex interface, and
	side effects of denying system calls. We then present some practical
	solutions to these problems, and provide general principles for avoiding
	the difficulties we encountered.},
  owner = {Mathias Payer},
  timestamp = {2010.10.19}
}

@INPROCEEDINGS{garfinkel07hotos,
  author = {Garfinkel, Tal and Adams, Keith and Warfield, Andrew and Franklin,
	Jason},
  title = {Compatibility is not transparency: VMM detection myths and realities},
  booktitle = {HOTOS'07: Proc. 11th USENIX workshop on Hot topics in operating systems},
  year = {2007},
  pages = {6:1--6:6},
  acmid = {1361403},
  articleno = {6},
  numpages = {6},
  owner = {Mathias Payer},
  timestamp = {2012.04.26},
  url = {http://dl.acm.org/citation.cfm?id=1361397.1361403}
}

@INPROCEEDINGS{ostia04,
  author = {Tal Garfinkel and Ben Pfaff and Mendel Rosenblum},
  title = {Ostia: A Delegating architecture for Secure System Call Interposition},
  booktitle = {NDSS'04: Proc. Network and Distributed Systems Security Symp.},
  year = {2004},
  abstract = {Application sandboxes provide restricted execution environments that
	limit an application's access to sensitive OS resources. These systems
	are an increasingly popular method for limiting the impact of a compromise.
	While a variety of mechanisms for building these systems have been
	proposed, the most thoroughly implemented and studied are based on
	system call interposition. Current interposition-based architectures
	offer a wide variety of properties that make them an attractive approach
	for building sandboxing systems. Unfortunately, these architectures
	also possess several critical properties that make their implementation
	error prone and limit their functionality. We present a study of
	Ostia, a sandboxing system we have developed that relies on a ``delegating''
	architecture which overcomes many of the limitations of today's sandboxing
	systems. We compare this delegating architecture to the ``filtering''
	architecture commonly used for sandboxes today. We present the salient
	features of each architecture and examine the design choices that
	significantly impact security, compatibility, flexibility, deployability,
	and performance in this class of system.},
  owner = {Mathias Payer},
  review = {Some system calls are disabled through a kernel module. These system
	calls are then redireced through a delegation model which checks
	parameters (marshalling helps to prevent concurrent security attacks)


	All 'evil' system calls are delegated to a proxy which checks first,
	executes the system call if everything is correct, and returns the
	result},
  timestamp = {2010.09.08}
}

@INPROCEEDINGS{livewire,
  author = {Tal Garfinkel and Mendel Rosenblum},
  title = {A Virtual Machine Introspection Based Architecture for Intrusion
	Detection},
  booktitle = {NDSS'03: Proc. Network and Distributed Systems Security Symp.},
  year = {2003},
  abstract = {Today's architectures for intrusion detection force the IDS designer
	to make a difficult choice. If the IDS resides on the host, it has
	an excellent view of what is happening in that host's software, but
	is highly susceptible to attack. On the other hand, if the IDS resides
	in the network, it is more resistant to attack, but has a poor view
	of what is happening inside the host, making it more susceptible
	to evasion. In this paper we present an architecture that retains
	the visibility of a host-based IDS, but pulls the IDS outside of
	the host for greater attack resistance. We achieve this through the
	use of a virtual machine monitor. Using this approach allows us to
	isolate the IDS from the monitored host but still retain excellent
	visibility into the host's state. The VMM also offers us the unique
	ability to completely mediate interactions between the host software
	and the underlying hardware. We present a detailed study of our architecture,
	including Livewire, a prototype implementation. We demonstrate Livewire
	by implementing a suite of simple intrusion detection policies and
	using them to detect real attacks.},
  owner = {Mathias Payer},
  review = {Livewire: A VMI IDS that extends VMWare and reports intrusions. Different
	events can be monitored and checked according to a policy.},
  timestamp = {2010.09.08}
}

@misc{linuxsysenter,
  author = {Manu Garg},
  owner = {Mathias Payer},
  timestamp = {2008.08.07},
  year = {2006},
  title = {Sysenter Based System Call Mechanism in Linux 2.6},
  howpublished = {\url{http://manugarg.googlepages.com/systemcallinlinux2_6.html}}
}

@ARTICLE{geer03cciar,
  author = {Daniel Geer and Charles P. Pfleeger and Bruce Schneier and John S.
	Quarterman and Perry Metzger and Rebecca Bace and Peter Gutmann},
  title = {{CyberInsecurity}: The Cost of Monopoly -- How the Dominance of {Microsoft}'s
	Products Poses a Risk to Security},
  journal = {Computer \& Communications Industry Association Report},
  year = {2003},
  owner = {Mathias Payer},
  timestamp = {2012.04.16}
}

@INPROCEEDINGS{method-level-phases,
  author = {Andy Georges and Dries Buytaert and Lieven Eeckhout and Koen De Bosschere},
  title = {Method-level phase behavior in java workloads},
  booktitle = {Proc. of the 19th annual ACM SIGPLAN Conference on Object-Oriented
	Programming, Systems, Languages, and Applications (OOPSLA~2004)},
  year = {2004},
  pages = {270--287},
  doi = {http://doi.acm.org/10.1145/1028976.1028999},
  isbn = {1-58113-831-9},
  location = {Vancouver, BC, Canada}
}

@ARTICLE{ghemawat00field,
  author = {Sanjay Ghemawat and Keith H. Randall and Daniel J. Scales},
  title = {Field analysis: getting useful and low-cost interprocedural information},
  journal = {ACM SIG{\-}PLAN Notices},
  year = {2000},
  volume = {35},
  pages = {334--344},
  number = {5},
  url = {citeseer.nj.nec.com/ghemawat00field.html}
}

@ARTICLE{gill51,
  author = {Gill, S.},
  title = {The Diagnosis of Mistakes in Programmes on the {EDSAC}},
  journal = {Proceedings of the Royal Society of London. Series A, Mathematical
	and Physical Sciences},
  year = {1951},
  volume = {206},
  pages = {538--554},
  number = {1087},
  abstract = {This paper describes methods developed at the Cambridge University
	Mathematical Laboratory for the speedy diagnosis of mistakes in programmes
	for an automatic high-speed digital computer. The aim of these methods
	is to avoid undue wastage of machine time, and a principal feature
	is the provision of several standard routines which may be used in
	conjunction with faulty programmes to check the operation of the
	latter. Two of these routines are considered in detail, and the others
	are briefly described.},
  copyright = {Copyright Â© 1951 The Royal Society},
  issn = {00804630},
  jstor_articletype = {primary_article},
  jstor_formatteddate = {May 22, 1951},
  owner = {Mathias Payer},
  publisher = {The Royal Society},
  timestamp = {2009.10.13},
  url = {http://www.jstor.org/stable/98663}
}

@INPROCEEDINGS{126075,
  author = {Aaron J. Goldberg and John L. Hennessy},
  title = {Performance debugging shared memory multiprocessor programs with
	MTOOL},
  booktitle = {Supercomputing '91: Proc. of the 1991 ACM/IEEE conference on Supercomputing},
  year = {1991},
  pages = {481--490},
  doi = {http://doi.acm.org/10.1145/125826.126075},
  isbn = {0-89791-459-7},
  location = {Albuquerque, New Mexico, United States}
}

@INPROCEEDINGS{Goldberg96asecure,
  author = {Ian Goldberg and David Wagner and Randi Thomas and Eric A. Brewer},
  title = {A Secure Environment for Untrusted Helper Applications: Confining
	the Wily Hacker},
  booktitle = {SSYM'06: Proc. 6th USENIX Security Symp.},
  year = {1996},
  abstract = {Many popular programs, such as Netscape, use untrusted helper applications
	to process data from the network. Unfortunately, the unauthenticated
	network data they interpret could well have been created by an adversary,
	and the helper applications are usually too complex to be bug-free.
	This raises significant security concerns. Therefore, it is desirable
	to create a secure environment to contain untrusted helper applications.
	We propose to reduce the risk of a security breach by restricting
	the program's access to the operating system. In particular, we intercept
	and filter dangerous system calls via the Solaris process tracing
	facility. This enabled us to build a simple, clean, user-mode implementation
	of a secure environment for untrusted helper applications. Our implementation
	has negligible performance impact, and can protect pre-existing applications.
	1 Introduction Over the past several years the Internet environment
	has changed drastically. This network, which was once populated...},
  owner = {Mathias Payer},
  timestamp = {2009.09.14}
}

@INPROCEEDINGS{167001,
  author = {Stephen R. Goldschmidt and John L. Hennessy},
  title = {The accuracy of trace-driven simulations of multiprocessors},
  booktitle = {Proc. of the 1993 ACM SIGMETRICS conference on Measurement and modeling
	of computer systems (SIGMETRICS~2001)},
  year = {1993},
  pages = {146--157},
  doi = {http://doi.acm.org/10.1145/166955.167001},
  isbn = {0-89791-580-1},
  location = {Santa Clara, California, United States}
}

@INPROCEEDINGS{goyal03cans,
  author = {Bharat Goyal and Sriranjani Sitaraman and S. Venkatesan},
  title = {A unified approach to detect binding based race condition attacks},
  booktitle = {CANS'03: Intl. Workshop on Cryptology \& Network Security},
  year = {2003},
  abstract = {Synchronization flaws due to race conditions, in which the binding
	of a name to an object changes between repeated references, occur
	in many programs. A malicious program acts by exploiting a window
	of opportunity between the points of execution of another program.
	Such vulnerabilities can be exploited to gain unauthorized access
	to resources of a system. We propose a unified approach to detect
	and analyze these flaws in the Unix file system. We use our approach
	to identify binding based race condition attacks in an interleaved
	execution trace of a system utility and a malicious program. We apply
	our approach to numerous binding based race condition attacks. We
	also present an algorithm to flag these attacks when an interleaved
	execution trace of a system utility with a malicious program is available.},
  owner = {Mathias Payer},
  timestamp = {2011.05.10}
}

@INPROCEEDINGS{grossman07tmgcanalogy,
  author = {Dan Grossman},
  title = {The transactional memory / garbage collection analogy},
  booktitle = {OOPSLA '07: Proceedings of the 22nd annual ACM SIGPLAN conference
	on Object oriented programming systems and applications},
  year = {2007},
  pages = {695--706},
  abstract = {This essay presents remarkable similarities between transactional
	memory and garbage collection. The connections are fascinating in
	their own right, and they let us better understand one technology
	by thinking about the corresponding issues for the other.},
  doi = {http://doi.acm.org/10.1145/1297027.1297080},
  isbn = {978-1-59593-786-5},
  keywords = {TM, analogy},
  location = {Montreal, Quebec, Canada},
  owner = {Mathias Payer},
  review = {Transactional Memory is to shared memory concurrency as garbage collection
	is to memory management


	print -> 1},
  timestamp = {2008.08.10}
}

@INPROCEEDINGS{guyer99dsl,
  author = {Samuel Z. Guyer and Calvin Lin},
  title = {An annotation language for optimizing software libraries},
  booktitle = {DSL},
  year = {1999},
  pages = {39-52},
  abstract = { This paper introduces an annotation language and a compiler that
	together can customize a library implementation for specific application
	needs. Our approach is distinguished by its ability to exploit high
	level, domain-specific information in the customization process.
	In particular, the annotations provide semantic information that
	enables our compiler to analyze and optimize library operations as
	if they were primitives of a domain-specific language. Thus, our
	approach yields many of the performance benefits of domain-specific
	languages, without the effort of developing a new compiler for each
	domain. This paper presents the annotation language, describes its
	role in optimization, and illustrates the benefits of the overall
	approach. Using a partially implemented compiler, we show how our
	system can significantly improve the performance of two applications
	written using the PLAPACK parallel linear algebra library. },
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://doi.acm.org/10.1145/331960.331970}
}

@MISC{haas10formatstring,
  author = {Paul Haas},
  title = {Advanced Format String Attacks},
  howpublished = {\url{https://www.defcon.org/images/defcon-18/dc-18-presentations/Haas/DEFCON-18-Haas-Adv-Format-String-Attacks.pdf}},
  month = {DEFCON 18},
  year = {2010},
  owner = {Mathias Payer},
  timestamp = {2011.11.21}
}

@ARTICLE{SUIF,
  author = {Mary W. Hall and Jennifer M. Anderson and Saman P. Amarasinghe and
	Brian R. Murphy and Shih-Wei Liao and Edouard Bugnion and Monica
	S. Lam},
  title = {Maximizing Multiprocessor Performance with the SUIF Compiler},
  journal = {Computer},
  year = {1996},
  volume = {29},
  pages = {84--89},
  number = {12},
  doi = {http://dx.doi.org/10.1109/2.546613},
  keywords = {multiprocessor, compiler, static},
  owner = {Mathias Payer},
  review = {print -> 1},
  timestamp = {2007.10.04},
  url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=546613}
}

@ARTICLE{harris03language,
  author = {T. Harris and K. Fraser},
  title = {Language support for lightweight transactions},
  journal = {SIGPLAN Not.},
  year = {2003},
  volume = {38},
  pages = {pp. 388--402},
  abstract = {Concurrent programming is notoriously di#cult. Current

	abstractions are intricate and make it hard to design computer

	systems that are reliable and scalable. We argue that

	these problems can be addressed by moving to a declarative

	style of concurrency control in which programmers directly

	indicate the safety properties that they require.},
  citeseerurl = {http://citeseer.ist.psu.edu/harris03language.html},
  keywords = {java stm, STM, TM},
  owner = {Mathias Payer},
  review = {STM for Java (extension)

	-> orec, keep Track of Locations & owners

	-> no stack STM (new methods for transactional parts)


	print -> 1},
  text = {Tim Harris and Keir Fraser. Language support for lightweight transactions.
	In OOPSLA, pages 388--402, 2003.},
  timestamp = {2007.10.05},
  url = {http://citeseer.ist.psu.edu/harris03language.html}
}

@ARTICLE{pldi06bartokstm,
  author = {Harris, Tim and Plesko, Mark and Shinnar, Avraham and Tarditi, David},
  title = {Optimizing memory transactions},
  journal = {SIGPLAN Not.},
  year = {2006},
  volume = {41},
  pages = {pp. 14--25},
  number = {6},
  abstract = {Atomic blocks allow programmers to delimit sections of code as 'atomic',
	leaving the language's implementation to enforce atomicity. Existing
	work has shown how to implement atomic blocks over word-based transactional
	memory that provides scalable multi-processor performance without
	requiring changes to the basic structure of objects in the heap.
	However, these implementations perform poorly because they interpose
	on all accesses to shared memory in the atomic block, redirecting
	updates to a thread-private log which must be searched by reads in
	the block and later reconciled with the heap when leaving the block.This
	paper takes a four-pronged approach to improving performance: (1)
	we introduce a new 'direct access' implementation that avoids searching
	thread-private logs, (2) we develop compiler optimizations to reduce
	the amount of logging (e.g. when a thread accesses the same data
	repeatedly in an atomic block), (3) we use runtime filtering to detect
	duplicate log entries that are missed statically, and (4) we present
	a series of GC-time techniques to compact the logs generated by long-running
	atomic blocks.Our implementation supports short-running scalable
	concurrent benchmarks with less than 50\% overhead over a non-thread-safe
	baseline. We support long atomic blocks containing millions of shared
	memory accesses with a 2.5-4.5x slowdown.},
  doi = {http://doi.acm.org/10.1145/1133255.1133984},
  issn = {0362-1340},
  keywords = {STM, TM, Bartok, C#},
  owner = {Mathias Payer},
  publisher = {ACM},
  review = {early version of versioning stm with eager-locking and in-place-update
	(write-through) (bartok STM)},
  timestamp = {2009.10.07}
}

@INPROCEEDINGS{vertical-prof,
  author = {Matthias Hauswirth and Peter F. Sweeney and Amer Diwan and Michael
	Hind},
  title = {Vertical profiling: understanding the behavior of object-priented
	applications},
  booktitle = {Proc. of the 19th annual ACM SIGPLAN Conference on Object-Oriented
	Programming, Systems, Languages, and Applications (OOPSLA~2004)},
  year = {2004},
  pages = {251--269},
  doi = {http://doi.acm.org/10.1145/1028976.1028998},
  isbn = {1-58113-831-9},
  location = {Vancouver, BC, Canada}
}

@ARTICLE{hazelwood06boundedcache,
  author = {Kim Hazelwood and Michael D. Smith},
  title = {Managing bounded code caches in dynamic binary optimization systems},
  journal = {TACO '06},
  year = {2006},
  volume = {3},
  pages = {263--294},
  number = {3},
  doi = {http://doi.acm.org/10.1145/1162690.1162692},
  issn = {1544-3566},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@INPROCEEDINGS{1167495,
  author = {Maurice Herlihy and Victor Luchangco and Mark Moir},
  title = {A flexible framework for implementing software transactional memory},
  booktitle = {OOPSLA '06: Proceedings of the 21st annual ACM SIGPLAN conference
	on Object-oriented programming systems, languages, and applications},
  year = {2006},
  pages = {253--262},
  abstract = {We describe DSTM2, a Javaâ¢ software library that provides a flexible
	framework for implementing object-based software transactional memory
	(STM). The library uses transactional factories to transform sequential
	(unsynchronized) classes into atomic (transactionally synchronized)
	ones, providing a substantial improvement over the awkward programming
	interface of our previous DSTM library. Furthermore, researchers
	can experiment with alternative STM mechanisms by providing their
	own factories. We demonstrate this flexibility by presenting two
	factories: one that uses essentially the same mechanisms as the original
	DSTM (with some enhancements),and another that uses a completely
	different approach.Because DSTM2 is packaged as a Java library, a
	wide range of programmers can easily try it out, and the community
	can begin to gain experience with transactional programming. Furthermore,
	researchers will be able to use the body of transactional programs
	that arises from this community experience to test and evaluate different
	STM mechanisms simply by supplying new transactional factories. We
	believe that this flexible approach will help to build consensus
	about the best ways to implement transactions, and will avoid the
	premature "lock-in" that may arise if STM mechanisms are baked into
	compilers before such experimentation is done.},
  doi = {http://doi.acm.org/10.1145/1167473.1167495},
  isbn = {1-59593-348-4},
  keywords = {java stm, class rewriting, TM},
  location = {Portland, Oregon, USA},
  owner = {Mathias Payer},
  review = {Library for STM -> no 'internal' support in JVM

	-> uses reflection to rewrite classes

	-> STM as lock replacement

	dSTM2 - for java

	use bytecoderewriting to implement stm

	object based


	print -> 1},
  timestamp = {2007.10.05}
}

@INPROCEEDINGS{herlihy:stm-dynamic:podc:2003,
  author = {Herlihy, Maurice and Luchangco, Victor and Moir, Mark and {William
	N. Scherer}, III},
  title = {Software Transactional Memory for Dynamic-Sized Data Structures},
  booktitle = {PODC'03},
  year = {2003},
  pages = {92--101},
  month = {Jul},
  keywords = {STM, TM, DSTM},
  owner = {Mathias Payer},
  review = {DSTM


	Obj -> Trans

	 -> Old

	 -> New


	+ Comparison of different contention managers},
  timestamp = {2007.10.05},
  url = {http://doi.acm.org/10.1145/872035.872048}
}

@INPROCEEDINGS{herlihy93transactional,
  author = {M. Herlihy and J. E. B. Moss},
  title = {Transactional Memory: {Architectural} Support For Lock-Free Data
	Structures},
  booktitle = {ISCA'93},
  year = {1993},
  keywords = {TM, HTM},
  owner = {Mathias Payer},
  review = {- hardware transactional memory

	- concepts and foundations

	- also uses information about cache coherency protocols},
  timestamp = {2008.02.08},
  url = {citeseer.ist.psu.edu/herlihy93transactional.html}
}

@INPROCEEDINGS{hicks01pldi,
  author = {Hicks, Michael and Moore, Jonathan T. and Nettles, Scott},
  title = {Dynamic software updating},
  booktitle = {PLDI'01},
  doi = {http://doi.acm.org/10.1145/378795.378798},
  isbn = {1-58113-414-2},
  numpages = {11},
  url = {http://doi.acm.org/10.1145/378795.378798}
}

@ARTICLE{propolice01hiroaki,
  author = {Etoh Hiroaki and Yoda Kunikazu},
  title = {{ProPolice}: Improved stack-smashing attack detection},
  journal = {IPSJ SIG Notes},
  year = {2001},
  pages = {181-188},
  abstract = {This paper presents some new ideas for improving the state of the
	art in buffer overflow detection. The main ideas are(1)the reordering
	of local variables to place buffers after pointers to avoid the corruption
	of pointers that could be used to further corrupt arbitrary memory
	locations, (2)the copying of pointers in function arguments to an
	area preceding local variable buffers to prevent the corruption of
	pointers that could be used to further corrupt arbitrary memory locations,
	and the(3)omission of instrumentation code from some functions to
	decrease the performance overhead.},
  issn = {09196072},
  owner = {Mathias Payer},
  publisher = {Information Processing Society of Japan (IPSJ)},
  timestamp = {2010.10.29},
  url = {http://ci.nii.ac.jp/naid/110002675568/en/}
}

@INPROCEEDINGS{hiser06optimization,
  author = {Jason Hiser and Naveen Kumar and Min Zhao and Shukang Zhou and Bruce
	R. Childers and Jack W. Davidson and Mary Lou Soffa},
  title = {Techniques and tools for dynamic optimization.},
  booktitle = {IPDPS},
  year = {2006},
  date = {2007-05-20},
  description = {dblp},
  ee = {http://dx.doi.org/10.1109/IPDPS.2006.1639569},
  keywords = {dblp },
  owner = {Mathias Payer},
  timestamp = {2008.07.30},
  url = {http://dblp.uni-trier.de/db/conf/ipps/ipdps2006.html#HiserKZZCDS06}
}

@INPROCEEDINGS{strata06,
  author = {Hiser, Jason D. and Williams, Daniel and Filipi, Adrian and Davidson,
	Jack W. and Childers, Bruce R.},
  title = {Evaluating fragment construction policies for SDT systems},
  booktitle = {VEE'06: Proceedings of the 2nd international conference on Virtual
	execution environments},
  year = {2006},
  pages = {122--132},
  publisher = {ACM},
  abstract = {Software Dynamic Translation (SDT) systems have been used for program
	instrumentation, dynamic optimization, security policy enforcement,
	intrusion detection, and many other uses. To be widely applicable,
	the overhead (runtime, memory usage, and power consumption) should
	be as low as possible. For instance, if an SDT system is protecting
	a web server against possible attacks, but causes 30% slowdown, a
	company may need 30% more machines to handle the web traffic they
	expect. Consequently, the causes of SDT overhead should be studied
	rigorously. This work evaluates many alternative policies for the
	creation of fragments within the Strata SDT framework. In particular,
	we examine the effects of ending translation at conditional branches;
	ending translation at unconditional branches; whether to use partial
	inlining for call instructions; whether to build the target of calls
	immediately or lazily; whether to align branch targets; and how to
	place code to transition back to the dynamic translator. We find
	that effective translation strategies are vital to program performance,
	improving performance from as much as 28% overhead, to as little
	as 3% overhead on average for the SPEC CPU2000 benchmark suite. We
	further demonstrate that these translation strategies are effective
	across several platforms, including Sun SPARC UltraSparc IIi, AMD
	Athlon Opteron, and Intel Pentium IV processors.},
  doi = {http://doi.acm.org/10.1145/1134760.1134778},
  isbn = {1-59593-332-6},
  location = {Ottawa, Ontario, Canada},
  owner = {Mathias Payer},
  review = {Strata: BT, changes ret instrs and stack (translated address is on
	stack)

	-> opts for bts with translated stacks

	-> no inlining (but greedy trace building like fastBT)},
  timestamp = {2009.10.20}
}

@INPROCEEDINGS{hiser07indbranchhandling,
  author = {Hiser, Jason D. and Williams, Daniel and Hu, Wei and Davidson, Jack
	W. and Mars, Jason and Childers, Bruce R.},
  title = {Evaluating Indirect Branch Handling Mechanisms in Software Dynamic
	Translation Systems},
  booktitle = {CGO '07},
  year = {2007},
  pages = {61--73},
  abstract = {Software Dynamic Translation (SDT) systems are used for program instrumentation,
	dynamic optimization, security, intrusion detection, and many other
	uses. As noted by many researchers, a major source of SDT overhead
	is the execution of code which is needed to translate an indirect
	branch's target address into the address of the translated destination
	block. This paper discusses the sources of indirect branch (IB) overhead
	in SDT systems and evaluates several techniques for overhead reduction.
	Measurements using SPEC CPU2000 show that the appropriate choice
	and configuration of IB translation mechanisms can significantly
	reduce the IB handling overhead. In addition, cross-architecture
	evaluation of IB handling mechanisms reveals that the most efficient
	implementation and configuration can be highly dependent on the implementation
	of the underlying architecture.},
  doi = {http://dx.doi.org/10.1109/CGO.2007.10},
  isbn = {0-7695-2764-7},
  owner = {Mathias Payer},
  review = {rets are changed (as is stack layout - errors for exception handling!)


	paper offers differend mechanisms for ind. branch handling:

	* sieve

	* inline lookup

	* caching (special IB cache for ~1k entries)


	Folder BT},
  timestamp = {2009.05.31}
}

@INPROCEEDINGS{taintbasedprotection06ho,
  author = {Ho, Alex and Fetterman, Michael and Clark, Christopher and Warfield,
	Andrew and Hand, Steven},
  title = {Practical taint-based protection using demand emulation},
  booktitle = {EuroSys'06: Proc. 1st Europ. Conf. Comp. Sys.},
  year = {2006},
  pages = {29--41},
  abstract = {Many software attacks are based on injecting malicious code into a
	target host. This paper demonstrates the use of a well-known technique,
	data tainting, to track data received from the network as it propagates
	through a system and to prevent its execution. Unlike past approaches
	to taint tracking, which track tainted data by running the system
	completely in an emulator or simulator, resulting in considerable
	execution overhead, our work demonstrates the ability to dynamically
	switch a running system between virtualized and emulated execution.
	Using this technique, we are able to explore hardware support for
	taint-based protection that is deployable in real-world situations,
	as emulation is only used when tainted data is being processed by
	the CPU. By modifying the CPU, memory, and I/O devices to support
	taint tracking and protection, we guarantee that data received from
	the network may not be executed, even if it is written to, and later
	read from disk. We demonstrate near native speeds for workloads where
	little taint data is present.},
  doi = {http://doi.acm.org/10.1145/1218063.1217939},
  issn = {0163-5980},
  journal = {SIGOPS Oper. Syst. Rev.},
  owner = {Mathias Payer},
  timestamp = {2010.10.29}
}

@INPROCEEDINGS{huang10icc,
  author = {Huang, Nen-Fu and Tsai, Wen-Yen},
  title = {{SHOCK}: A Worst-Case Ensured Sub-Linear Time Pattern Matching Algorithm
	for Inline Anti-Virus Scanning.},
  booktitle = {ICC},
  year = {2010},
  pages = {1-5},
  publisher = {IEEE},
  ee = {http://dx.doi.org/10.1109/ICC.2010.5501986},
  isbn = {978-1-4244-6402-9},
  owner = {Mathias Payer},
  timestamp = {2012.04.16},
  url = {http://dblp.uni-trier.de/db/conf/icc/icc2010.html#HuangT10}
}

@MISC{pseudojbb,
  author = {Wei Huang},
  title = {{PSEUDOJBB} {B}enchmark},
  howpublished = {http://csl.ee.iastate.edu/~huangwei/pseudojbb.htm}
}

@INPROCEEDINGS{OBJECTREORDER-OOPSLA04,
  author = {Xianglong Huang and Stephen M. Blackburn and Kathryn S. McKinley
	and J Eliot B. Moss and Zhenlin Wang and Perry Cheng},
  title = {The garbage collection advantage: improving program locality},
  booktitle = {Proc.~of the ACM Conf.~on Object-Oriented Programming, Systems, Languages,
	and Applications (OOPSLA~2004)},
  year = {2004},
  pages = {69--80},
  doi = {http://doi.acm.org/10.1145/1028976.1028983},
  isbn = {1-58113-831-9},
  location = {Vancouver, BC, Canada}
}

@ARTICLE{hudak96acs,
  author = {Hudak, Paul},
  title = {Building domain-specific embedded languages},
  journal = {ACM Comput. Surv.},
  year = {1996},
  volume = {28},
  month = {Dec.},
  abstract = {this paper I will describe the results of using the functional language
	Haskell to build DSELs. Haskell has several features that make it
	particularly suitable for this, but other languages could also be
	used. On the other hand, there are features that don't exist in any
	language (to my knowledge) that would make things even easier; there
	is much more work to be done. Domain Specific Semantics It is surprisingly
	straightforward to design a DSEL for many specific applications.
	We have done so already using Haskell in several domains: parser
	generation, graphics, animation, simulation, music composition, and
	geometric region analysis, to -- Geometric regions are represented
	as functions: type Region = Point -? Bool -- so to test a point's
	membership in a region, we do: inRegion :: Point -? Region -? Bool
	p `inRegion` r = r p -- Given suitable definitions of "circle", "outside",
	and /": circle :: Radius -? Region -- creates a region with given
	radius outside :: Region -? Region -- the logical negation of a region
	(/") :: Region -? Region -? Region -- the intersection of two regions
	-- we can then define a function to generate an annulus: annulus
	:: Radius -? Radius -? Region annulus r1 r2 = outside (circle r1)
	/" circle r2 Figure 1: Example of a DSEL for a Naval Application
	name a few. The latter domain---geometric region analysis---came
	about through an experiment conducted jointly by Arpa, ONR, and the
	Naval Surface Warfare Center. This well-documented experiment (see
	[Car93, CHJ93, LBK },
  acmid = {242477},
  address = {New York, NY, USA},
  articleno = {196},
  doi = {http://doi.acm.org/10.1145/242224.242477},
  issn = {0360-0300},
  issue = {4es},
  issue_date = {Dec. 1996},
  publisher = {ACM},
  url = {http://doi.acm.org/10.1145/242224.242477}
}

@INPROCEEDINGS{mcrt-malloc06,
  author = {Hudson,, Richard L. and Saha,, Bratin and Adl-Tabatabai,, Ali-Reza
	and Hertzberg,, Benjamin C.},
  title = {{McRT-Malloc}: a scalable transactional memory allocator},
  booktitle = {ISMM'06},
  year = {2006},
  pages = {74--83},
  publisher = {ACM},
  abstract = {Emerging multi-core processors promise to provide an exponentially
	increasing number of hardware threads with every generation. Applications
	will need to be highly concurrent to fullyuse the power of these
	processors. To enable maximum concurrency, libraries (such as malloc-free
	packages) would therefore need to use non-blocking algorithms. But
	lock-free algorithms are notoriously difficult to reason about and
	inappropriate for average programmers. Transactional memory promises
	to significantly ease concurrent programming for the average programmer.
	This paper describes a highly efficient non-blocking malloc/free
	algorithm that supports memory allocation and deallocation inside
	transactional code blocks. Thus this paper describes a memory allocator
	that is suitable for emerging multi-core applications, while supporting
	modern concurrency constructs.This paper makes several novel contributions.
	It is the first to integrate a software transactional memory system
	with a malloc/free based memory allocator. We present the first algorithm
	which ensures that space allocated in an aborted transaction is properly
	freed and does not lead to a space blowup. Unlike previous lock-free
	malloc packages, our algorithm avoids atomic operations on typical
	code paths, making our algorithm substantially more efficient.},
  doi = {http://doi.acm.org/10.1145/1133956.1133967},
  isbn = {1-59593-221-6},
  keywords = {STM, TM, McRT-Malloc, memory allocation},
  location = {Ottawa, Ontario, Canada},
  owner = {Mathias Payer},
  review = {they describe an multi core memory allocator with thread local memory
	pools.


	they serve some special needs of an stm system!


	Thread Local Buffer (like google tcmalloc)

	+ Special functions (like getSize for free) for STMs

	+ Nesting supported (nested free, nested malloc)


	Belongs to McRT-STM},
  timestamp = {2009.04.08}
}

@INPROCEEDINGS{johnson11sp,
  author = {Noah M. Johnson and Juan Caballero and Kevin Zhijie Chen and Stephen
	McCamant and Pongsin Poosankam and Daniel Reynaud and Dawn Song},
  title = {Differential Slicing: Identifying Causal Execution Differences for
	Security Applications},
  booktitle = {IEEE S\&P'11},
  abstract = {A security analyst often needs to understand two runs of the same
	program that exhibit a difference in program state or output. This
	is important, for example, for vulnerability analysis, as well as
	for analyzing a malware program that features different behaviors
	when run in different environments. In this paper we propose a differential
	slicing approach that automates the analysis of such execution differences.
	Differential slicing outputs a causal difference graph that captures
	the input differences that triggered the observed difference and
	the causal path of differences that led from those input differences
	to the observed difference. The analyst uses the graph to quickly
	understand the observed difference. We implement differential slicing
	and evaluate it on the analysis of 11 real-world vulnerabilities
	and 2 malware samples with environment-dependent behaviors. We also
	evaluate it in an informal user study with two vulnerability analysts.
	Our results show that differential slicing successfully identifies
	the input differences that caused the observed difference and that
	the causal difference graph significantly reduces the amount of time
	and effort required for an analyst to understand the observed difference.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://doi.ieeecomputersociety.org/10.1109/SP.2011.41},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@INPROCEEDINGS{joshi05sosp,
  author = {Joshi, Ashlesha and King, Samuel T. and Dunlap, George W. and Chen,
	Peter M.},
  title = {Detecting past and present intrusions through vulnerability-specific
	predicates},
  booktitle = {SOSP'05: Proc. 20th ACM Symposium on Operating Systems Principles},
  year = {2005},
  pages = {91--104},
  abstract = {Most systems contain software with yet-to-be-discovered security vulnerabilities.
	When a vulnerability is disclosed, administrators face the grim reality
	that they have been running software which was open to attack. Sites
	that value availability may be forced to continue running this vulnerable
	software until the accompanying patch has been tested. Our goal is
	to improve security by detecting intrusions that occurred before
	the vulnerability was disclosed and by detecting and responding to
	intrusions that are attempted after the vulnerability is disclosed.
	We detect when a vulnerability is triggered by executing vulnerability-specific
	predicates as the system runs or replays. This paper describes the
	design, implementation and evaluation of a system that supports the
	construction and execution of these vulnerability-specific predicates.
	Our system, called IntroVirt, uses virtual-machine introspection
	to monitor the execution of application and operating system software.
	IntroVirt executes predicates over past execution periods by combining
	virtual-machine introspection with virtual-machine replay. IntroVirt
	eases the construction of powerful predicates by allowing predicates
	to run existing target code in the context of the target system,
	and it uses checkpoints so that predicates can execute target code
	without perturbing the state of the target system. IntroVirt allows
	predicates to refresh themselves automatically so they work in the
	presence of preemptions. We show that vulnerability-specific predicates
	can be written easily for a wide variety of real vulnerabilities,
	can detect and respond to intrusions over both the past and present
	time intervals, and add little overhead for most vulnerabilities.},
  acmid = {1095820},
  doi = {http://doi.acm.org/10.1145/1095810.1095820},
  isbn = {1-59593-079-5},
  keywords = {IntroVirt, intrusion detection, semantic gap, virtual-machine introspection,
	virtual-machine replay, vulnerability-specific predicates},
  location = {Brighton, United Kingdom},
  numpages = {14},
  owner = {Mathias Payer},
  timestamp = {2011.05.09},
  url = {http://doi.acm.org/10.1145/1095810.1095820}
}

@INPROCEEDINGS{kang09vmsec,
  author = {Kang, Min Gyung and Yin, Heng and Hanna, Steve and McCamant, Stephen
	and Song, Dawn},
  title = {Emulating emulation-resistant malware},
  booktitle = {VMSec'09: Proc. 1st ACM Workshop on Virtual Machine Security},
  year = {2009},
  pages = {11--22},
  doi = {10.1145/1655148.1655151},
  keywords = {dynamic analysis, emulation, malware analysis, virtualization},
  numpages = {12},
  owner = {Mathias Payer},
  timestamp = {2012.04.26},
  url = {http://doi.acm.org/10.1145/1655148.1655151}
}

@ARTICLE{msf09ppopp,
  author = {Kang, Seunghwa and Bader, David A.},
  title = {An efficient transactional memory algorithm for computing minimum
	spanning forest of sparse graphs},
  journal = {SIGPLAN Not.},
  year = {2009},
  volume = {44},
  pages = {15--24},
  number = {4},
  abstract = {Due to power wall, memory wall, and ILP wall, we are facing the end
	of ever increasing single-threaded performance. For this reason,
	multicore and manycore processors are arising as a new paradigm to
	pursue. However, to fully exploit all the cores in a chip, parallel
	programming is often required, and the complexity of parallel programming
	raises a significant concern. Data synchronization is a major source
	of this programming complexity, and Transactional Memory is proposed
	to reduce the difficulty caused by data synchronization requirements,
	while providing high scalability and low performance overhead.


	The previous literature on Transactional Memory mostly focuses on
	architectural designs. Its impact on algorithms and applications
	has not yet been studied thoroughly. In this paper, we investigate
	Transactional Memory from the algorithm designer's perspective. This
	paper presents an algorithmic model to assist in the design of efficient
	Transactional Memory algorithms and a novel Transactional Memory
	algorithm for computing a minimum spanning forest of sparse graphs.
	We emphasize multiple Transactional Memory related design issues
	in presenting our algorithm. We also provide experimental results
	on an existing software Transactional Memory system. Our algorithm
	demonstrates excellent scalability in the experiments, but at the
	same time, the experimental results reveal the clear limitation of
	software Transactional Memory due to its high performance overhead.
	Based on our experience, we highlight the necessity of efficient
	hardware support for Transactional Memory to realize the potential
	of the technology.},
  doi = {http://doi.acm.org/10.1145/1594835.1504182},
  issn = {0362-1340},
  keywords = {STM, TM, TL2},
  owner = {Mathias Payer},
  publisher = {ACM},
  review = {Implementation of an parallel MST (minimum spanning tree) algorithm
	for STMs


	Conclusion: STM needs too many operations (data structure access,
	loads, stores, computation) for a transactional load and store

	=> Speedup eaten by STM overhead

	=> Used TL2},
  timestamp = {2009.10.21}
}

@INPROCEEDINGS{kazi:JavaSpMT,
  author = {I. H. Kazi and D. J. Lilja},
  title = {JavaSpMT: A Speculative Thread Pipelining Parallelization Model for
	Java Programs},
  booktitle = {Proceedings of the 14th International Symposium on Parallel and Distributed
	Processing (IDPS~2000)},
  year = {2000},
  pages = {559},
  abstract = {This paper presents a new approach to improve execution-time

	performance of Java programs by

	exploiting coarse-grained parallelism on a shared-memory

	multiprocessor system. The parallelization

	model, called Java Speculative MultiThreading (JavaSpMT), uses a

	speculative thread pipelining execution

	model with run-time data-dependence checking to execute concurrent

	threads. The control

	speculation combined with the run-time dependence checking allows

	JavaSpMT to parallelize a wide

	variety of loop constructs, including do-while loops, that cannot
	be

	parallelized using standard parallelization

	techniques. JavaSpMT is implemented using the standard Java

	multithreading mechanism

	and the parallelization is expressed by a Java source-to-source

	transformation. Thus, the transformed

	programs are still portable to any shared-memory multiprocessor

	system with a Java Virtual Machine

	implementation that supports native threads. We have evaluated the

	performance of the JavaSpMT

	model on an 8-processor...},
  isbn = {0-7695-0574-0},
  keywords = {javaspmt, parallelization, source-to-source, java threads},
  review = {- Parallelization for Java [Threads]

	- Source-to-source

	- No change to VM -> high overhead (no low-level information)


	print -> 1},
  url = {citeseer.ist.psu.edu/kazi00javaspmt.html}
}

@INPROCEEDINGS{kc03randomization,
  author = {G.S. Kc and A.D. Keromytis and V. Prevelakis},
  title = {Countering Code-Injection Attacks with Instruction-Set Randomization},
  booktitle = {Proc. of the 10th {ACM} Conference on Computer and Communications
	Security},
  year = {2003},
  month = {Oct},
  abstract = {We describe a new, general approach for safeguarding systems against
	any type of code-injection attack. We apply Kerckhoffâs principle,
	by creating process-speciï¬c randomized instruction sets (e.g., machine
	instructions) of the system executing potentially vulnerable software.
	An attacker who does not know the key to the randomization algorithm
	will inject code that is invalid for that randomized processor, causing
	a runtime exception. To determine the difï¬culty of integrating support
	for the proposed mechanism in the operating system, we modiï¬ed the
	Linux kernel, the GNU binutils tools, and the bochs-x86 emulator.
	Although the performance penalty is signiï¬cant, our prototype demonstrates
	the feasibility of the approach, and should be directly usable on
	a suitable-modiï¬ed processor (e.g., the Transmeta Crusoe).


	Our approach is equally applicable against code-injecting attacks
	in scripting and interpreted languages, e.g., web-based SQL injection.
	We demonstrate this by modifying the Perl interpreter to permit randomized
	script execution. The performance penalty in this case is minimal.
	Where our proposed approach is feasible (i.e., in an emulated environment,
	in the presence of programmable or specialized hardware, or in interpreted
	languages), it can serve as a low-overhead protection mechanism,
	and can easily complement other mechanisms.},
  owner = {Mathias Payer},
  timestamp = {2011.11.21}
}

@INPROCEEDINGS{kc03ccs,
  author = {Kc, Gaurav S. and Keromytis, Angelos D. and Prevelakis, Vassilis},
  title = {Countering code-injection attacks with instruction-set randomization},
  booktitle = {CCS'03: Proc. 10th Conf. on Computer and Communications Security},
  year = {2003},
  pages = {272--280},
  abstract = {We describe a new, general approach for safeguarding systems against
	any type of code-injection attack. We apply Kerckhoff's principle,
	by creating process-specific randomized instruction sets (e.g., machine
	instructions) of the system executing potentially vulnerable software.
	An attacker who does not know the key to the randomization algorithm
	will inject code that is invalid for that randomized processor, causing
	a runtime exception. To determine the difficulty of integrating support
	for the proposed mechanism in the operating system, we modified the
	Linux kernel, the GNU binutils tools, and the bochs-x86 emulator.
	Although the performance penalty is significant, our prototype demonstrates
	the feasibility of the approach, and should be directly usable on
	a suitable-modified processor (e.g., the Transmeta Crusoe).Our approach
	is equally applicable against code-injecting attacks in scripting
	and interpreted languages, e.g., web-based SQL injection. We demonstrate
	this by modifying the Perl interpreter to permit randomized script
	execution. The performance penalty in this case is minimal. Where
	our proposed approach is feasible (i.e., in an emulated environment,
	in the presence of programmable or specialized hardware, or in interpreted
	languages), it can serve as a low-overhead protection mechanism,
	and can easily complement other mechanisms.},
  doi = {10.1145/948109.948146},
  isbn = {1-58113-738-9},
  keywords = {buffer overflows, emulators, interpreters},
  numpages = {9},
  owner = {Mathias Payer},
  timestamp = {2012.04.18},
  url = {http://doi.acm.org/10.1145/948109.948146}
}

@INPROCEEDINGS{keleher92lrc,
  author = {Pete Keleher and Alan L. Cox and Willy Zwaenepoel},
  title = {Lazy release consistency for software distributed shared memory},
  booktitle = {ISCA '92: Proceedings of the 19th annual international symposium
	on Computer architecture},
  year = {1992},
  pages = {13--21},
  abstract = {Relaxed memory consistency models, such as release consistency, were
	introduced in order to reduce the impact of remote memory access
	latency in both software and hardware distributed shared memory (DSM).
	However, in a software DSM, it is also important to reduce the number
	of messages and the amount of data exchanged for remote memory access.
	Lazy release consistency is a new algorithm for implementing release
	consistency that lazily pulls modifications across the interconnect
	only when necessary. Trace-driven simulation using the SPLASH benchmarks
	indicates that lazy release consistency reduces both the number of
	messages and the amount of data transferred between processors. These
	reductions are especially significant for programs that exhibit false
	sharing and make extensive use of locks.},
  doi = {http://doi.acm.org/10.1145/139669.139676},
  isbn = {0-89791-509-7},
  location = {Queensland, Australia},
  owner = {Mathias Payer},
  review = {dsm paper


	distributed shared memory


	updates only on aquire and at fixed time intervals


	print -> 1},
  timestamp = {2008.08.10}
}

@ARTICLE{kennedy99partial,
  author = {Robert Kennedy and Sun Chan and Shin-Ming Liu and Raymond Lo and
	Peng Tu and Fred Chow},
  title = {Partial redundancy elimination in {SSA} form},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {1999},
  volume = {21},
  pages = {627--676},
  number = {3},
  url = {citeseer.nj.nec.com/kennedy99partial.html}
}

@INPROCEEDINGS{shepherding02,
  author = {Kiriansky, Vladimir and Bruening, Derek and Amarasinghe, Saman P.},
  title = {Secure Execution via Program Shepherding},
  booktitle = {SSYM'02},
  isbn = {1-931971-00-5},
  owner = {Mathias Payer},
  review = {Uses DynmoRIO to safeguard applications (BT)

	-> only single policy implemented, hard policy in code

	-> restricts code origins and control transfers

	-> uses BT for sandboxing

	-> 10% overhead on average, no idea about short programs},
  timestamp = {2010.02.02}
}

@INPROCEEDINGS{kisserli07cobassa,
  author = {Nessim Kisserli and Jan Cappaert and Bart Preneel},
  title = {Software Security through Targeted Diversification},
  booktitle = {Proceedings Third Int. Workshop on Code Based Software Security Assessments},
  year = {2007},
  owner = {Mathias Payer},
  timestamp = {2012.04.16}
}

@ARTICLE{kistler01optimization,
  author = {Thomas Kistler and Michael Franz},
  title = {Continuous Program Optimization: Design and Evaluation},
  journal = {IEEE Trans. Comput.},
  year = {2001},
  volume = {50},
  pages = {549--566},
  number = {6},
  doi = {http://dx.doi.org/10.1109/12.931893},
  issn = {0018-9340},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@ARTICLE{DATALAYOUT-FRANZ00,
  author = {Thomas Kistler and Michael Franz},
  title = {Automated data-member layout of heap objects to improve memory-hierarchy
	performance},
  journal = {ACM Trans. Program. Lang. Syst.},
  year = {2000},
  volume = {22},
  pages = {490--505},
  number = {3},
  doi = {http://doi.acm.org/10.1145/353926.353937},
  issn = {0164-0925}
}

@BOOK{Knuth:1973:ACP,
  title = {The Art of Computer Programming, Sorting and Searching},
  publisher = {Ad{\-d}i{\-s}on-Wes{\-l}ey},
  year = {1973},
  author = {D. E. Knuth},
  volume = {3},
  pages = {xi + 723},
  acknowledgement = {Nelson H. F. Beebe, University of Utah, Department of Mathematics,
	110 LCB, 155 S 1400 E RM 233, Salt Lake City, UT 84112-0090, USA,
	Tel: +1 801 581 5254, FAX: +1 801 581 4148, e-mail: \path|beebe@math.utah.edu|,
	\path|beebe@acm.org|, \path|beebe@computer.org| (Internet), URL:
	\path|http://www.math.utah.edu/~beebe/|},
  annote = {Standardwerk ueber Suchen und Sortieren 5. Sorting 5.1. Combinatorial
	Properties of Permutations 5.2. Internal Sorting 5.3. Optimum Sorting
	5.4. External Sorting 5.5. Summary, History, and Bibliography 6.
	Searching 6.1. Sequential Search 6.2. Searching By Comparison of
	Keys 6.3. Digital Searching 6.4. Hashing 6.5. Retrieval on Secondary
	Keys Answers to Exercises Appendix A: Tables of Numerical Quantities
	Appendix B: Index to Notations Index and Glossary.},
  annote-2 = {A basic source for computational algorithms such as hashing (pp.506--568),
	search tree construction(pp.406--505), and some notes on disk performance
	evaluation (pp.361--371).},
  bibdate = {Wed Dec 15 15:47:47 1993},
  descriptor = {Algorithmus, B-baum, Baum, Binaer-baum, Gestreute Speicherung, Hash-verfahren,
	Mischen, Sortieren, Speicherung, Suchen, Zugriff},
  isbn = {0-201-03803-X},
  isbn-13 = {978-0-201-03803-3},
  lccn = {QA76.5 .K74},
  owner = {Mathias Payer},
  timestamp = {2009.05.26}
}

@INPROCEEDINGS{ko02sp,
  author = {Ko, Calvin and Redmond, Timothy},
  title = {Noninterference and Intrusion Detection},
  booktitle = {S\&P'02: Proc. 2002 IEEE Symposium on Security and Privacy},
  year = {2002},
  pages = {177--187},
  abstract = {This paper presents an intrusion detection methodology based on the
	concept of noninterference for detecting race-condition attacks.
	In general, this type of attack occurs when an unprivileged process
	causes a privileged process to perform illegal operations by executing
	strategic operations in the appropriate timing window. We apply the
	noninterference model in a novel way that allows us to formally represent
	valid interleaving between privileged and unprivileged processes.
	Instead of proving a system satisfies noninterference assertions,
	we derive an algorithm for checking the assertions at run-time based
	on the developed theory and a formal model of Unix system calls.
	Our methodology can detect unknown race-condition attacks. In addition,
	this work provides an example of the application of formal specification
	and reasoning in intrusion detection.},
  acmid = {830541},
  isbn = {0-7695-1543-6},
  owner = {Mathias Payer},
  timestamp = {2011.05.09},
  url = {http://portal.acm.org/citation.cfm?id=829514.830541}
}

@MISC{asmjit,
  author = {Petr Kobalicek},
  title = {asmjit - Complete {x86/x64} {JIT} Assembler for C++ Language},
  howpublished = {\url{http://code.google.com/p/asmjit/}},
  month = {Dec.},
  year = {2011},
  owner = {Mathias Payer},
  timestamp = {2011.12.16}
}

@INPROCEEDINGS{koes06globregallocation,
  author = {Koes, David Ryan and Goldstein, Seth Copen},
  title = {A global progressive register allocator},
  booktitle = {PLDI '06},
  year = {2006},
  pages = {204--215},
  publisher = {ACM},
  abstract = {This paper describes a global progressive register allocator, a register
	allocator that uses an expressive model of the register allocation
	problem to quickly find a good allocation and then progressively
	find better allocations until a provably optimal solution is found
	or a preset time limit is reached. The key contributions of this
	paper are an expressive model of global register allocation based
	on multicommodity network flows that explicitly represents spill
	code optimization, register preferences, copy insertion, and constant
	rematerialization; two fast, but effective, heuristic allocators
	based on this model; and a more elaborate progressive allocator that
	uses Lagrangian relaxation to compute the optimality of its allocations.
	Our progressive allocator demonstrates code size improvements as
	large as 16.75% compared to a traditional graph allocator. On average,
	we observe an initial improvement of 3.47%, which increases progressively
	to 6.84% as more time is permitted for compilation.},
  doi = {http://doi.acm.org/10.1145/1133981.1134006},
  isbn = {1-59593-320-4},
  location = {Ottawa, Ontario, Canada},
  owner = {Mathias Payer},
  review = {- Extension to gcc 3.4

	- Max Flow/Min Cut -> Global Register Allocation based on flow algorithms

	 -> Minimize spill code},
  timestamp = {2009.05.31}
}

@ARTICLE{clamav,
  author = {Tomasz Kojm},
  title = {Clam AntiVirus ({ClamAV)}},
  year = {2012},
  pages = {\url{http://clamav.net}},
  owner = {Mathias Payer},
  timestamp = {2011.07.05}
}

@ARTICLE{koufaty:intelSMT,
  author = {David Koufaty and Deborah T. Marr},
  title = {Hyperthreading Technology in the Netburst Microarchitecture},
  journal = {IEEE Micro},
  year = {2003},
  volume = {23},
  pages = {56--65},
  number = {2},
  doi = {http://dx.doi.org/10.1109/MM.2003.1196115},
  issn = {0272-1732}
}

@INPROCEEDINGS{kulkarni09parallelism,
  author = {Kulkarni, Milind and Burtscher, Martin and Inkulu, Rajeshkar and
	Pingali, Keshav and Cas\c{c}aval, Calin},
  title = {How much parallelism is there in irregular applications?},
  booktitle = {PPoPP '09},
  year = {2009},
  pages = {3--14},
  publisher = {ACM},
  abstract = {Irregular programs are programs organized around pointer-based data
	structures such as trees and graphs. Recent investigations by the
	Galois project have shown that many irregular programs have a generalized
	form of data-parallelism called amorphous data-parallelism. However,
	in many programs, amorphous data-parallelism cannot be uncovered
	using static techniques, and its exploitation requires runtime strategies
	such as optimistic parallel execution. This raises a natural question:
	how much amorphous data-parallelism actually exists in irregular
	programs?


	In this paper, we describe the design and implementation of a tool
	called ParaMeter that produces parallelism profiles for irregular
	programs. Parallelism profiles are an abstract measure of the amount
	of amorphous data-parallelism at different points in the execution
	of an algorithm, independent of implementation-dependent details
	such as the number of cores, cache sizes, load-balancing, etc. ParaMeter
	can also generate constrained parallelism profiles for a fixed number
	of cores. We show parallelism profiles for seven irregular applications,
	and explain how these profiles provide insight into the behavior
	of these applications.},
  doi = {http://doi.acm.org/10.1145/1504176.1504181},
  isbn = {978-1-60558-397-6},
  keywords = {TM, STM},
  location = {Raleigh, NC, USA},
  owner = {Mathias Payer},
  review = {graph based computation -> predict parallelism},
  timestamp = {2009.05.31}
}

@MISC{flexinstr,
  author = {Naveen Kumar and Bruce Childers},
  title = {Flexible Instrumentation for Software Dynamic Translation},
  owner = {Mathias Payer},
  review = {Strata for dynamic BT used for flexible instrumentation},
  timestamp = {2010.01.04}
}

@INPROCEEDINGS{kumar:multicorePower,
  author = {Rakesh Kumar and Keith I. Farkas and Norman P. Jouppi and Parthasarathy
	Ranganathan and Dean M. Tullsen},
  title = {Single-ISA Heterogeneous Multi-Core Architectures: The Potential
	for Processor Power Reduction},
  booktitle = {MICRO 36: Proceedings of the 36th annual IEEE/ACM International Symposium
	on Microarchitecture},
  year = {2003},
  pages = {81},
  isbn = {0-7695-2043-X}
}

@INPROCEEDINGS{lamrothberg91,
  author = {M. S. Lam and E. E. Rothberg and M. E. Wolf},
  title = {The cache performance and optimizations of block algorithms},
  booktitle = {4th International Conference on Architectural Support for Programming
	Languages and Operating Systems},
  year = {1991},
  pages = {63--74},
  month = apr
}

@ARTICLE{landi93interprocedural,
  author = {William Landi and Barbara G. Ryder and Sean Zhang},
  title = {Interprocedural modification side effect analysis with pointer aliasing},
  journal = {ACM SIG{\-}PLAN Notices},
  year = {1993},
  volume = {28},
  pages = {56--67},
  number = {6},
  isbn = {0-89791-598-4},
  url = {citeseer.nj.nec.com/article/landi93interprocedural.html}
}

@ARTICLE{larus08transactionalmemory,
  author = {James R. Larus and Christos Kozyrakis},
  title = {Transactional memory},
  journal = {Commun. ACM},
  year = {2008},
  volume = {51},
  pages = {80-88},
  number = {7},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://doi.acm.org/10.1145/1364782.1364800},
  owner = {Mathias Payer},
  review = {Review article about STM, conservative

	is tm the answer for improving parallel programming?


	print -> 1},
  timestamp = {2008.08.10}
}

@BOOK{larus:tmbook:mcp:2006,
  title = {Transactional Memory},
  publisher = {Morgan \& Claypool},
  year = {2006},
  author = {Larus, James R. and Rajwar, Ravi},
  owner = {Mathias Payer},
  timestamp = {2009.07.09},
  urlpage = {http://www.morganclaypool.com/doi/abs/10.2200/S00070ED1V01Y200611CAC002}
}

@INPROCEEDINGS{lattner04cgo,
  author = {Chris Lattner and Vikram Adve},
  title = {{LLVM}: A Compilation Framework for Lifelong Program Analysis \&
	Transformation},
  booktitle = {CGO'04: Proc. 2004 Int. Symp. Code Generation and Optimization},
  year = {2004},
  abstract = {This paper describes LLVM (Low Level Virtual Machine), a compiler
	framework designed to support transparent, lifelong program analysis
	and transformation for arbitrary programs, by providing high-level
	information to compiler transformations at compile-time, link-time,
	run-time, and in idle time between runs. LLVM defines a common, low-level
	code representation in Static Single Assignment (SSA) form, with
	several novel features: a simple, language-independent type-system
	that exposes the primitives commonly used to implement high-level
	language features; an instruction for typed address arithmetic; and
	a simple mechanism that can be used to implement the exception handling
	features of high-level languages (and setjmp/longjmp in C) uniformly
	and efficiently. The LLVM compiler framework and code representation
	together provide a combination of key capabilities that are important
	for practical, lifelong analysis and transformation of programs.
	To our knowledge, no existing compilation approach provides all these
	capabilities. We describe the design of the LLVM representation and
	compiler framework, and evaluate the design in three ways: (a) the
	size and effectiveness of the representation, including the type
	information it provides; (b) compiler performance for several interprocedural
	problems; and (c) illustrative examples of the benefits LLVM provides
	for several challenging compiler problems.},
  owner = {Mathias Payer},
  timestamp = {2012.04.18}
}

@ARTICLE{lau10cv,
  author = {Boris Lau and Vanja Svajcer},
  title = {Measuring virtual machine detection in malware using DSD tracer},
  journal = {Journal in Computer Virology},
  year = {2010},
  pages = {181-195},
  owner = {Mathias Payer},
  review = {Anti-tracing},
  timestamp = {2012.04.26}
}

@INPROCEEDINGS{PERF-AUDIT-PLDI06,
  author = {Jeremy Lau and Matthew Arnold and Michael Hind and Brad Calder},
  title = {Online performance auditing: using hot optimizations without getting
	burned},
  booktitle = {Proceedings of the 2006 ACM SIGPLAN conference on Programming Language
	Design and Implementation (PLDI~2006)},
  year = {2006},
  pages = {239--251},
  doi = {http://doi.acm.org/10.1145/1133981.1134010},
  isbn = {1-59593-320-4},
  location = {Ottawa, Ontario, Canada}
}

@ARTICLE{lee06problemthreads,
  author = {Edward A. Lee},
  title = {The Problem with Threads},
  journal = {Computer},
  year = {2006},
  volume = {39},
  pages = {33--42},
  number = {5},
  abstract = {For concurrent programming to become mainstream, we must discard threads
	as a programming model. Nondeterminism should be judiciously and
	carefully introduced where needed, and it should be explicit in programs.},
  doi = {http://dx.doi.org/10.1109/MC.2006.180},
  issn = {0018-9162},
  owner = {Mathias Payer},
  review = {statement: threads are the wrong programming paradigm


	threads introduce too much nondeterminism and are therefore uncontrollable!


	print -> 1},
  timestamp = {2008.08.10}
}

@ARTICLE{lt79dominators,
  author = {T. Lengauer and Robert Tarjan},
  title = {A fast algorithm for finding dominators in a flowgraph},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {1979},
  volume = {1},
  pages = {121--141},
  number = {1},
  month = {July}
}

@ARTICLE{lhee05races,
  author = {Kyung-suk Lhee and Steve J. Chapin},
  title = {Detection of file-based race conditions},
  journal = {Int'l Journal Information Security},
  year = {2005},
  volume = {4},
  pages = {105-119},
  number = {1-2},
  abstract = {Multiprocessing environments such as Unix are susceptible to race
	conditions on the le space, since processes share les in the system.
	A process accessing a file may get unexpected results while executing
	in a critical section, if the binding between the file name and
	the file object is altered by another process. Such errors, called
	Time-of-check-to-time-of-use (TOCTTOU) binding flaws, are among the
	most prevalent security flaws. This paper presents a model that detects
	TOCTTOU binding flaws by checking the integrity of bindings betweenfile
	names and le objects at run time, and a simplied prototype of the
	detection model. We discuss the properties of the detection model
	and its run-time overhead, based on the results of experiments on
	the prototype.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://dx.doi.org/10.1007/s10207-004-0068-2},
  owner = {Mathias Payer},
  review = {Assumes predefined critical sections, works on interception of libc
	functions},
  timestamp = {2011.05.09}
}

@ARTICLE{alcatraz09,
  author = {Liang, Zhenkai and Sun, Weiqing and Venkatakrishnan, V. N. and Sekar,
	R.},
  title = {Alcatraz: An Isolated Environment for Experimenting with Untrusted
	Software},
  journal = {ACM Trans. Inf. Syst. Secur.},
  year = {2009},
  volume = {12},
  pages = {1--37},
  number = {3},
  abstract = {In this article, we present an approach for realizing a safe execution
	environment (SEE) that enables users to âtry outâ new software (or
	configuration changes to existing software) without the fear of damaging
	the system in any manner. A key property of our SEE is that it faithfully
	reproduces the behavior of applications, as if they were running
	natively on the underlying (host) operating system. This is accomplished
	via one-way isolation: processes running within the SEE are given
	read-access to the environment provided by the host OS, but their
	write operations are prevented from escaping outside the SEE. As
	a result, SEE processes cannot impact the behavior of host OS processes,
	or the integrity of data on the host OS. SEEs support a wide range
	of tasks, including: study of malicious code, controlled execution
	of untrusted software, experimentation with software configuration
	changes, testing of software patches, and so on. It provides a convenient
	way for users to inspect system changes made within the SEE. If these
	changes are not accepted, they can be rolled back at the click of
	a button. Otherwise, the changes can be committed so as to become
	visible outside the SEE. We provide consistency criteria that ensure
	semantic consistency of the committed results. We develop two different
	implementation approaches, one in user-land and the other in the
	OS kernel, for realizing a safe-execution environment. Our implementation
	results show that most software, including fairly complex server
	and client applications, can run successfully within our SEEs. It
	introduces low performance overheads, typically below 10 percent.},
  doi = {http://doi.acm.org/10.1145/1455526.1455527},
  issn = {1094-9224},
  owner = {Mathias Payer},
  publisher = {ACM},
  review = {Encapsulate I/O (disk & net), redirect all writes to buffer

	-> ptrace / user-space implementation (fork races)

	-> kernel (VFS) implementation

	=> commit only for disk, not for network access


	static redirection:

	host h -> h'

	port p -> p'


	dynamic redirection for files


	DNS allowed (covert channel)


	high overhead (100%) for ptrace, 10% for kernel},
  timestamp = {2010.09.08}
}

@INPROCEEDINGS{lindorfer11raid,
  author = {Lindorfer, Martina and Kolbitsch, Clemens and Milani Comparetti,
	Paolo},
  title = {{Detecting Environment-Sensitive Malware}},
  booktitle = {Recent Advances in Intrusion Detection (RAID) Symposium},
  year = {2011},
  owner = {Mathias Payer},
  timestamp = {2012.04.26}
}

@ARTICLE{lo98register,
  author = {Raymond Lo and Fred Chow and Robert Kennedy and Shin-Ming Liu and
	Peng Tu},
  title = {Register promotion by sparse partial redundancy elimination of loads
	and stores},
  journal = {ACM SIG{\-}PLAN Notices},
  year = {1998},
  volume = {33},
  pages = {26--37},
  number = {5},
  isbn = {0-89791-987-4},
  url = {citeseer.nj.nec.com/lo98register.html}
}

@PROCEEDINGS{lobosco03cojvm,
  title = {A New Distributed JVM for Cluster Computing},
  year = {2003},
  abstract = {Abstract. In this work, we introduce CoJVM, a new distributed Java
	run-time system that enables concurrent Java programs to efficiently
	execute on clusters of personal computers or workstations. CoJVM
	implements Javaâs shared memory model by enabling multiple standard
	JVMs to work cooperatively and transparently to support a single
	distributed shared-memory across the clusterâs nodes. CoJVM requires
	no change to applications written in standard Java. Our experimental
	results using several Java benchmarks show that CoJVM performance
	is considerable with speed-ups ranging from 6.1 to 7.8 for an 8-node
	cluster. 1},
  author = {Marcelo Lobosco and Claudio L. De Amorim},
  owner = {Mathias Payer},
  review = {- MicroBenchmarks, external DSM, all objects in shared heap

	+(H)LRC

	- First touch -> processor that first writes to page is owner throughout
	execution

	- 1 thread/ jvm

	- no implementation details

	vapor??


	print -> 1},
  timestamp = {2008.08.10}
}

@MISC{lasci-workshop,
  author = {{Lubeck, O. et al.}},
  title = {{WS6: Hardware Performance Monitor Design and Functionality, Los
	Alamos Computer Science Institute Symposium 2005}},
  howpublished = {Web archive http://lacsi.rice.edu/workshops/hpca11, Feb 12-16 2005,
	San Francisco},
  year = {2005},
  key = {Lubeck, O. et al. 2005}
}

@INPROCEEDINGS{luk05pldi,
  author = {Chi-Keung Luk and Robert Cohn and Robert Muth and Harish Patil and
	Artur Klauser and Geoff Lowney and Steven Wallace and Vijay Janapa
	Reddi and Kim Hazelwood},
  title = {Pin: building customized program analysis tools with dynamic instrumentation},
  booktitle = {PLDI'05},
  abstract = {Robust and powerful software instrumentation tools are essential for
	program analysis tasks such as profiling, performance evaluation,
	and bug detection. To meet this need, we have developed a new instrumentation
	system called Pin. Our goals are to provide easy-to-use, portable,
	transparent, and efficient instrumentation. Instrumentation tools
	(called Pintools) are written in C/C++ using Pin's rich API. Pin
	follows the model of ATOM, allowing the tool writer to analyze an
	application at the instruction level without the need for detailed
	knowledge of the underlying instruction set. The API is designed
	to be architecture independent whenever possible, making Pintools
	source compatible across different architectures. However, a Pintool
	can access architecture-specific details when necessary. Instrumentation
	with Pin is mostly transparent as the application and Pintool observe
	the application's original, uninstrumented behavior. Pin uses dynamic
	compilation to instrument executables while they are running. For
	efficiency, Pin uses several techniques, including inlining, register
	re-allocation, liveness analysis, and instruction scheduling to optimize
	instrumentation. This fully automated approach delivers significantly
	better instrumentation performance than similar tools. For example,
	Pin is 3.3x faster than Valgrind and 2x faster than DynamoRIO for
	basic-block counting. To illustrate Pin's versatility, we describe
	two Pintools in daily use to analyze production software. Pin is
	publicly available for Linux platforms on four architectures: IA32
	(32-bit x86), EM64T (64-bit x86), ItaniumÂ®, and ARM. In the ten months
	since Pin 2 was released in July 2004, there have been over 3000
	downloads from its website.},
  doi = {http://doi.acm.org/10.1145/1065010.1065034},
  isbn = {1-59593-056-6},
  location = {Chicago, IL, USA},
  owner = {Mathias Payer},
  timestamp = {2008.07.23}
}

@INPROCEEDINGS{makris09upstare,
  author = {Makris, Kristis and Bazzi, Rida A.},
  title = {Immediate multi-threaded dynamic software updates using stack reconstruction},
  booktitle = {Usenix ATC'09},
  abstract = {We propose a new approach for dynamic software updates. This approach
	allows updating applications that until now could not be updated
	at runtime at all or could be updated but with a possibly indefinite
	delay between the time an update is initiated and the time the update
	is effected (during this period no service is provided). Unlike existing
	approaches, we allow arbitrary changes to functions active on the
	stack and without requiring the programmer to anticipate the future
	evolution of a program. We argue, using actual examples, that this
	capability is needed to dynamically update common real applications.


	At the heart of our approach is a stack reconstruction technique that
	allows all functions on the call stack to be updated at the same
	time to guarantee that all active functions have the same version
	after an update. This is the first general approach that maintains
	both code and data representation consistency for multi-threaded
	applications. Our system UpStare was used to update the PostgreSQL
	database management system (more than 200,000 lines of code) and
	apply 5.5 years-worth of updates to the very secure FTP server vsFTPd
	(about 12,000 lines of code).},
  acmid = {1855838},
  numpages = {1},
  owner = {Mathias Payer},
  timestamp = {2012.01.27},
  url = {http://dl.acm.org/citation.cfm?id=1855807.1855838}
}

@INPROCEEDINGS{astm05,
  author = {Virendra J. Marathe and William N. Scherer Iii and Michael L. Scott},
  title = {Adaptive Software Transactional Memory},
  booktitle = {DISC'05},
  year = {2005},
  pages = {354--368},
  abstract = {Software Transactional Memory (STM) is a generic synchronization construct
	that enables automatic conversion of correct sequential objects into
	correct nonblocking concurrent objects. Recent STM systems, though
	significantly more practical than their predecessors, display inconsistent
	performance: differing design decisions cause different systems to
	perform best in different circumstances, often by dramatic margins.
	In this paper we consider four dimensions of the STM design space:
	(i) when concurrent objects are acquired by transactions for modification;
	(ii) how they are acquired; (iii) what they look like when not acquired;
	and (iv) the non-blocking semantics for transactions (lock-freedom
	vs. obstruction-freedom). In this 4-dimensional space we highlight
	the locations of two leading STM systems: the DSTM of Herlihy et
	al. and the OSTM of Fraser and Harris. Drawing motivation from the
	performance of a series of application benchmarks, we then present
	a new Adaptive STM (ASTM) system that adjusts to the offered workload,
	allowing it to match the performance of the best known existing system
	on every tested workload.},
  keywords = {STM, TM, ASTM,},
  owner = {Mathias Payer},
  review = {extension of DSTM called ASTM


	adapts between

	- lazy and eager lock acquire

	- direct or indirect object references (tm metadata)},
  timestamp = {2010.01.12}
}

@TECHREPORT{marathe:stm-survey:urcs-tr:2004,
  author = {Marathe, Virendra J. and Scott, Michael L.},
  title = {A Qualitative Survey of Modern Software Transactional Memory Systems},
  institution = {University of Rochester Computer Science Dept.},
  year = {2004},
  number = {TR 839},
  month = {Jun},
  file = {2004_TR839.pdf:http\://www.cs.rochester.edu/u/scott/papers/2004_TR839.pdf:PDF},
  keywords = {3 stms compared, word based, object based, STM, TM},
  owner = {Mathias Payer},
  review = {Compares 3 STMs


	Word based (hash table)

	Object based

	- DSTM -> Obj(Trans,Old,New)

	- FSTM -> Header(Obj)},
  timestamp = {2007.10.05}
}

@INPROCEEDINGS{may87system370,
  author = {C. May},
  title = {Mimic: a fast {System/370} simulator},
  booktitle = {SIGPLAN '87: Papers of the Symposium on Interpreters and
                  interpretive techniques},
  year = {1987},
  pages = {1--13},
  doi = {http://doi.acm.org/10.1145/29650.29651},
  isbn = {0-89791-235-7},
  location = {St. Paul, Minnesota, United States},
  owner = {Mathias Payer},
  timestamp = {2008.07.30}
}

@INPROCEEDINGS{mazieres97hotos,
  author = {David Mazi{\`e}res and M. Frans Kaashoek},
  title = {Secure Applications Need Flexible Operating Systems},
  booktitle = {HotOS'07: Workshop on Hot Topics in Operating Systems},
  year = {1997},
  pages = {56-61}
}

@INPROCEEDINGS{sficisc06,
  author = {Stephen McCamant and Greg Morrisett},
  title = {Evaluating {SFI} for a {CISC} Architecture},
  booktitle = {SSYM'06},
  abstract = {Executing untrusted code while preserving security requires that the
	code be prevented from modifying memory or executing code except
	as explicitly allowed. Software-based fault isolation (SFI) or âsandboxingâ
	enforces such a policy by rewriting the untrusted code at the instruction
	level. However, the original sandboxing technique of Wahbe et al.
	is applicable only to RISC architectures, and most other previous
	work is either insecure, or has been not described in enough detail
	to give confidence in its security properties. We present a new sandboxing
	technique that can be applied to a CISC architecture like the IA-32,
	and whose application can be checked at load-time to minimize the
	TCB. We describe an implementation which provides a robust security
	guarantee and has low runtime overheads (an average of 21% on the
	SPECint2000 benchmarks). We evaluate the utility of the technique
	by applying it to untrusted decompression modules in an archive tool,
	and its safety by constructing a machine-checked proof that any program
	approved by the verification algorithm will respect the desired safety
	property.},
  file = {pittsfield-usenix2006.pdf:http\://people.csail.mit.edu/smcc/projects/pittsfield/pubs/usenix-sec-2006/pittsfield-usenix2006.pdf:PDF},
  owner = {Mathias Payer},
  review = {Static checking and translation, but 21% overhead

	-> no syscall validation

	-> subset of instructions proved (no exploit possible)

	-> good related work},
  timestamp = {2009.10.20}
}

@INBOOK{McConnell2004bugs,
  chapter = {19. General Control Issues},
  pages = {30},
  title = {Code Complete, Second Edition},
  publisher = {Microsoft Press},
  year = {2004},
  author = {Steve McConnell},
  address = {Redmond, WA, USA},
  abstract = {<table style="margin-left: 18px"><div class="abstract">Take a strategic
	approach to software construction-and produce superior products-with
	this fully updated edition of Steve McConnell's critically praised
	and award-winning guide to software development best practices.},
  added-at = {2009-10-05T13:43:07.000+0200},
  biburl = {http://www.bibsonomy.org/bibtex/2fa928f6b009b463af0141b4cbd7d9c9b/fsteeg},
  description = {Code Complete, Second Edition},
  interhash = {fe6d817ee9cfa35671bd5bb695ba7726},
  intrahash = {fa928f6b009b463af0141b4cbd7d9c9b},
  isbn = {0735619670},
  keywords = {programming},
  owner = {gannimo},
  review = {Control-flow complexity is important because it has been correlated
	with low

	reliability and frequent errors (McCabe 1976, Shen et al. 1985). William
	T.

	Ward reported a significant gain in software reliability resulting
	from using

	McCabeâs complexity metric at Hewlett-Packard (1989b). McCabeâs metric
	was

	 used on one 77,000-line program to identify problem areas. The program
	had a

	 post-release defect rate of 0.31 defects per thousand lines of code.
	A 125,000-

	 line program had a post-release defect rate of 0.02 defects per thousand
	lines of

	code. Ward reported that because of their lower complexity both programs
	had

	substantially fewer defects than other programs at Hewlett-Packard.
	My own

	company, Construx Software, has experienced similar results using
	complexity

	measures to identify problematic routines in the 2000s.},
  timestamp = {2011.06.13},
  url = {http://portal.acm.org/citation.cfm?id=1096143}
}

@ARTICLE{mernik05acs,
  author = {Mernik, Marjan and Heering, Jan and Sloane, Anthony M.},
  title = {When and how to develop domain-specific languages},
  journal = {ACM Comput. Surv.},
  year = {2005},
  volume = {37},
  pages = {316--344},
  month = {Dec.},
  abstract = {Domain-specific languages (DSLs) are languages tailored to a specific
	application domain. They offer substantial gains in expressiveness
	and ease of use compared with general-purpose programming languages
	in their domain of application. DSL development is hard, requiring
	both domain knowledge and language development expertise. Few people
	have both. Not surprisingly, the decision to develop a DSL is often
	postponed indefinitely, if considered at all, and most DSLs never
	get beyond the application library stage.Although many articles have
	been written on the development of particular DSLs, there is very
	limited literature on DSL development methodologies and many questions
	remain regarding when and how to develop a DSL. To aid the DSL developer,
	we identify patterns in the decision, analysis, design, and implementation
	phases of DSL development. Our patterns improve and extend earlier
	work on DSL design patterns. We also discuss domain analysis tools
	and language development systems that may help to speed up DSL development.
	Finally, we present a number of open problems. },
  acmid = {1118892},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1118890.1118892},
  issn = {0360-0300},
  issue = {4},
  keywords = {Domain-specific language, application language, domain analysis, language
	development system},
  numpages = {29},
  publisher = {ACM},
  url = {http://doi.acm.org/10.1145/1118890.1118892}
}

@INPROCEEDINGS{morrisett99talx86,
  author = {Greg Morrisett and Karl Crary and Neal Glew and Dan Grossman and
	Richard Samuels and Frederick Smith and David Walker and Stephanie
	Weirich and Steve Zdancewic},
  title = {TALx86: A Realistic Typed Assembly Language},
  booktitle = {2nd Workshop on Compiler Support for System Software},
  year = {1999},
  pages = {25--35}
}

@INPROCEEDINGS{SOFTWARE-PREFETCH,
  author = {Todd C. Mowry and Monica S. Lam and Anoop Gupta},
  title = {Design and evaluation of a compiler algorithm for prefetching},
  booktitle = {ASPLOS'92},
  year = {1992},
  pages = {62--73},
  doi = {http://doi.acm.org/10.1145/143365.143488},
  isbn = {0-89791-534-8},
  location = {Boston, Massachusetts, United States}
}

@ARTICLE{myers86diff,
  author = {Eugene W. Myers},
  title = {An O(ND) Difference Algorithm and Its Variations},
  journal = {Algorithmica},
  year = {1986},
  volume = {1},
  pages = {251--266}
}

@INPROCEEDINGS{neamtiu09pldi,
  author = {Neamtiu, Iulian and Hicks, Michael},
  title = {Safe and timely updates to multi-threaded programs},
  booktitle = {PLDI'09},
  abstract = {Many dynamic updating systems have been developed that enable a program
	to be patched while it runs, to fix bugs or add new features. This
	paper explores techniques for supporting dynamic updates to multi-threaded
	programs, focusing on the problem of applying an update in a timely
	fashion while still producing correct behavior. Past work has shown
	that this tension of safety versus timeliness can be balanced for
	single-threaded programs. For multi-threaded programs, the task is
	more difficult because myriad thread interactions complicate understanding
	the possible program states to which a patch could be applied. Our
	approach allows the programmer to specify a few program points (e.g.,
	one per thread) at which a patch may be applied, which simplifies
	reasoning about safety. To improve timeliness, a combination of static
	analysis and run-time support automatically expands these few points
	to many more that produce behavior equivalent to the originals. Experiments
	with thirteen realistic updates to three multi-threaded servers show
	that we can safely perform a dynamic update within milliseconds when
	more straightforward alternatives would delay some updates indefinitely.},
  acmid = {1542479},
  doi = {http://doi.acm.org/10.1145/1542476.1542479},
  isbn = {978-1-60558-392-1},
  keywords = {dynamic software updating, multi-threading, update safety, update
	timeliness},
  location = {Dublin, Ireland},
  numpages = {12},
  url = {http://doi.acm.org/10.1145/1542476.1542479}
}

@INPROCEEDINGS{neamtiu06pldi,
  author = {Neamtiu, Iulian and Hicks, Michael and Stoyle, Gareth and Oriol,
	Manuel},
  title = {Practical dynamic software updating for C},
  booktitle = {PLDIâ°6},
  doi = {http://doi.acm.org/10.1145/1133981.1133991},
  isbn = {1-59593-320-4},
  keywords = {dynamic software updating, function indirection, loop extraction,
	type wrapping},
  numpages = {12},
  url = {http://doi.acm.org/10.1145/1133981.1133991}
}

@INPROCEEDINGS{necula2005ccured,
  author = {Necula, G.C. and Condit, J. and Harren, M. and McPeak, S. and Weimer,
	W.},
  title = {{CCured: Type-safe retrofitting of legacy software}},
  year = {2005},
  volume = {27},
  number = {3},
  pages = {477--526},
  publisher = {ACM},
  abstract = {This article describes CCured, a program transformation system that
	adds type safety guarantees to existing C programs. CCured attempts
	to verify statically that memory errors cannot occur, and it inserts
	run-time checks where static verification is insufficient.CCured
	extends C's type system by separating pointer types according to
	their usage, and it uses a surprisingly simple type inference algorithm
	that is able to infer the appropriate pointer kinds for existing
	C programs. CCured uses physical subtyping to recognize and verify
	a large number of type casts at compile time. Additional type casts
	are verified using run-time type information. CCured uses two instrumentation
	schemes, one that is optimized for performance and one in which metadata
	is stored in a separate data structure whose shape mirrors that of
	the original user data. This latter scheme allows instrumented programs
	to invoke external functions directly on the program's data without
	the use of a wrapper function.We have used CCured on real-world security-critical
	network daemons to produce instrumented versions without memory-safety
	vulnerabilities, and we have found several bugs in these programs.
	The instrumented code is efficient enough to be used in day-to-day
	operations.},
  issn = {0164-0925},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  owner = {Mathias Payer},
  review = {Mem type system with type inference, static verification and dynamic
	runtime checks

	2 runtime modes, speed and add. metadata


	Pointer types:

	SAFE = nullcheck, static

	SEQ = boundchek, static

	WILD = boundcheck and dynamic type check (casted, used in casts)},
  timestamp = {2011.02.03}
}

@INPROCEEDINGS{necula02cil,
  author = {Necula, George C. and McPeak, Scott and Rahul, Shree Prakash and
	Weimer, Westley},
  title = {CIL: Intermediate Language and Tools for Analysis and Transformation
	of C Programs},
  booktitle = {CC'02},
  isbn = {3-540-43369-4},
  numpages = {16},
  url = {http://dl.acm.org/citation.cfm?id=647478.727796}
}

@ARTICLE{nergal07ret2libc,
  author = {Nergal},
  title = {The advanced return-into-lib(c) exploits},
  journal = {Phrack},
  year = {2007},
  volume = {11},
  pages = {\url{http://phrack.com/issues.html?issue=67&id=8}},
  number = {58},
  month = nov,
  chapter = {4},
  keywords = {buffer-overflow, c, security, software, vulnerability},
  owner = {Mathias Payer},
  review = {This article can be roughly divided into two parts. First, the advanced
	return-into-lib(c) techniques are described. Some of the presented
	ideas, or rather similar ones, have already been published by others.
	However, the available pieces of information are dispersed, usually
	platform-specific, somewhat limited, and the accompanying source
	code is not instructive enough (or at all). Therefore I have decided
	to assemble the available bits and a few of my thoughts into a single
	document, which should be useful as a convenient reference. Judging
	by the contents of many posts on security lists, the presented information
	is by no means the common knowledge.

	 The second part is devoted to methods of bypassing PaX in case of
	stack buffer overflow (other types of vulnerabilities are discussed
	at the end). The recent PaX improvements, namely randomization of
	addresses the stack and the libraries are mmapped at, pose an untrivial
	challenge for an exploit coder. An original technique of calling
	directly the dynamic linker's symbol resolution procedure is presented.
	This method is very generic and the conditions required for successful
	exploitation are usually satisfied.},
  url = {http://www.phrack.org/issues.html?issue=58\&id=4}
}

@INPROCEEDINGS{nethercote08valgrind,
  author = {Nicholas Nethercote and Julian Seward},
  title = {Valgrind: a framework for heavyweight dynamic binary instrumentation},
  booktitle = {PLDI'07},
  abstract = {Dynamic binary instrumentation (DBI) frameworks make it easy to build
	dynamic binary analysis (DBA) tools such as checkers and profilers.
	Much of the focus on DBI frameworks has been on performance; little
	attention has been paid to their capabilities. As a result, we believe
	the potential of DBI has not been fully exploited.


	In this paper we describe Valgrind, a DBI framework designed for building
	heavyweight DBA tools. We focus on its unique support for shadow
	values-a powerful but previously little-studied and difficult-to-implement
	DBA technique, which requires a tool to shadow every register and
	memory value with another value that describes it. This support accounts
	for several crucial design features that distinguish Valgrind from
	other DBI frameworks. Because of these features, lightweight tools
	built with Valgrind run comparatively slowly, but Valgrind can be
	used to build more interesting, heavyweight tools that are difficult
	or impossible to build with other DBI frameworks such as Pin and
	DynamoRIO.},
  doi = {http://doi.acm.org/10.1145/1250734.1250746},
  isbn = {978-1-59593-633-2},
  location = {San Diego, California, USA},
  owner = {Mathias Payer},
  timestamp = {2008.07.23}
}

@INPROCEEDINGS{ni07,
  author = {Ni, Yang and Menon, Vijay S. and Adl-Tabatabai, Ali-Reza and Hosking,
	Antony L. and Hudson, Richard L. and Moss, J. Eliot B. and Saha,
	Bratin and Shpeisman, Tatiana},
  title = {Open nesting in software transactional memory},
  booktitle = {PPoPP '07},
  year = {2007},
  pages = {68--78},
  publisher = {ACM},
  abstract = {Transactional memory (TM) promises to simplify concurrent programming
	while providing scalability competitive to fine-grained locking.
	Language-based constructs allow programmers to denote atomic regions
	declaratively and to rely on the underlying system to provide transactional
	guarantees along with concurrency. In contrast with fine-grained
	locking, TM allows programmers to write simpler programs that are
	composable and deadlock-free.


	TM implementations operate by tracking loads and stores to memory
	and by detecting concurrent conflicting accesses by different transactions.
	By automating this process, they greatly reduce the programmer's
	burden, but they also are forced to be conservative. Incertain cases,
	conflicting memory accesses may not actually violate the higher-level
	semantics of a program, and a programmer may wish to allow seemingly
	conflicting transactions to execute concurrently.


	Open nested transactions enable expert programmers to differentiate
	between physical conflicts, at the level of memory, and logical conflicts
	that actually violate application semantics. A TMsystem with open
	nesting can permit physical conflicts that are not logical conflicts,
	and thus increase concurrency among application threads.


	Here we present an implementation of open nested transactions in a
	Java-based software transactional memory (STM)system. We describe
	new language constructs to support open nesting in Java, and we discuss
	new abstract locking mechanisms that a programmer can use to prevent
	logical conflicts. We demonstrate how these constructs can be mapped
	efficiently to existing STM data structures. Finally, we evaluate
	our system on a set of Java applications and data structures, demonstrating
	how open nesting can enhance application scalability.},
  doi = {http://doi.acm.org/10.1145/1229428.1229442},
  isbn = {978-1-59593-602-8},
  keywords = {STM, TM, nesting, open nesting},
  location = {San Jose, California, USA},
  owner = {Mathias Payer},
  review = {STM system with nested TX (Java)

	open nested: inner tx commit & support compensation fcts. if parent
	fails or aborts},
  timestamp = {2010.09.27}
}

@INPROCEEDINGS{judostm,
  author = {Marek Olszewski and Jeremy Cutler and J. Gregory Steffan},
  title = {JudoSTM: A Dynamic Binary-Rewriting Approach to Software Transactional
	Memory},
  booktitle = {PACT '07},
  year = {2007},
  pages = {365--375},
  abstract = {With the advent of chip-multiprocessors, we are faced with the challenge
	of parallelizing performance-critical software. Transactional memory
	(TM) has emerged as a promising programming model allowing programmers
	to focus on parallelism rather than maintaining correctness and avoiding
	deadlock. Many implementations of hardware, software, and hybrid
	support for TM have been proposed; of these, software-only implementations
	(STMs) are especially compelling since they can be used with current
	commodity hardware. However, in addition to higher overheads, many
	existing STM systems are limited to either managed languages or intrusive
	APIs. Furthermore, transactions in STMs cannot normally contain calls
	to unobservable code such as shared libraries or system calls. In
	this paper we present JudoSTM, a novel dynamic binary-rewriting approach
	to implementing STM that supports C and C++ code. Furthermore, by
	using value-based conflict detection, JudoSTM additionally supports
	the transactional execution of both (i) irreversible system calls
	and (ii) library functions that may contain locks. We significantly
	lower overhead through several novel optimizations that improve the
	quality of rewritten code and reduce the cost of conflict detection
	and buffering. We show that our approach performs comparably to Rochester's
	RSTM library-based implementation--demonstrating that a dynamic binary-rewriting
	approach to implementing STM is an interesting alternative.},
  doi = {http://dx.doi.org/10.1109/PACT.2007.42},
  isbn = {0-7695-2944-5},
  keywords = {STM, TM, JudoSTM},
  review = {- optimized for short transactions

	- 1 privileged transaction that can execute syscalls (during this
	privileged txn, no other txn may commit)

	- detects local stack access -> no instrumentation for these operations

	- uses replacement for gnu malloc (gnu malloc does not scale!)}
}

@misc{CVE-2010-3847,
  author = {Tavis Ormandy},
  title = {{CVE-2010-3847}: {GNU} {C} library dynamic linker \${ORIGIN} expansion
	Vulnerability},
  year = {2010},
  howpublished = {\url{http://www.exploit-db.com/exploits/15274/}},
  owner = {gannimo},
  timestamp = {2011.06.12}
}

@misc{CVE-2010-3856,
  author = {Tavis Ormandy},
  title = {{CVE-2010-3856}: {GNU} {C} library dynamic linker {LD\_AUDIT} arbitrary
	{DSO} load Vulnerability},
  year = {2010},
  howpublished = {\url{http://www.exploit-db.com/exploits/15304/}},
  owner = {gannimo},
  timestamp = {2011.06.12}
}

@MISC{formatstring,
  author = {OWASP},
  title = {Definition of format string attacks},
  howpublished = {\url{https://www.owasp.org/index.php/Format_string_attack}},
  owner = {Mathias Payer},
  timestamp = {2011.11.21}
}

@INPROCEEDINGS{paleari09woot,
  author = {Roberto Paleari and Lorenzo Martignoni and Giampaolo Fresi and Roglia
	Danilo Bruschi},
  title = {A Fistful of Red-Pills: How to Automatically Generate Procedures
	to Detect {CPU} Emulators},
  booktitle = {WOOT'09: Proc. USENIX Workshop on Offensive Technologies},
  year = {2009},
  abstract = {Malware includes several protections to complicate their analysis:
	the longer it takes to analyze a new malware sample, the longer the
	sample survives and the larger number of systems it compromises.
	Nowadays, new malware samples are analyzed dynamically using virtual
	environments (e.g., emulators, virtual machines, or debuggers). Therefore,
	malware incorporate a variety of tests to detect whether they are
	executed through such environments and obfuscate their behavior if
	they suspect their execution is being monitored. Several simple tests,
	we indistinctly call red-pills, have already been proposed in literature
	to detect whether the execution of a program is performed in a real
	or in a virtual environment. In this paper we propose an automatic
	and systematic technique to generate red-pills, specific for detecting
	if a program is executed through a CPU emulator. Using this technique
	we generated thousands of new red-pills, involving hundreds of different
	opcodes, for two publicly available emulators, which are widely used
	for analyzing malware.},
  owner = {Mathias Payer},
  review = {generating red pills},
  timestamp = {2012.04.26}
}

@INPROCEEDINGS{park04pcm,
  author = {Jongwoon Park and Gunhee Lee and Sangha Lee and Dong-Kyoo Kim},
  title = {{RPS}: An Extension of Reference Monitor to Prevent Race-Attacks},
  booktitle = {PCM'04: 5th Pacific Rim Conf. on Multimedia},
  year = {2004},
  pages = {556-563},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://springerlink.metapress.com/openurl.asp?genre=article{\&}issn=0302-9743{\&}volume=3331{\&}spage=556},
  owner = {Mathias Payer},
  timestamp = {2011.05.10}
}

@MISC{aslr,
  author = {PaX-Team},
  title = {{PaX} {ASLR} ({A}ddress {S}pace {L}ayout {R}andomization)},
  year = {2003},
  howpublished = {\url{http://pax.grsecurity.net/docs/aslr.txt}},
  owner = {Mathias Payer},
  timestamp = {2010.10.18},
  url = {http://pax.grsecurity.net/docs/aslr.txt}
}

@INPROCEEDINGS{payerm11SOP,
  author = {Mathias Payer},
  title = {String Oriented Programming - Circumventing ASLR, DEP and Other Guards},
  booktitle = {28c3'11: Proc. 28th Chaos Communication Congress},
  year = {2011}
}

@INPROCEEDINGS{secuBT26c3,
  author = {Mathias Payer},
  title = {{secuBT}: Hacking the Hackers with User-Space Virtualization},
  booktitle = {Proceedings of the 26c3},
  year = {2009},
  pages = {157--163},
  owner = {Mathias Payer},
  timestamp = {2010.01.22}
}

@INPROCEEDINGS{libdetox27c3,
  author = {Mathias Payer},
  title = {I control your code - Attack vectors through the eyes of Software-based Fault Isolation},
  booktitle = {Proceedings of the 27c3},
  year = {2010},
  pages = {},
  owner = {Mathias Payer},
  timestamp = {2010.01.22}
}
@TECHREPORT{trustVM10,
  author = {Mathias Payer and Thomas Gross},
  title = {{secuBT}: Enforcing Security through User-Space Process Virtualization},
  owner = {Mathias Payer},
  timestamp = {2009.11.17}
}

@TECHREPORT{adaptSTM,
  author = {Mathias Payer and Thomas Gross},
  title = {{adaptSTM} - An Online Fine-Grained Adaptive STM System},
  institution = {ETH Zurich},
  year = {2010},
  address = {http://www.lst.ethz.ch/research/publications/ ADAPTSTM\_2010.html},
  owner = {Mathias Payer},
  timestamp = {2010.01.18},
  url = {http://people.inf.ethz.ch/payerm/adaptSTM/}
}

@INPROCEEDINGS{libdetox,
  author = {Payer, Mathias and Gross, Thomas R.},
  title = {Fine-grained user-space security through virtualization},
  booktitle = {VEE'11},
  acmid = {1952703},
  doi = {http://doi.acm.org/10.1145/1952682.1952703},
  isbn = {978-1-4503-0687-4},
  keywords = {dynamic binary translation, dynamic instrumentation, optimization,
	policy-based system call authorization, process sandboxing, security,
	user-space software virtualization, virtualization},
  location = {Newport Beach, California, USA},
  numpages = {12},
  owner = {Mathias Payer},
  timestamp = {2011.04.08},
  url = {http://doi.acm.org/10.1145/1952682.1952703}
}

@INPROCEEDINGS{dynarace,
  author = {Payer, Mathias and Gross, Thomas R.},
  title = {Protecting Applications Against TOCTTOU Races by User-Space Caching
    of File Metadata},
  booktitle = {VEE'12: Proc. 8th Int'l Conf. Virtual Execution Environments},
  year = {2012},
  location = {London, UK},
  numpages = {12},
  owner = {Mathias Payer},
  timestamp = {2011.04.08},
  url = {TODO}
}

@INPROCEEDINGS{secuLoader,
  author = {Payer, Mathias and Hartmann, Tobias and Gross, Thomas R.},
  title = {Safe Loading - A Foundation for Secure Execution of Untrusted Programs},
  booktitle = {S\&P'12: Proc. Int'l Symp. on Security and Privacy},
  year = {2012},
  location = {San Fracisco, California, USA},
  numpages = {15},
  owner = {Mathias Payer},
  timestamp = {2011.04.08},
  url = {TODO}
}

@INPROCEEDINGS{fastBT10,
  author = {Payer, Mathias and Gross, Thomas R.},
  title = {Generating low-overhead dynamic binary translators},
  booktitle = {Proc. 3rd Annual Haifa Experimental Systems Conf.},
  year = {2010},
  series = {SYSTOR '10},
  pages = {22:1--22:14},
  publisher = {ACM},
  acmid = {1815724},
  articleno = {22},
  doi = {http://doi.acm.org/10.1145/1815695.1815724},
  isbn = {978-1-60558-908-4},
  keywords = {binary translation, dynamic instrumentation, dynamic translation,
	optimization},
  location = {Haifa, Israel},
  numpages = {14},
  owner = {Mathias Payer},
  timestamp = {2010.04.15},
  url = {http://doi.acm.org/10.1145/1815695.1815724}
}

@INPROCEEDINGS{fastBT,
  author = {Mathias Payer and Thomas R. Gross},
  title = {Requirements for Fast Binary Translation},
  booktitle = {2nd Workshop on Architectural and Microarchitectural Support for
	Binary Translation},
  year = {2009},
  owner = {Mathias Payer},
  timestamp = {2009.09.15}
}

@INPROCEEDINGS{pickett:SableSpMT,
  author = {Christopher J. F. Pickett and Clark Verbrugge},
  title = {SableSpMT: a software framework for analysing speculative multithreading
	in Java},
  booktitle = {PASTE '05: Proceedings of the 6th ACM SIGPLAN-SIGSOFT workshop on
	Program analysis for software tools and engineering},
  year = {2005},
  pages = {59--66},
  doi = {http://doi.acm.org/10.1145/1108792.1108809},
  isbn = {1-59593-239-9},
  keywords = {speculation, specmt, java, dynamic},
  location = {Lisbon, Portugal},
  owner = {Mathias Payer},
  review = {dynamic, online, automatic parallelization technique

	- automatic speculative threads at 'INVOKE' and join at return from
	function

	- does not (yet) work with JIT compilers

	- reads and writes from speculative thread are written to a buffer
	and committed if currect

	- problems / special case for native methods, gc, exceptions and synchronization

	- uses return value prediction (multiple algorithms)

	--> big overhead


	print -> 1},
  timestamp = {2007.10.04}
}

@ARTICLE{beyondstacksmashing,
  author = {Jonathan Pincus and Brandon Baker},
  title = {Beyond Stack Smashing: Recent Advances in Exploiting Buffer Overruns},
  journal = {IEEE Security and Privacy},
  year = {2004},
  volume = {2},
  pages = {20-27},
  abstract = {Security vulnerabilities related to buffer overruns account for the
	largest share of CERT advisories, as well as high-profile worms -
	from the original Internet Worm in 1987 through Blaster's appearance
	in 2003. When malicious crackers discover a vulnerability, they devise
	exploits that take advantage of the vulnerability to attack a system.
	The article describes three powerful general-purpose families of
	exploits for buffer overruns: arc injection, pointer subterfuge,
	and heap smashing. These new techniques go beyond the traditional
	"stack smashing" attack and invalidate traditional assumptions about
	buffer overruns.},
  doi = {http://doi.ieeecomputersociety.org/10.1109/MSP.2004.36},
  issn = {1540-7993},
  owner = {Mathias Payer},
  review = {Stack smashing ( inject code on the stack )

	Heap smashing ( inject code on the heap )

	Arc injection (inject new alternate control flows into the program
	(e.g., ret2libc) )

	Pointer subterfuge ( function pointer clobbering, data-pointer modification,
	exception-handler hijacking, virtual pointer smashing )},
  timestamp = {2011.02.02}
}

@ARTICLE{captain10formatstring,
  author = {Captain Planet},
  title = {A Eulogy for Format Strings},
  journal = {Phrack},
  year = {2010},
  volume = {14},
  pages = {\url{http://phrack.com/issues.html?issue=67&id=8}},
  number = {67},
  abstract = {Today the Windows CRT disables %n by default [0]. And likewise, glibc's

	FORTIFY_SOURCE patches provides protection mechanisms which render


	exploitation impossible. Objective-C isn't being considered, but i'm
	told

	you can have plenty of fun there too. Even format strings weren't
	a

	critically endangered species, they've been demoted to the class of


	infoleak. The great thing about format strings of course was that
	they

	provided both a read and write primitive. They were the `spork` of


	exploitation. ASLR? PIE? NX Stack/Heap? No problem, fmt had you covered.},
  chapter = {9},
  keywords = {format string exploit},
  owner = {Mathias Payer},
  review = {bypass FORTIFY_SOURCE (in libc)},
  timestamp = {2011.12.21},
  url = {http://www.phrack.org/issues.html?issue=67\&id=9}
}

@INPROCEEDINGS{popovici02aosd,
  author = {Popovici, Andrei and Gross, Thomas and Alonso, Gustavo},
  title = {Dynamic weaving for aspect-oriented programming},
  booktitle = {AOSD'02},
  acmid = {508404},
  doi = {http://doi.acm.org/10.1145/508386.508404},
  isbn = {1-58113-469-X},
  numpages = {7},
  url = {http://doi.acm.org/10.1145/508386.508404}
}

@INPROCEEDINGS{porkolab10gpce,
  author = {Porkolab, Zolt\'{a}n and Sinkovics, \'{A}bel},
  title = {Domain-specific language integration with compile-time parser generator
	library},
  booktitle = {GPCE '10: Proc. 9th Conf. on Generative Programming and Component
	Engineering},
  year = {2010},
  pages = {137--146},
  abstract = { Smooth integration of domain-specific languages into a general purpose
	host language requires absorbing of domain code written in arbitrary
	syntax. The integration should cause minimal syntactical and semantic
	overhead and introduce minimal dependency on external tools. In this
	paper we discuss a DSL integration technique for the C++ programming
	language. The solution is based on compile-time parsing of the DSL
	code. The parser generator is a C++ template metaprogram reimplementation
	of a runtime Haskell parser generator library. The full parsing phase
	is executed when the host program is compiled. The library uses only
	standard C++ language features, thus our solution is highly portable.
	As a demonstration of the power of this approach, we present a highly
	efficient and type-safe version of printf and the way it can be constructed
	using our library. Despite the well known syntactical difficulties
	of C++ template metaprograms, building embedded languages using our
	library leads to self-documenting C++ source code. },
  acmid = {1868315},
  doi = {http://doi.acm.org/10.1145/1868294.1868315},
  isbn = {978-1-4503-0154-1},
  keywords = {C++ template metaprogram, DSL integration, haskell, parser generator},
  location = {Eindhoven, The Netherlands},
  numpages = {10},
  url = {http://doi.acm.org/10.1145/1868294.1868315}
}

@INPROCEEDINGS{porter10syncchar,
  author = {Porter, Donald E. and Witchel, Emmett},
  title = {Understanding Transactional Memory Performance},
  booktitle = {ISPASS'2010},
  year = {2010},
  pages = {97--108},
  month = {March},
  abstract = {Transactional memory promises to generalize transactional programming
	to mainstream languages and data structures. The purported benefit
	of transactions is that they are easier to program correctly than
	fine-grained locking and perform just as well. This performance claim
	is not always borne out because an application may violate a common-case
	assumption of the TM designer or because of external system effects.
	This paper carefully studies a range of factors that can adversely
	influence transactional memory performance.

	In order to help programmers assess the suitability of their code
	for transactional memory, this paper introduces a formal model of
	transactional memory as well as a tool, called Syncchar. Syncchar
	can predict the speedup of a conversion from locks to transactions
	within 25% for the STAMP benchmarks. We also use

	the Syncchar tool to diagnose and eliminate a starvation pathology
	in the TxLinux kernel, improving the performance of the Modified
	Andrew Benchmark by 55% over Linux.

	The paper also presents the first detailed study of how the performance
	of user-level transactional programs (from the STAMP benchmarks)
	are influenced by factors outside of the transactional memory system.
	The study includes data about the interaction of transactional programs
	with the architecture, memory allocator, and compiler. Because many
	factors influence the performance of transactional programs, getting
	good performance from transactions is more difficult than commonly
	appreciated.},
  keywords = {TM, HTM, analysis},
  owner = {Mathias Payer},
  review = {They present Syncchar, a tool to analyze TM / transactions (currently
	a HTM) & to find performance bottlenecks},
  timestamp = {2010.09.08},
  urlpage = {http://www.cs.utexas.edu/~porterde/pubs/ispass10-final.pdf}
}

@INPROCEEDINGS{ports2008towards,
  author = {Ports, D.R.K. and Garfinkel, T.},
  title = {{Towards application security on untrusted operating systems}},
  booktitle = {Proceedings of the 3rd conference on Hot topics in security},
  year = {2008},
  pages = {1--7},
  abstract = {Complexity in commodity operating systems makes compromises inevitable.
	Consequently, a great deal of work has examined how to protect security-critical
	portions of applications from the OS through mechanisms such as microkernels,
	virtual machine monitors, and new processor architectures. Unfortunately,
	most work has focused on CPU and memory isolation and neglected OS
	semantics. Thus, while much is known about how to prevent OS and
	application processes from modifying each other, far less is understood
	about how different OS components can undermine application security
	if they turn malicious.


	We consider this problem in the context of our work on Overshadow,
	a virtual-machine-based system for retrofitting protection in commodity
	operating systems. We explore how malicious behavior in each major
	OS sub-system can undermine application security, and present potential
	mitigations. While our discussion is presented in terms of Overshadow
	and Linux, many of the problems and solutions are applicable to other
	systems where trusted applications rely on untrusted, potentially
	malicious OS components.},
  owner = {Mathias Payer},
  review = {1st overshadow paper},
  timestamp = {2011.02.03}
}

@INPROCEEDINGS{prasad03atc,
  author = {Manish Prasad and Tzi-cker Chiueh},
  title = {A Binary Rewriting Defense Against Stack based Buffer Overflow Attacks},
  booktitle = {Proc. 12th USENIX ATC},
  year = {2003},
  pages = {211-224},
  ee = {http://www.usenix.org/events/usenix03/tech/prasad.html}
}

@INPROCEEDINGS{systrace03,
  author = {Provos, Niels},
  title = {Improving host security with system call policies},
  booktitle = {SSYM'03: Proc. 12th USENIX Security Symp.},
  year = {2003},
  abstract = {Many operating system services require special privilege to execute
	their tasks. A programming error in a privileged service opens the
	door to system compromise in the form of unauthorized acquisition
	of privileges. In the worst case, a remote attacker may obtain superuser
	privileges. In this paper, we discuss the methodology and design
	of privilege separation, a generic approach that lets parts of an
	application run with different levels of privilege. Programming errors
	occurring in the unprivileged parts can no longer be abused to gain
	unauthorized privileges. Privilege separation is orthogonal to capability
	systems or application confinement and enhances the security of such
	systems even further.


	Privilege separation is especially useful for system services that
	authenticate users. These services execute privileged operations
	depending on internal state not known to an application confinement
	mechanism. As a concrete example, the concept of privilege separation
	has been implemented in OpenSSH. However, privilege separation is
	equally useful for other authenticating services. We illustrate how
	separation of privileges reduces the amount of OpenSSH code that
	is executed with special privilege. Privilege separation prevents
	known security vulnerabilities in prior OpenSSH versions including
	some that were unknown at the time of its implementation.},
  location = {Washington, DC},
  owner = {Mathias Payer},
  review = {kernel extension

	small general in-kernel policy read/write

	policy daemon in user-space, context switches

	text policy-language used},
  timestamp = {2010.02.02}
}

@ARTICLE{quinones:Mitosis,
  author = {Carlos Garcia Quinones and Carlos Madriles and Jesus Sanchez and
	Pedro Marcuello and Antonio Gonzalez and Dean M. Tullsen},
  title = {Mitosis compiler: an infrastructure for speculative threading based
	on pre-computation slices},
  journal = {SIGPLAN Not.},
  year = {2005},
  volume = {40},
  pages = {269--279},
  number = {6},
  abstract = {Speculative parallelization can provide significant sources of additional
	thread-level parallelism, especially for irregular applications that
	are hard to parallelize by conventional approaches. In this paper,
	we present the Mitosis compiler, which partitions applications into
	speculative threads, with special emphasis on applications for which
	conventional parallelizing approaches fail.The management of inter-thread
	data dependences is crucial for the performance of the system. The
	Mitosis framework uses a pure software approach to predict/compute
	the thread's input values. This software approach is based on the
	use of pre-computation slices (p-slices), which are built by the
	Mitosis compiler and added at the beginning of the speculative thread.
	P-slices must compute thread input values accurately but they do
	not need to guarantee correctness, since the underlying architecture
	can detect and recover from misspeculations. This allows the compiler
	to use aggressive/unsafe optimizations to significantly reduce their
	overhead. The most important optimizations included in the Mitosis
	compiler and presented in this paper are branch pruning, memory and
	register dependence speculation, and early thread squashing.Performance
	evaluation of Mitosis compiler/architecture shows an average speedup
	of 2.2.},
  doi = {http://doi.acm.org/10.1145/1064978.1065043},
  issn = {0362-1340},
  keywords = {speculation, specmt, hardware},
  owner = {Mathias Payer},
  review = {speculation on BB

	p-slices for precomputed values (IN nodes & used variables)

	depends on HW support for mem rollback


	print -> 1},
  timestamp = {2007.10.04}
}

@INPROCEEDINGS{raffetseder07isc,
  author = {Thomas Raffetseder and Christopher Kr{\"u}gel and Engin Kirda},
  title = {Detecting System Emulators},
  booktitle = {ISC'07: Int. Conf. Information Security},
  year = {2007},
  pages = {1-18},
  abstract = {Malware analysis is the process of determining the behavior and purpose
	of a given malware sample (such as a virus, worm, or Trojan horse).
	This process is a necessary step to be able to develop effective
	detection techniques and removal tools. Security companies typically
	analyze unknown malware samples using simulated system environments
	(such as virtual machines or emulators). The reason is that these
	environments ease the analysis process and provide more control over
	executing processes. Of course, the goal of malware authors is to
	make the analysis process as difficult as possible. To this end,
	they can equip their malware programs with checks that detect whether
	their code is executing in a virtual environment, and if so, adjust
	the programâs behavior accordingly. In fact, many current malware
	programs already use routines to determine whether they are running
	in a virtualizer such as VMware. The general belief is that system
	emulators (such as Qemu) are more difficult to detect than traditional
	virtual machines (such as VMware) because they handle all instructions
	in software. In this paper, we seek to answer the question whether
	this belief is justified. In particular, we analyze a number of possibilities
	to detect system emulators. Our results shows that emulation can
	be successfully detected, mainly because the task of perfectly emulating
	real hardware is complex. Furthermore, some of our tests also indicate
	that novel technologies that provide hardware support for virtualization
	(such as Intel Virtualization Technology) may not be as undetectable
	as previously thought.},
  ee = {http://dx.doi.org/10.1007/978-3-540-75496-1_1},
  owner = {Mathias Payer},
  timestamp = {2012.04.26}
}

@INPROCEEDINGS{virttranmem05,
  author = {Rajwar,, Ravi and Herlihy,, Maurice and Lai,, Konrad},
  title = {Virtualizing Transactional Memory},
  booktitle = {ISCA '05: Proceedings of the 32nd annual international symposium
	on Computer Architecture},
  year = {2005},
  pages = {494--505},
  abstract = {Writing concurrent programs is difficult because of the complexity
	of ensuring proper synchronization. Conventional lock-based synchronization
	suffers from wellknown limitations, so researchers have considered
	non-blocking transactions as an alternative. Recent hardware proposals
	have demonstrated how transactions can achieve high performance while
	not suffering limitations of lock-based mechanisms. However, current
	hardware proposals require programmers to be aware of platform-specific
	resource limitations such as buffer sizes, scheduling quanta, as
	well as events such as page faults, and process migrations. If the
	transactional model is to gain wide acceptance, hardware support
	for transactions must be virtualized to hide these limitations in
	much the same way that virtual memory shields the programmer from
	platform-specific limitations of physical memory. This paper proposes
	Virtual Transactional Memory (VTM), a user-transparent system that
	shields the programmer from various platform-specific resource limitations.
	VTM maintains the performance advantage of hardware transactions,
	incurs low overhead in time, and has modest costs in hardware support.
	While manysystem-level challenges remain, VTM takes a step toward
	making transactional models more widely acceptable.},
  doi = {http://dx.doi.org/10.1109/ISCA.2005.54},
  isbn = {0-7695-2270-X},
  keywords = {STM, TM, HTM},
  owner = {Mathias Payer},
  review = {Based on HTM + Software Layer to handle stuff like swapping ,nesting
	and user space considerations

	(but all is backed by the HTM system)

	=> Print 1},
  timestamp = {2009.04.08}
}

@INPROCEEDINGS{ramadan09committingconflictingtx,
  author = {Ramadan, Hany E. and Roy, Indrajit and Herlihy, Maurice and Witchel,
	Emmett},
  title = {Committing conflicting transactions in an {STM}},
  booktitle = {PPoPP '09},
  year = {2009},
  pages = {163--172},
  publisher = {ACM},
  abstract = {Dependence-aware transactional memory (DATM) is a recently proposed
	model for increasing concurrency of memory transactions without complicating
	their interface. DATM manages dependences between conflicting, uncommitted
	transactions so that they commit safely.


	The contributions of this paper are twofold. First, we provide a safety
	proof for the dependence-aware model. This proof also shows that
	the DATM model accepts all concurrent interleavings that are conflict-serializable.


	Second, we describe the first application of dependence tracking to
	software transactional memory (STM) design and implementation. We
	compare our implementation with a state of the art STM, TL2 [4].
	We use benchmarks from the STAMP [21] suite, quantifying how dependence
	tracking converts certain types of transactional conflicts into successful
	commits. On high contention workloads, DATM is able to take advantage
	of dependences to speed up execution by up to 4.8x.},
  doi = {http://doi.acm.org/10.1145/1504176.1504201},
  isbn = {978-1-60558-397-6},
  keywords = {STM, TM, DATM},
  location = {Raleigh, NC, USA},
  owner = {Mathias Payer},
  review = {DATM system


	R->W & W->W => lock tx and commit later

	W->R => forward W and commit later


	WB system, lock based},
  timestamp = {2009.05.31}
}

@INPROCEEDINGS{tolerace,
  author = {Ratanaworabhan, Paruj and Burtscher, Martin and Kirovski, Darko and
	Zorn, Benjamin and Nagpal, Rahul and Pattabiraman, Karthik},
  title = {Detecting and tolerating asymmetric races},
  booktitle = {PPoPP '09: Proceedings of the 14th ACM SIGPLAN symposium on Principles
	and practice of parallel programming},
  year = {2009},
  pages = {173--184},
  publisher = {ACM},
  abstract = {This paper introduces ToleRace, a runtime system that allows programs
	to detect and even tolerate asymmetric data races. Asymmetric races
	are race conditions where one thread correctly acquires and releases
	a lock for a shared variable while another thread improperly accesses
	the same variable. ToleRace provides approximate isolation in the
	critical sections of lock-based parallel programs by creating a local
	copy of each shared variable when entering a critical section, operating
	on the local copies, and propagating the appropriate copies upon
	leaving the critical section. We start by characterizing all possible
	interleavings that can cause races and precisely describe the effect
	of ToleRace in each case. Then, we study the theoretical aspects
	of an oracle that knows exactly what type of interleaving has occurred.
	Finally, we present two software implementations of ToleRace and
	evaluate them on multithreaded applications from the SPLASH2 and
	PARSEC suites. Our implementation on top of a dynamic instrumentation
	tool, which works directly on executables and requires no source
	code modifications, incurs an overhead of a factor of two on average.
	Manually adding ToleRace to the source code of these applications
	results in an average overhead of 6.4 percent.},
  doi = {http://doi.acm.org/10.1145/1504176.1504202},
  isbn = {978-1-60558-397-6},
  keywords = {STM, TM, race detection, SPLASH2},
  location = {Raleigh, NC, USA},
  owner = {Mathias Payer},
  review = {solve races through replication

	critical section -> make 2 copies, locked data work on one copy

	leave critical section -> check backup copy and original

	implemented in PIN -> slow},
  timestamp = {2010.09.27}
}

@INPROCEEDINGS{riegel:lsa:disc:2006,
  author = {Riegel, Torvald and Felber, Pascal and Fetzer, Christof},
  title = {A Lazy Snapshot Algorithm with Eager Validation},
  booktitle = {DISC'06},
  year = {2006},
  pages = {284--298},
  month = {Sep},
  publisher = {Springer},
  file = {preprint-riegel2006lsa.pdf:http\://se.inf.tu-dresden.de/papers/preprint-riegel2006lsa.pdf:PDF},
  isbn = {3-540-44624-9},
  owner = {Mathias Payer},
  timestamp = {2009.05.26},
  urlpage = {http://dx.doi.org/10.1007/11864219_20}
}

@INPROCEEDINGS{riegel2006sistm,
  author = {Torvald Riegel and Christof Fetzer and Pascal Felber},
  title = {Snapshot Isolation for Software Transactional Memory },
  booktitle = {TRANSACT'06},
  year = { 2006 },
  month = { Jun },
  abstract = {Software transactional memory (STM) has been proposed to simplify
	the development and to increase the scalability of concurrent programs.
	One problem of existing STMs is that of having long-running read
	transactions co-exist with shorter update transactions. This problem
	is of practical importance and has so far not been addressed by other
	papers in this domain. We approach this problem by investigating
	the performance of a STM using snapshot isolation and a novel lazy
	multi-version snapshot algorithm to decrease the validation costs
	- which can increase quadratically with the number of objects read
	in STMs with invisible reads. Our measurements demonstrate that snapshot
	isolation can increase throughput for workloads with long transactions.
	In comparison to other STMs with invisible reads, we can reduce the
	validation costs by using our lazy consistent snapshot algorithm.},
  comment = { generated by split.pl },
  owner = {Mathias Payer},
  timestamp = {2009.05.28}
}

@INPROCEEDINGS{riley06htm,
  author = {Nicholas Riley and Craig Zilles},
  title = {Hardware tansactional memory support for lightweight dynamic language
	evolution},
  booktitle = {OOPSLA '06: Companion to the 21st ACM SIGPLAN symposium on Object-oriented
	programming systems, languages, and applications},
  year = {2006},
  pages = {998--1008},
  publisher = {ACM},
  abstract = {Lightweight dynamic language runtimes have become popular in part
	because they simply integrate with a wide range of native code libraries
	and embedding applications. However, further development of these
	runtimes in the areas of concurrency, efficiency and safety is impeded
	by the desire to maintain their native code interfaces, even at a
	source level. Native extension modules' lack of thread safety is
	a significant barrier to dynamic languages' effective deployment
	on current and future multicore and multiprocessor systems. We propose
	the use of hardware transactional memory (HTM) to aid runtimes in
	evolving more capable and robust execution models while maintaining
	native code compatibility. To explore these ideas, we constructed
	a full-system simulation infrastructure consisting of an HTM implementation,
	modified Linux kernel and Python interpreter.Python includes thread
	constructs, but its primary implementation is not architected to
	support their parallel execution. With small changes, a runtime can
	be made HTM-aware to enable parallel execution of Python code and
	extension modules. We exploit the semantics of Python execution to
	evaluate individual bytecodes atomically by default, using nested
	transactions to emulate programmer-specified locking constructs where
	possible in existing threaded code. We eliminate common transactional
	conflicts and defer I/O within transactions to make parallel Python
	execution both possible and efficient. Transactions also provide
	safety for foreign function invocations. We characterize several
	small Python applications executing on our infrastructure.},
  doi = {http://doi.acm.org/10.1145/1176617.1176758},
  isbn = {1-59593-491-X},
  keywords = {HTM, TM},
  location = {Portland, Oregon, USA},
  owner = {Mathias Payer},
  review = {use a htm to remove pythons global lock},
  timestamp = {2008.11.13}
}

@INPROCEEDINGS{rivera98,
  author = {Gabriel Rivera and Chau-Wen Tseng},
  title = {Data transformations for eliminating conflict misses},
  booktitle = {Proc. of the ACM SIGPLAN 1998 Conf. on Programming Language Design
	and Implementation (PLDI~1998)},
  year = {1998},
  pages = {38--49},
  doi = {http://doi.acm.org/10.1145/277650.277661},
  isbn = {0-89791-987-4},
  location = {Montreal, Quebec, Canada}
}

@INPROCEEDINGS{robertson03lisa,
  author = {W. Robertson and C Kruegel and D. Mutz and F Valeur},
  title = {Run-time Detection of Heap-based Overflows},
  booktitle = {Proc. of the 17th {Usenix} Large Installation Systems Administration
	Conference ({LISA})},
  year = {2003},
  pages = {51--60},
  month = {Oct},
  abstract = {Buffer overflows belong to the most common class of attacks on todayâs
	Internet. Although

	stack-based variants are still by far more frequent and well-understood,
	heap-based overflows have

	recently gained more attention. Several real-world exploits have been
	published that corrupt heap

	management information and allow arbitrary code execution with the
	privileges of the victim process.

	This paper presents a technique that protects the heap management
	information and allows

	for run-time detection of heap-based overflows. We discuss the structure
	of these attacks and our

	proposed detection scheme that has been implemented as a patch to
	the GNU Lib C. We report the

	results of our experiments, which demonstrate the detection effectiveness
	and performance impact

	of our approach. In addition, we discuss different mechanisms to deploy
	the memory protection.},
  owner = {Mathias Payer},
  review = {Replaces malloc and protects from overwriting malloc data structures.
	Function pointers on the heap are not protected.},
  timestamp = {2011.11.21},
  url = {http://www.usenix.org/publications/library/proceedings/lisa03/tech/full_papers/robertson/robertson.pdf}
}

@MISC{rose-survey,
  author = {Robert Rose},
  title = {Survey of System Virtualization Techniques},
  abstract = {This paper discusses two main trends in the development of virtual


	machine systems: full system virtualization, where an entire hardware


	architecture is replicated virtually, and paravirtualization, where

	an


	operating system is modified so that it can be run concurrently with


	other operating systems that have also been designed for

	paravirtualization.},
  keywords = {survey, virtualization, techniques, VMM},
  owner = {Mathias Payer},
  review = {2 reasons for virtualization: isolation & performance


	VMM (virtual machine monitor)

	- provides isolation and access to (virtualized) HW

	HW requirement: privileged instructions must trap (sensitive instr
	are a subset of the privileged instructions)


	Virtualization: Expensive (alot must be emulated), but no changes
	to OS

	Paravirtualization: Changes to OS, maybe other limitations, faster
	(nearly native performance)


	print -> 1},
  timestamp = {2007.10.04}
}

@misc{CVE-2010-0830,
  author = {Dan Rosenberg},
  year = {2010},
  title = {{CVE-2010-0830}: Integer overflow in ld.so},
  howpublished = {\url{http://drosenbe.blogspot.com/2010/05/integer-overflow-in-ldso-cve-2010-0830.html}},
  owner = {gannimo},
  timestamp = {2011.06.12}
}

@INPROCEEDINGS{DATALAYOUT-POPL02,
  author = {Shai Rubin and Rastislav Bodik and Trishul Chilimbi},
  title = {An efficient {profile-analysis} framework for data-layout optimizations},
  booktitle = {Proc.~of the 29th Symp.~on Principles Of Programming Languages (POPL~2002)},
  year = {2002},
  pages = {140--153},
  doi = {http://doi.acm.org/10.1145/503272.503287},
  isbn = {1-58113-450-9},
  location = {Portland, Oregon}
}

@MISC{rutkowska04blog,
  author = {Joanna Rutkowska},
  title = {Red Pill... Or How To Detect {VMM} Using (Almost) One {CPU} Instruction},
  howpublished = {\url{http://invisiblethings.org/papers/redpill.html}},
  month = {2004},
  owner = {Mathias Payer},
  timestamp = {2012.04.26}
}

@INPROCEEDINGS{SanchezGonzales98,
  author = {Jesus S\'anchez and Antonio Gonz\'alez},
  title = {Fast, Accurate and Flexible Data Locality Analysis},
  booktitle = {Proc. of the 1998 International Conference on Parallel Architectures
	and Compilation Techniques},
  year = {1998},
  pages = {124},
  isbn = {0-8186-8591-3}
}

@INPROCEEDINGS{saha06mcrtstm,
  author = {Bratin Saha and Ali-Reza Adl-Tabatabai and Richard L. Hudson and
	Chi Cao Minh and Benjamin Hertzberg},
  title = {{McRT-STM}: a high performance software transactional memory system
	for a multi-core runtime},
  booktitle = {PPoPP '06},
  year = {2006},
  pages = {187--197},
  publisher = {ACM},
  abstract = {Applications need to become more concurrent to take advantage of the
	increased computational power provided by chip level multiprocessing.
	Programmers have traditionally managed this concurrency using locks
	(mutex based synchronization). Unfortunately, lock based synchronization
	often leads to deadlocks, makes fine-grained synchronization difficult,
	hinders composition of atomic primitives, and provides no support
	for error recovery. Transactions avoid many of these problems, and
	therefore, promise to ease concurrent programming.We describe a software
	transactional memory (STM) system that is part of McRT, an experimental
	Multi-Core RunTime. The McRT-STM implementation uses a number of
	novel algorithms, and supports advanced features such as nested transactions
	with partial aborts, conditional signaling within a transaction,
	and object based conflict detection for C/C++ applications. The McRT-STM
	exports interfaces that can be used from C/C++ programs directly
	or as a target for compilers translating higher level linguistic
	constructs.We present a detailed performance analysis of various
	STM design tradeoffs such as pessimistic versus optimistic concurrency,
	undo logging versus write buffering, and cache line based versus
	object based conflict detection. We also show a MCAS implementation
	that works on arbitrary values, coexists with the STM, and can be
	used as a more efficient form of transactional memory. To provide
	a baseline we compare the performance of the STM with that of fine-grained
	and coarse-grained locking using a number of concurrent data structures
	on a 16-processor SMP system. We also show our STM performance on
	a non-synthetic workload -- the Linux sendmail application.},
  doi = {http://doi.acm.org/10.1145/1122971.1123001},
  isbn = {1-59593-189-9},
  keywords = {STM, TM, McRT-STM},
  location = {New York, New York, USA},
  owner = {Mathias Payer},
  timestamp = {2008.11.13}
}

@INPROCEEDINGS{schmuck91sosp,
  author = {Schmuck, Frank and Wylie, Jim},
  title = {Experience with transactions in QuickSilver},
  booktitle = {SOSP'09: Proc. 13th ACM Symposium on Operating Systems Principles},
  year = {1991},
  pages = {239--253},
  abstract = {All programs in the QuickSilver distributed system behave atomically
	with respect to their updates to permanent data. Operating system
	support for transactions provides the framework required to support
	this, as well as a mechanism that unifies reclamation of resources
	after failures or normal process termination. This paper evaluates
	the use of transactions for these purposes in a general purpose operating
	system and presents some of the lessons learned from our experience
	with a complete running system based on transactions. Examples of
	how transactions are used in QuickSilver and measurements of their
	use demonstrate that the transaction mechanism provides an efficient
	and powerful means for solving many of the problems introduced by
	operating system extensibility and distribution.},
  acmid = {121171},
  doi = {http://doi.acm.org/10.1145/121132.121171},
  isbn = {0-89791-447-3},
  location = {Pacific Grove, California, United States},
  numpages = {15},
  owner = {Mathias Payer},
  timestamp = {2011.05.10},
  url = {http://doi.acm.org/10.1145/121132.121171}
}

@INPROCEEDINGS{LCPC05,
  author = {Florian Schneider and Thomas Gross},
  title = {Using Platform-Specific Performance Counters for Dynamic Compilation},
  booktitle = {Proceedings of the International Workshop on Compilers for Parallel
	Computing (LCPC~2005)},
  year = {2005},
  month = oct,
  key = {LCPC05}
}

@misc{schneierbugs,
  author = {Bruce Schneier},
  title = {Software Complexity and Security},
  howpublished = {\url{https://www.schneier.com/crypto-gram-0003.html#8}},
  year = {2000},
  owner = {gannimo},
  review = {The first reason is the number of security bugs. All software contains
	bugs. And as the complexity of the software goes up, the number of
	bugs goes up. And a percentage of these bugs will affect security.

	...

	Real systems show no signs of becoming less complex. In fact, they
	are becoming more complex faster and faster. Microsoft Windows is
	a poster child for this trend to complexity. Windows 3.1, released
	in 1992, had 3 million lines of code; Windows 95 has 15 million and
	Windows 98 has 18 million. The original Windows NT (also 1992) had
	4 million lines of code; NT 4.0 (1996) has 16.5 million. In 1998,
	Windows NT 5.0 was estimated to have 20 million lines of code; by
	the time it was renamed Windows 2000 (in 1999) it had between 35
	million and 60 million lines of code, depending on who you believe.
	(As points of comparison, Solaris has held pretty stable at about
	7 to 8 million lines of code for the last few releases, and Linux,
	even with the addition of X Windows and Apache, is still under 5
	million lines of code.)},
  timestamp = {2011.06.13}
}

@INPROCEEDINGS{schwarz05ccs,
  author = {Schwarz, Benjamin and Chen, Hao and Wagner, David and Lin, Jeremy
	and Tu, Wei and Morrison, Geoff and West, Jacob},
  title = {Model Checking An Entire {Linux} Distribution for Security Violations},
  booktitle = {Proc 21st Computer Security Applications Conference},
  year = {2005},
  pages = {13--22},
  abstract = {Software model checking has become a popular tool for verifying programs'
	behavior. Recent results suggest that it is viable for finding and
	eradicating security bugs quickly. However, even state-of-the-art
	model checkers are limited in use when they report an overwhelming
	number of false positives, or when their lengthy running time dwarfs
	other software development processes. In this paper we report our
	experiences with software model checking for security properties
	on an extremely large scale-an entire Linux distribution consisting
	of 839 packages and 60 million lines of code. To date, we have discovered
	108 exploitable bugs. Our results indicate that model checking can
	be both a feasible and integral part of the software development
	process.},
  acmid = {1106807},
  doi = {10.1109/CSAC.2005.39},
  isbn = {0-7695-2461-3},
  numpages = {10},
  owner = {Mathias Payer},
  review = {Use model checking for a complete linux distribution, use MOPS to
	check different patterns.


	2333 warnings, 108 bugs found.},
  timestamp = {2011.05.09},
  url = {http://portal.acm.org/citation.cfm?id=1106778.1106807}
}

@misc{sysVABI,
  author = {SCO},
  title = {{System V Application Binary Interface, Intel386 Architecture Processor
	Supplement}},
  howpublished = {\url{http://www.sco.com/developers/devspecs/abi386-4.pdf}},
  year = {1996},
  abstract = {The System V Application Binary Interface, or ABI, defines a system
	interface for

	compiled application programs. Its purpose is to establish a standard
	binary

	interface for application programs on systems that implement the interfaces

	defined in the System V Interface Definition, Edition 4. This includes
	systems that

	have implemented UnixWareÂ® 2.0.


	This document is a supplement to the generic System V ABI, and it
	contains infor-

	mation specific to System V implementations built on the Intel386
	processor archi-

	tecture. Together, these two specifications, the generic System V
	ABI and the

	Intel386 Architecture System V ABI Supplement (hereafter referred
	to as the Intel386

	ABI), constitute a complete System V Application Binary Interface
	specification for

	systems that implement the processor architecture of the Intel386
	microprocessors.

	Note that, because the Intel486 and Pentium processor are compatible
	members of

	the Intel386 architecture, this Intel386 ABI also applies to any system
	built with the

	Intel486 or the Pentium processor chips.},
  institution = {SCO},
  owner = {Mathias Payer},
  timestamp = {2011.02.01},
  url = {https://www.sco.com/developers/devspecs/abi386-4.pdf}
}

@ARTICLE{strataSVE,
  author = {Kevin Scott and Jack Davidson},
  title = {Safe Virtual Execution Using Software Dynamic Translation},
  journal = {ACSAC'02},
  abstract = {Safe virtual execution (SVE) allows a host computer system to reduce
	the risks associated with running untrusted programs. SVE prevents
	untrusted programs from directly accessing system resources, thereby
	giving the host the ability to control how individual resources may
	be used. SVE is used in a variety of safety-conscious software systems,
	including the Java Virtual Machine (JVM), software fault isolation
	(SFI), system call interposition layers, and execution monitors.
	While SVE is the conceptual foundation for these systems, each uses
	a different implementation technology. The lack of a unifying framework
	for building SVE systems results in a variety of problems: many useful
	SVE systems are not portable and therefore are usable only on a limited
	number of platforms; code reuse among different SVE systems is often
	difficult or impossible; and building SVE systems from scratch can
	be both time consuming and error prone.

	To address these concerns, we have developed a portable, extensible
	framework for constructing SVE systems. Our framework, called Strata,
	is based on software dynamic translation (SDT), a technique for modifying
	binary programs as they execute. Strata is designed to be ported
	easily to new platforms and to date has been targeted to SPARC/Solaris,
	x86/Linux, and MIPS/IRIX. This portability ensures that SVE applications
	implemented in Strata are available to a wide variety of host systems.
	Strata also affords the opportunity for code reuse among different
	SVE applications by establishing a common implementation framework.

	Strata implements a basic safe virtual execution engine using SDT.
	The base functionality supplied by this engine is easily extended
	to implement specific SVE systems. In this paper we describe the
	organization of Strata and demonstrate its extension by building
	two SVE systems: system call interposition and stack-smashing prevention.
	To illustrate the use of the system call interposition extensions,
	the paper presents implementations of several useful security policies.},
  doi = {http://doi.ieeecomputersociety.org/10.1109/CSAC.2002.1176292},
  issn = {1063-9527},
  owner = {Mathias Payer},
  timestamp = {2009.10.27}
}

@TECHREPORT{strataimpl,
  author = {Scott, Kevin and Davidson, Jack},
  title = {Strata: A Software Dynamic Translation Infrastructure},
  institution = {University of Virginia},
  year = {2001},
  abstract = {Software dynamic translation is the alteration of a running program
	to achieve a specific objective. For example, a dynamic optimizer
	uses software dynamic translation to modify a running program with
	the objective of making the program run faster. In addition to its
	demonstrated utility in dynamic optimizers, software dynamic translation
	also shows promise for producing applications that are adaptable,
	secure, and robust. In this paper, we describe the design and implementation
	of an extensible, retargetable infrastructure to facilitate research
	in applications of software dynamic translation technology. The infrastructure,
	called Strata, provides the software dynamic translator implementor
	with a virtual machine model that can be extended to implement specific
	software dynamic translation functionality. To illustrate the use
	of Strata to build client applications, the paper describes the Strata
	implementation of a two dynamic safety checkers and a dynamic instruction
	scheduler.},
  owner = {Mathias Payer},
  publisher = {University of Virginia},
  source = {http://www.ncstrl.org:8900/ncstrl/servlet/search?formname=detail\&id=oai%3Ancstrlh%3Auva_cs%3Ancstrl.uva_cs%2F%2FCS-2001-17},
  timestamp = {2009.10.27}
}

@ARTICLE{segal89dynprog,
  author = {Segal, M. E. and Frieder, O.},
  title = {Dynamic program updating: a software maintenance technique for minimizing
	software downtime},
  journal = {Journal of Software Maintenance'89},
  doi = {10.1002/smr.4360010106},
  issn = {1040-550X},
  url = {http://dl.acm.org/citation.cfm?id=68673.68677}
}

@INPROCEEDINGS{ret2libc,
  author = {Hovav Shacham},
  title = {The Geometry of Innocent Flesh on the Bone: Return-into-libc without
	Function Calls (on the {x86})},
  booktitle = {CCS'07: Proc. 14th Conf. on Computer and Communications Security},
  year = {2007},
  pages = {552-561},
  abstract = {We present new techniques that allow a return-into-libc attack to
	be mounted on x86 executables that calls no functions at all. Our
	attack combines a large number of short instruction sequences to
	build gadgets that allow arbitrary computation. We show how to discover
	such instruction sequences by means of static analysis. We make use,
	in an essential way, of the properties of the x86 instruction set.},
  owner = {Mathias Payer},
  timestamp = {2010.11.08}
}

@INPROCEEDINGS{shacham04aslr,
  author = {Shacham, Hovav and Page, Matthew and Pfaff, Ben and Goh, Eu-Jin and
	Modadugu, Nagendra and Boneh, Dan},
  title = {On the effectiveness of address-space randomization},
  booktitle = {CCS'04: Proc. 11th Conf. Computer and Communications Security},
  year = {2004},
  pages = {298--307},
  abstract = {Address-space randomization is a technique used to fortify systems
	against buffer overflow attacks. The idea is to introduce artificial
	diversity by randomizing the memory location of certain system components.
	This mechanism is available for both Linux (via PaX ASLR) and OpenBSD.
	We study the effectiveness of address-space randomization and find
	that its utility on 32-bit architectures is limited by the number
	of bits available for address randomization. In particular, we demonstrate
	a <i>derandomization attack</i> that will convert any standard buffer-overflow
	exploit into an exploit that works against systems protected by address-space
	randomization. The resulting exploit is as effective as the original
	exploit, although it takes a little longer to compromise a target
	machine: on average 216 seconds to compromise Apache running on a
	Linux PaX ASLR system. The attack does not require running code on
	the stack.


	We also explore various ways of strengthening address-space randomization
	and point out weaknesses in each. Surprisingly, increasing the frequency
	of re-randomizations adds at most 1 bit of security. Furthermore,
	compile-time randomization appears to be more effective than runtime
	randomization. We conclude that, on 32-bit architectures, the only
	benefit of PaX-like address-space randomization is a small slowdown
	in worm propagation speed. The cost of randomization is extra complexity
	in system support.},
  doi = {http://doi.acm.org/10.1145/1030083.1030124},
  isbn = {1-58113-961-6},
  location = {Washington DC, USA},
  owner = {Mathias Payer},
  timestamp = {2010.10.19}
}

@INPROCEEDINGS{shavit95stm,
  author = {Nir Shavit and Dan Touitou},
  title = {Software transactional memory},
  booktitle = {PODC'95},
  year = {1995},
  pages = {204--213},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/224964.224987},
  isbn = {0-89791-710-3},
  keywords = {STM, TM},
  location = {Ottowa, Ontario, Canada},
  owner = {Mathias Payer},
  review = {foundation paper},
  timestamp = {2008.10.16}
}

@INPROCEEDINGS{GC-LOCALITY-SHUF02,
  author = {Yefim Shuf and Manish Gupta and Hubertus Franke and Andrew Appel
	and Jaswinder Pal Singh},
  title = {Creating and preserving locality of java applications at allocation
	and garbage collection times},
  booktitle = {Proceedings of the 17th ACM SIGPLAN conference on Object-Oriented
	Programming, Systems, Languages, and Applications (OOPSLA~2002)},
  year = {2002},
  pages = {13--25},
  doi = {http://doi.acm.org/10.1145/582419.582422},
  isbn = {1-58113-471-1},
  location = {Seattle, Washington, USA}
}

@INPROCEEDINGS{378783,
  author = {Yefim Shuf and Mauricio J. Serrano and Manish Gupta and Jaswinder
	Pal Singh},
  title = {Characterizing the memory behavior of Java workloads: a structured
	view and opportunities for optimizations},
  booktitle = {Proc. of the 2001 ACM SIGMETRICS international conference on Measurement
	and modeling of computer systems (SIGMETRICS~2001)},
  year = {2001},
  pages = {194--205},
  doi = {http://doi.acm.org/10.1145/378420.378783},
  isbn = {1-58113-334-0},
  location = {Cambridge, Massachusetts, United States}
}

@INPROCEEDINGS{HPM-PATH-PROF,
  author = {Alex Shye and Matthew Iyer and Tipp Moseley and David Hodgdon and
	Dan Fay and Vijay Janapa Reddi and Daniel A. Connors},
  title = {Analyis of Path Profiling Information Generated with Performance
	Monitoring Hardware},
  booktitle = {INTERACT '05: Proceedings of the 9th Annual Workshop on Interaction
	between Compilers and Computer Architectures (INTERACT'05)},
  year = {2005},
  pages = {34--43},
  doi = {http://dx.doi.org/10.1109/INTERACT.2005.3},
  isbn = {0-7695-2321-8}
}

@INPROCEEDINGS{Siegwart:COPYGC,
  author = {David Siegwart and Martin Hirzel},
  title = {Improving locality with parallel hierarchical copying GC},
  booktitle = {Proceedings of the 2006 International Symposium on Memory Management
	(ISMM~2006)},
  year = {2006},
  pages = {52--63},
  doi = {http://doi.acm.org/10.1145/1133956.1133964},
  isbn = {1-59593-221-6},
  location = {Ottawa, Ontario, Canada}
}

@INPROCEEDINGS{soares10flexsc,
  author = {Soares, Livio and Stumm, Michael},
  title = {FlexSC: flexible system call scheduling with exception-less system
	calls},
  booktitle = {Proceedings of the 9th USENIX conference on Operating systems design
	and implementation},
  year = {2010},
  series = {OSDI'10},
  pages = {1--8},
  address = {Berkeley, CA, USA},
  abstract = {For the past 30+ years, system calls have been the de facto interface
	used by applications to request services from the operating system
	kernel. System calls have almost universally been implemented as
	a synchronous mechanism, where a special processor instruction is
	used to yield userspace execution to the kernel. In the first part
	of this paper, we evaluate the performance impact of traditional
	synchronous system calls on system intensive workloads. We show that
	synchronous system calls negatively affect performance in a significant
	way, primarily because of pipeline flushing and pollution of key
	processor structures (e.g., TLB, data and instruction caches, etc.).


	We propose a new mechanism for applications to request services from
	the operating system kernel: exception-less system calls. They improve
	processor efficiency by enabling flexibility in the scheduling of
	operating system work, which in turn can lead to significantly increased
	temporal and spacial locality of execution in both user and kernel
	space, thus reducing pollution effects on processor structures. Exception-less
	system calls are particularly effective on multicore processors.
	They primarily target highly threaded server applications, such as
	Web servers and database servers.


	We present FlexSC, an implementation of exceptionless system calls
	in the Linux kernel, and an accompanying user-mode thread package
	(FlexSC-Threads), binary compatible with POSIX threads, that translates
	legacy synchronous system calls into exception-less ones transparently
	to applications. We show how FlexSC improves performance of Apache
	by up to 116%, MySQL by up to 40%, and BIND by up to 105% while requiring
	no modifications to the applications.},
  acmid = {1924946},
  location = {Vancouver, BC, Canada},
  numpages = {8},
  owner = {Mathias Payer},
  timestamp = {2011.11.28},
  url = {http://dl.acm.org/citation.cfm?id=1924943.1924946}
}

@INPROCEEDINGS{sovarel05ssym,
  author = {Sovarel, Ana Nora and Evans, David and Paul, Nathanael},
  title = {Where's the {FEEB}? the effectiveness of instruction set randomization},
  booktitle = {SSYM'05: Proc. 14th Conf. on USENIX Security Symposium},
  year = {2005},
  abstract = {Instruction Set Randomization (ISR) has been proposed as a promising
	defense against code injection attacks. It defuses all standard code
	injection attacks since the attacker does not know the instruction
	set of the target machine. A motivated attacker, however, may be
	able to circumvent ISR by determining the randomization key. In this
	paper, we investigate the possibility of a remote attacker successfully
	ascertaining an ISR key using an incremental attack. We introduce
	a strategy for attacking ISR-protected servers, develop and analyze
	two attack variations, and present a technique for packaging a worm
	with a miniature virtual machine that reduces the number of key bytes
	an attacker must acquire to 100. Our attacks can break enough key
	bytes to infect an ISR-protected server in about six minutes. Our
	results provide insights into properties necessary for ISR implementations
	to be secure.},
  acmid = {1251408},
  owner = {Mathias Payer},
  timestamp = {2012.04.18},
  url = {http://dl.acm.org/citation.cfm?id=1251398.1251408}
}

@INPROCEEDINGS{spear09priocontentionmanagement,
  author = {Spear, Michael F. and Dalessandro, Luke and Marathe, Virendra J.
	and Scott, Michael L.},
  title = {A comprehensive strategy for contention management in software transactional
	memory},
  booktitle = {PPoPP '09},
  year = {2009},
  pages = {141--150},
  publisher = {ACM},
  abstract = {In Software Transactional Memory (STM), contention management refers
	to the mechanisms used to ensure forward progress--to avoid livelock
	and starvation, and to promote throughput and fairness. Unfortunately,
	most past approaches to contention management were designed for obstruction-free
	STM frameworks, and impose significant constant-time overheads. Priority-based
	approaches in particular typically require that reads be visible
	to all transactions, an expensive property that is not easy to support
	in most STM systems.


	In this paper we present a comprehensive strategy for contention management
	via fair resolution of conflicts in an STM with invisible reads.
	Our strategy depends on (1) lazy acquisition of ownership, (2) extendable
	timestamps, and (3) an efficient way to capture both priority and
	conflicts. We introduce two mechanisms--one using Bloom filters,
	the other using visible read bits--that implement point (3). These
	mechanisms unify the notions of conflict resolution, inevitability,
	and transaction retry. They are orthogonal to the rest of the contention
	management strategy, and could be used in a wide variety of hardware
	and software TM systems. Experimental evaluation demonstrates that
	the overhead of the mechanisms is low, particularly when conflicts
	are rare, and that our strategy as a whole provides good throughput
	and fairness, including livelock and starvation freedom, even for
	challenging workloads.},
  doi = {http://doi.acm.org/10.1145/1504176.1504199},
  isbn = {978-1-60558-397-6},
  keywords = {STM, TM, Contention Management},
  location = {Raleigh, NC, USA},
  owner = {Mathias Payer},
  review = {- Lazy Locking (with invisible reads)

	- Hashtable for writes -> rehash on 33% load

	- priority based contention management},
  timestamp = {2009.05.31}
}

@INPROCEEDINGS{ringstm08,
  author = {Spear, Michael F. and Michael, Maged M. and von Praun, Christoph},
  title = {{RingSTM}: scalable transactions with a single atomic instruction},
  booktitle = {SPAA'08},
  year = {2008},
  pages = {275--284},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1378533.1378583},
  isbn = {978-1-59593-973-9},
  keywords = {STM, TM, RingSTM},
  location = {Munich, Germany},
  owner = {Mathias Payer},
  timestamp = {2010.01.13}
}

@INPROCEEDINGS{fast09spillane,
  author = {Spillane, Richard P. and Gaikwad, Sachin and Chinni, Manjunath and
	Zadok, Erez and Wright, Charles P.},
  title = {Enabling transactional file access via lightweight kernel extensions},
  booktitle = {FAST'09: Proc. 7th Conf. on File and storage technologies},
  year = {2009},
  pages = {29--42},
  abstract = {Transactions offer a powerful data-access method used in many databases
	today trough a specialized query API. User applications, however,
	use a different file-access API (POSIX) which does not offer transactional
	guarantees. Applications using transactions can become simpler, smaller,
	easier to develop and maintain, more reliable, and more secure. We
	explored several techniques how to provide transactional file access
	with minimal impact on existing programs. Our first prototype was
	a standalone kernel component within the Linux kernel, but it complicated
	the kernel considerably and duplicated some of Linux's existing facilities.
	Our second prototype was all in user level, and while it was easier
	to develop, it suffered from high overheads. In this paper we describe
	our latest prototype and the evolution that led to it. We implemented
	a transactional file API inside the Linux kernel which integrates
	easily and seamlessly with existing kernel facilities. This design
	is easier to maintain, simpler to integrate into existing OSs, and
	efficient. We evaluated our prototype and other systems under a variety
	of workloads. We demonstrate that our prototype's performance is
	better than comparable systems and comes close to the theoretical
	lower bound for a log-based transaction manager.},
  acmid = {1525911},
  location = {San Francisco, California},
  numpages = {14},
  owner = {Mathias Payer},
  timestamp = {2011.11.02},
  url = {http://dl.acm.org/citation.cfm?id=1525908.1525911}
}

@INPROCEEDINGS{p4perfmon,
  author = {Brinkley Sprunt},
  title = {Pentium 4 Performance Monitoring Features},
  booktitle = {IEEE Micro},
  year = {July--August 2002},
  pages = {72--82}
}

@INPROCEEDINGS{sreedhar95linear,
  author = {Vugranam C. Sreedhar and Guang R. Gao},
  title = {A Linear Time Algorithm for Placing $\phi$-nodes},
  booktitle = {Conference Record of {POPL} '95: 22nd {ACM} {SIGPLAN}-{SIGACT} Symposium
	on Principles of Programming Languages},
  year = {1995},
  pages = {62--73},
  url = {citeseer.nj.nec.com/sreedhar95linear.html}
}

@TECHREPORT{sreedhar94incrementalphinode,
  author = {Vugranam C. Sreedhar and Guang R. Gao and Yong-fong Lee},
  title = {An Efficient Incremental Algorithm for Maintaining Dominator Trees
	and its Application to $\phi$-Nodes Update},
  institution = {McGill University},
  year = {May 1994},
  type = {{ACAPS} Technical Memo 77}
}

@ARTICLE{sreedhar97incremental,
  author = {Vugranam C. Sreedhar and Guang R. Gao and Yong-Fong Lee},
  title = {Incremental Computation of Dominator Trees},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {1997},
  volume = {19},
  pages = {239--252},
  number = {2},
  month = {March},
  url = {citeseer.nj.nec.com/sreedhar95incremental.html}
}

@ARTICLE{hdtrans07sridhar,
  author = {Swaroop Sridhar and Jonathan S. Shapiro and Prashanth P. Bungale},
  title = {{HDTrans}: a low-overhead dynamic translator},
  journal = {SIGARCH Comput. Archit. News},
  year = {2007},
  volume = {35},
  pages = {135--140},
  number = {1},
  abstract = {Dynamic translation is a general purpose tool used for instrumenting
	programs at run time. Many current translators perform substantial
	rewriting during translation in an attempt to reduce execution time.
	When dynamic translation is used as a ubiquitous policy enforcement
	mechanism, the majority of program executions have no dominating
	inner loop that can be used to amortize the cost of translation.
	Even under more favorable usage assumptions, our measurements show
	that such optimizations offer no significant benefit in most cases.
	A simpler, more maintainable, adaptable, and smaller translator may
	be preferable to more complicated designs.


	In this paper, we present HDTrans, a light-weight IA-32 to IA-32 binary
	translation system that uses some simple and effective translation
	techniques in combination with established trace linearization and
	code caching optimizations. We also present an evaluation of translation
	overhead under non-ideal conditions, showing that conventional benchmarks
	do not provide a good prediction of translation overhead when used
	pervasively.


	A further contribution of this paper is an analysis of the effectiveness
	of post-compile static pre-translation techniques for overhead reduction.
	Our results indicate that static pre-translation is effective only
	when expensive instrumentation or optimization is performed, and
	that efficient reload of pre-translated code incurs a substantial
	execution-time penalty.},
  doi = {http://doi.acm.org/10.1145/1241601.1241602},
  issn = {0163-5964},
  keywords = {binary translation},
  owner = {Mathias Payer},
  review = {simple binary translator without too many optimizations


	table based translation


	no high level IR


	print -> 1},
  timestamp = {2007.10.05}
}

@INPROCEEDINGS{hdtransvee,
  author = {Swaroop Sridhar and Jonathan S. Shapiro and Eric Northup and Prashanth
	P. Bungale},
  title = {{HDTrans}: an open source, low-level dynamic instrumentation system},
  booktitle = {VEE'06},
  doi = {http://doi.acm.org/10.1145/1134760.1220166},
  isbn = {1-59593-332-6},
  keywords = {binary translation system},
  location = {Ottawa, Ontario, Canada},
  owner = {Mathias Payer},
  review = {simple binary translator
	return caching, indirection handled, no changes of stack, code buffer
	print -> 1},
  timestamp = {2007.10.05}
}

@BOOK{national1996statistical,
  title = {{National Research Council (U.S.). Panel on Statistical Methods in Software Engineering: Statistical Software Engineering}},
  publisher = {National Academy Press},
  year = {1996},
  author = {Daryl Pregibon and Herman Chernoff and Bill Curtis and Siddhartha R. Dalal and Gloria J. Davis and Richard A. DeMillo and Stephen G. Eick and Bev Littlewood and Chitoor V. Ramamoorthy},
  isbn = {9780309053440},
  lccn = {95071101},
  owner = {gannimo},
  review = {Nasa case study,
	number of bugs per lines of code
	number of defects per lines of code
	http://www.nap.edu/catalog.php?record_id=5018},
  timestamp = {2011.06.13},
  url = {http://books.google.com/books?id=cjabpNouR1YC}
}

@TECHREPORT{MMTk2006,
  author = {Steve Blackburn, Robin Garner, Daniel Frampton},
  title = {MMTk: The Memory Management Toolkit},
  institution = {IBM Research},
  year = {2006},
  file = {mmtk-guide.pdf:http\://cs.anu.edu.au/people/Robin.Garner/mmtk-guide.pdf:PDF},
  keywords = {MMTk, Jikes, Memory Management, Implementation},
  owner = {Mathias Payer},
  review = {print -> 1},
  timestamp = {2007.10.04}
}

@INPROCEEDINGS{stichnoth97codecomposition,
  author = {James M. Stichnoth and Thomas R. Gross},
  title = {Code Composition as an Implementation Language for Compilers},
  booktitle = {DSL},
  year = {1997},
  pages = {119-132},
  abstract = { Code composition is an effective technique for a compiler to implement
	complex high-level operations. The developer (i.e., the language
	designer or compiler writer) provides building blocks consisting
	of sequences of code written in, e.g., C, that are combined by a
	composition system to generate the code for such a high-level operation.
	The composition system can include optimizations not commonly found
	in compilers; e.g., it can specialize the code sequences based on
	loop nesting depth or procedure parameters. We describe a composition
	system, Catacomb, and illustrate its use for mapping array operations
	onto a parallel system. },
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://www.usenix.org/publications/library/proceedings/dsl97/stichnoth.html}
}

@ARTICLE{stoyle07toplas,
  author = {Stoyle, Gareth and Hicks, Michael and Bierman, Gavin and Sewell,
	Peter and Neamtiu, Iulian},
  title = {Mutatis Mutandis: Safe and predictable dynamic software updating},
  journal = {TOPLAS'07},
  abstract = {This article presents Proteus, a core calculus that models dynamic
	software updating, a service for fixing bugs and adding features
	to a running program. Proteus permits a program's type structure
	to change dynamically but guarantees the updated program remains
	type-correct by ensuring a property we call con-freeness. We show
	how con-freeness can be enforced dynamically, and how it can be approximated
	via a novel static analysis. This analysis can be used to assess
	the implications of a program's structure on future updates in order
	to make update success more predictable. We have implemented Proteus
	for C, and briefly discuss our implementation which we have tested
	on several well-known programs.},
  doi = {http://doi.acm.org/10.1145/1255450.1255455},
  issn = {0164-0925},
  keywords = {Dynamic software updating, Proteus, capability, type inference, updateability
	analysis},
  owner = {Mathias Payer},
  timestamp = {2012.01.27},
  url = {http://doi.acm.org/10.1145/1255450.1255455}
}

@INPROCEEDINGS{DYNAMICOPT-IBMJIT-01,
  author = {Toshio Suganuma and Toshiaki Yasue and Motohiro Kawahito and Hideaki
	Komatsu and Toshio Nakatani},
  title = {A Dynamic Optimization Framework for a {Java} Just-In-Time Compiler},
  booktitle = {Proc. of the {ACM} Conf. on Object Oriented Programming, Systems,
	Languages, and Applications (OOPLSA~2001)},
  year = {2001},
  pages = {180--195},
  doi = {http://doi.acm.org/10.1145/504282.504296},
  isbn = {1-58113-335-9},
  location = {Tampa Bay, FL, USA}
}

@INPROCEEDINGS{sweeney04hpm,
  author = {Sweeney, Peter F. and Hauswirth, Matthias and Cahoon, Brendon and
	Cheng, Perry and Diwan, Amer and Grove, David and Hind, Michael},
  title = {Using hardware performance monitors to understand the behavior of
	java applications},
  booktitle = {VM'04: Proceedings of the 3rd conference on Virtual Machine Research
	And Technology Symposium},
  year = {2004},
  pages = {5--5},
  abstract = {Modern Java programs, such as middleware and application servers,
	include many complex software components. Improving the performance
	of these Java applications requires a better understanding of the
	interactions between the application, virtual machine, operating
	system, and architecture. Hardware performance monitors, which are
	available on most modern processors, provide facilities to obtain
	detailed performance measurements of long-running applications in
	real time. However, interpreting the data collected using hardware
	performance monitors is difficult because of the low-level nature
	of the data.


	We have developed a system, consisting of two components, to alleviate
	the difficulty of interpreting results obtained using hardware performance
	monitors. The first component is an enhanced VM that generates traces
	of hardware performance monitor values while executing Java programs.
	This enhanced VM generates a separate trace for each Java thread
	and CPU combination and thus provides accurate results in a multithreaded
	and multiprocessor environment. The second component is a tool that
	allows users to interactively explore the traces using a graphical
	interface. We implemented our tools in the context of Jikes RVM,
	an open source Java VM, and evaluated it on a POWER4 multiprocessor.
	We demonstrate that our system is effective in uncovering as yet
	unknown performance characteristics and is a first step in exploring
	the reasons behind observed behavior of a Java program.},
  location = {San Jose, California},
  owner = {Mathias Payer},
  review = {Online tracing/profiling and offline analysis

	- data saved to file

	- file read and analyzed},
  timestamp = {2009.05.31}
}

@MISC{JBB2000,
  author = {{The Standard Performance Evaluation Corporation}},
  title = {{SPEC JBB2000} {B}enchmark},
  howpublished = {http://www.spec.org/jbb2000/}
}

@INPROCEEDINGS{timbermont08d4ol,
  author = {Timbermont, Stijn and Adams, Bram and Haupt, Michael},
  title = {Towards a DSAL for object layout in virtual machines},
  booktitle = {DSAL'08: Proc. AOSD workshop on Domain-Specific Aspect Languages},
  year = {2008},
  abstract = { High-level language virtual machine implementations offer a challenging
	domain for modularization, not only because they are inherently complex,
	but also because efï¬ciency is not likely to be traded for modularity.
	The central data structure used throughout the VM, the object layout,
	cannot be succinctly modularised by current aspect technology, as
	provisions for static crosscutting are not ï¬ne-grained enough. This
	position paper motivates the need for a declarative, domain-speciï¬c
	language for handling the tangled object layout concern. Based on
	observations in real-world VM implementations, we propose such a
	language, D4OL. It combines a two-level layout mapping, constraints
	and an engine to divide responsibilities between VM component and
	VM developers. We consider a domain-speciï¬c language like D4OL a
	necessary complement to behavioural aspect languages in order to
	modularize VM implementations. },
  acmid = {1404932},
  articleno = {5},
  doi = {http://doi.acm.org/10.1145/1404927.1404932},
  isbn = {978-1-60558-146-0},
  keywords = {domain-specific aspect language, object layout, virtual machine},
  location = {Brussels, Belgium},
  numpages = {4},
  url = {http://doi.acm.org/10.1145/1404927.1404932}
}

@TECHREPORT{tsafrir08tr,
  author = {Tsafrir, Dan and Hertz, Tomer and Wagner, David and Da Silva, Dilma},
  title = {Portably Preventing File Race Attacks with User-Mode Path Resolution},
  institution = {IBM T. J. Watson Research Center},
  year = {June 2008},
  number = {RC24572},
  owner = {Mathias Payer},
  timestamp = {2012.01.03}
}

@INPROCEEDINGS{tsafrir08fast,
  author = {Tsafrir, Dan and Hertz, Tomer and Wagner, David and Da Silva, Dilma},
  title = {Portably solving file {TOCTTOU} races with hardness amplification},
  booktitle = {FAST'08: Proc. 6th USENIX Conf. on File and Storage Technologies},
  year = {2008},
  pages = {13:1--13:18},
  abstract = {The file-system API of contemporary systems makes programs vulnerable
	to TOCTTOU (time of check to time of use) race conditions. Existing
	solutions either help users to detect these problems (by pinpointing
	their locations in the code), or prevent the problem altogether (by
	modifying the kernel or its API). The latter alternative is not prevalent,
	and the former is just the first step: programmers must still address
	TOCTTOU flaws within the limits of the existing API with which several
	important tasks can not be accomplished in a portable straightforward
	manner. Recently, Dean and Hu addressed this problem and suggested
	a probabilistic hardness amplification approach that alleviated the
	matter. Alas, shortly after, Borisov et al. responded with an attack
	termed "filesystem maze" that defeated the new approach.


	We begin by noting that mazes constitute a generic way to deterministically
	win many TOCTTOU races (gone are the days when the probability was
	small). In the face of this threat, we (1) develop a new user-level
	defense that can withstand mazes, and (2) show that our method is
	undefeated even by much stronger hypothetical attacks that provide
	the adversary program with ideal conditions to win the race (enjoying
	complete and instantaneo us knowledge about the defending program's
	actions and being able to perfectly synchronize accordingly). The
	fact that our approach is immune to these unrealistic attacks suggests
	it can be used as a simple and portable solution to a large class
	of TOCTTOU vulnerabilities, without requiring modifications to the
	underlying operating system.},
  acmid = {1364826},
  articleno = {13},
  numpages = {18},
  owner = {Mathias Payer},
  review = {Novel API for file related system calls, tocttou safe.},
  timestamp = {2011.05.10},
  url = {http://portal.acm.org/citation.cfm?id=1364813.1364826}
}

@INPROCEEDINGS{tsyrklevich03security,
  author = {Eugene Tsyrklevich and Bennet Yee},
  title = {Dynamic detection and prevention of race conditions in file accesses},
  booktitle = {SSYM'03: Proc. 12th USENIX Security Symp.},
  year = {2003},
  pages = {243--255},
  abstract = {Race conditions in filesystem accesses occur when sequences of filesystem
	operations are not carried out in an isolated manner. Incorrect assumptions
	of filesystem namespace access isolation allow attackers to elevate
	their privileges without authorization by changing the namespace
	bindings. To address this security issue, we propose a mechanism
	for keeping track of all filesystem operations and possible interferences
	that might arise. If a filesystem operation is found to be interfering
	with another operation, it is temporarily suspended allowing the
	first process to access a file object to proceed, thereby reducing
	the size of the time window when a race condition exists. The above
	mechanism is shown to be effective at stopping all realistic filesystem
	race condition attacks known to us with minimal performance overhead.},
  owner = {Mathias Payer},
  review = {Add a kernel module that intercepts specific system calls.


	Pseudo-transactions check the system calls for TOCTTOU attacks.},
  timestamp = {2011.05.10}
}

@INPROCEEDINGS{tullsen:SMT,
  author = {Dean M. Tullsen and Susan J. Eggers and Henry M. Levy},
  title = {Simultaneous multithreading: maximizing on-chip parallelism},
  booktitle = {ISCA '95: Proceedings of the 22nd annual international symposium
	on Computer architecture},
  year = {1995},
  pages = {392--403},
  doi = {http://doi.acm.org/10.1145/223982.224449},
  isbn = {0-89791-698-0},
  location = {S. Margherita Ligure, Italy}
}

@ARTICLE{254184,
  author = {Richard A. Uhlig and Trevor N. Mudge},
  title = {Trace-driven memory simulation: a survey},
  journal = {ACM Comput. Surv.},
  year = {1997},
  volume = {29},
  pages = {128--170},
  number = {2},
  doi = {http://doi.acm.org/10.1145/254180.254184},
  issn = {0360-0300}
}

@INPROCEEDINGS{Ungar:GC,
  author = {David Ungar},
  title = {Generation Scavenging: A non-disruptive high performance storage
	reclamation algorithm},
  booktitle = {SDE 1: Proceedings of the first ACM SIGSOFT/SIGPLAN software engineering
	symposium on Practical software development environments},
  year = {1984},
  pages = {157--167},
  doi = {http://doi.acm.org/10.1145/800020.808261},
  isbn = {0-89791-131-8}
}

@INPROCEEDINGS{uppuluri05sac,
  author = {Uppuluri, Prem and Joshi, Uday and Ray, Arnab},
  title = {Preventing race condition attacks on file-systems},
  booktitle = {SAC'05: Proc. ACM Symposium on Applied computing},
  year = {2005},
  series = {SAC '05},
  pages = {346--353},
  abstract = {Race condition attacks occur when a process performs a sequence of
	operations on a file, under the assumption that the operations are
	being executed "atomically". This can be exploited by a malicious
	process which changes the characteristics of that file between two
	successive operations on it by a victim process, thus, inducing the
	victim process to operate on a modified or diflerent file. In this
	paper we present a practical approach to detect and prevent such
	race condition attacks. We monitor file operations and enforce policies
	which prevent the exploitation of the temporal window between any
	consecutive file operations by a process. Our approach does not rely
	on knowledge of previously known attacks. In addition, our experiments
	on Linux demonstrated that attacks can be detected with false alarms
	of less than 3% with performance overheads less than 8% of the processes
	execution time.},
  acmid = {1066758},
  doi = {http://doi.acm.org/10.1145/1066677.1066758},
  isbn = {1-58113-964-0},
  keywords = {race conditions, security, system calls},
  numpages = {8},
  owner = {Mathias Payer},
  timestamp = {2011.05.10},
  url = {http://doi.acm.org/10.1145/1066677.1066758}
}

@ARTICLE{CVE-2007-4060,
  author = {vade79/v9},
  title = {{CVE-2007-4060}: {CoreHTTPD} 0.5.3alpha (httpd) Remote Buffer Overflow
	Exploit},
  journal = {\url{http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4060}},
  year = {2007},
  owner = {gannimo},
  timestamp = {2012.01.26}
}

@MISC{execshield,
  author = {Arjan van de Ven and Ingo Molnar},
  year = {2004},
  title = {Exec Shield},
  howpublished = {\url{https://www.redhat.com/f/pdf/rhel/WHP0006US_Execshield.pdf}},
  owner = {Mathias Payer},
  timestamp = {2011.05.10}
}

@ARTICLE{vera04,
  author = {Xavier Vera and Nerina Bermudo and Josep Llosa and Antonio Gonz\'alez},
  title = {A fast and accurate framework to analyze and optimize cache memory
	behavior},
  journal = {ACM Trans. Program. Lang. Syst.},
  year = {2004},
  volume = {26},
  pages = {263--300},
  number = {2},
  doi = {http://doi.acm.org/10.1145/973097.973099},
  issn = {0164-0925}
}

@INPROCEEDINGS{viega00its4,
  author = {John Viega and J.T. Bloch and Tadayoshi Kohno and Gary McGraw},
  title = {{ITS4:} A Static Vulnerability Scanner for {C} and {C++} Code},
  booktitle = {ACSAC'00: Ann. Comput. Security Applications Conf.},
  year = {2000},
  abstract = {We describe ITS4, a tool for statically scanning security-critical
	C source code for vulnerabilities. Compared to other approaches,
	our scanning technique stakes out a new middle ground between accuracy
	and efficiency. This method is efficient enough to offer real-time
	feedback to developers during coding while producing few false negatives.
	Unlike other techniques, our method is also simple enough to scan
	C++ code despite the complexities inherent in the language. Using
	ITS4 we found new remotelyexploitable vulnerabilities in a widely
	distributed software package as well as in a major piece of e-commerce
	software. The ITS4 source distribution is available at http: //www.rstcorp.com/its4.},
  owner = {Mathias Payer},
  review = {Static scanning of source code for security problems. Uses simple
	pattern matching, no lexical checks of the source code.},
  timestamp = {2011.05.09}
}

@MISC{Xorg-CVE2011-4029,
  author = {vladz},
  year = {2011},
  title = {{Xorg} file permission change vulnerability ({CVE}-2011-4029)},
  howpublished = {\url{http://vladz.devzero.fr/Xorg-CVE-2011-4029.txt}},
  owner = {Mathias Payer},
  timestamp = {2011.11.02}
}

@INPROCEEDINGS{93wahbe,
  author = {Wahbe,, Robert and Lucco,, Steven and Anderson,, Thomas E. and Graham,,
	Susan L.},
  title = {Efficient software-based fault isolation},
  booktitle = {SOSP'93},
  abstract = {One way to provide fault isolation among cooperating software modules
	is to place each in its own address space. However, for tightly-coupled
	modules, this solution incurs prohibitive context switch overhead.
	In this paper, we present a software approach to implementing fault
	isolation within a single address space.Our approach has two parts.
	First, we load the code and data for a distrusted module into its
	own fault do main, a logically separate portion of the application's
	address space. Second, we modify the object code of a distrusted
	module to prevent it from writing or jumping to an address outside
	its fault domain. Both these software operations are portable and
	programming language independent.Our approach poses a tradeoff relative
	to hardware fault isolation: substantially faster communication between
	fault domains, at a cost of slightly increased execution time for
	distrusted modules. We demonstrate that for frequently communicating
	modules, implementing fault isolation in software rather than hardware
	can substantially improve end-to-end application performance.},
  doi = {http://doi.acm.org/10.1145/168619.168635},
  isbn = {0-89791-632-8},
  location = {Asheville, North Carolina, United States},
  owner = {Mathias Payer},
  review = {Fault Isolation through Segmentation -> Checks unsafe instructions

	Segment Matching -> Add instructions that check for correct segments

	Addr Sandboxing -> Limit range of ptrs/addresses through setting of
	specific bits},
  timestamp = {2009.05.04}
}

@INPROCEEDINGS{wall:limitsOfILparallelism,
  author = {David W. Wall},
  title = {Limits of instruction-level parallelism},
  booktitle = {ASPLOS-IV: Proceedings of the fourth international conference on
	Architectural support for programming languages and operating systems},
  year = {1991},
  pages = {176--188},
  doi = {http://doi.acm.org/10.1145/106972.106991},
  isbn = {0-89791-380-9},
  location = {Santa Clara, California, United States}
}

@ARTICLE{wang07atomicc,
  author = {Wang, Cheng and Chen, Wei-Yu and Wu, Youfeng and Saha, Bratin and
	Adl-Tabatabai, Ali-Reza},
  title = {Code Generation and Optimization for Transactional Memory Constructs
	in an Unmanaged Language},
  journal = {Code Generation and Optimization, 2007. CGO '07. International Symposium
	on},
  year = {2007},
  pages = {34-48},
  month = {March},
  abstract = {Transactional memory offers significant advantages for concurrency
	control compared to locks. This paper presents the design and implementation
	of transactional memory constructs in an unmanaged language. Unmanaged
	languages pose a unique set of challenges to transactional memory
	constructs - for example, lack of type and memory safety, use of
	function pointers, aliasing of local variables, and others. This
	paper describes novel compiler and runtime mechanisms that address
	these challenges and optimize the performance of transactions in
	an unmanaged environment. We have implemented these mechanisms in
	a production-quality C compiler and a high-performance software transactional
	memory runtime. We measure the effectiveness of these optimizations
	and compare the performance of lock-based versus transaction-based
	programming on a set of concurrent data structures and the SPLASH-2
	benchmark suite. On a 16 processor SMP system, the transaction-based
	version of the SPLASH-2 benchmarks scales much better than the coarse-grain
	locking version and performs comparably to the fine-grain locking
	version. Compiler optimizations significantly reduce the overheads
	of transactional memory so that, on a single thread, the transaction-based
	version incurs only about 6.4% overhead compared to the lock-based
	version for the SPLASH-2 benchmark suite. Thus, our system is the
	first to demonstrate that transactions integrate well with an unmanaged
	language, and can perform as well as fine-grain locking while providing
	the programming ease of coarse-grain locking even on an unmanaged
	environment},
  doi = {10.1109/CGO.2007.4},
  keywords = {STM, TM, Splash2, Low level},
  owner = {Mathias Payer},
  review = {atomic sections for c/c++ with optimizations to remove unneeded calls
	into the stm


	for the Intel compiler},
  timestamp = {2008.11.13}
}

@INPROCEEDINGS{warg:ModuleLevelParallelism,
  author = {Fredrik Warg and Per Stenstroem},
  title = {Limits on Speculative Module-Level Parallelism in Imperative and
	Object-Oriented Programs on CMP Platforms},
  booktitle = {PACT '01: Proceedings of the 2001 International Conference on Parallel
	Architectures and Compilation Techniques},
  year = {2001},
  pages = {221--230},
  abstract = {This paper considers program modules, e.g. procedures,

	functions, and methods as the basic method to exploit speculative

	parallelism in existing codes. We analyze how much

	inherent and exploitable parallelism exist in a set of C and

	Java programs on a set of chip-multiprocessor architecture

	models, and identify what inherent program features,

	as well as architectural deficiencies, that limit the speedup.

	Our data complement previous limit studies by indicating

	that the programming style -- object-oriented versus imperative

	-- does not seem to have any noticeable impact

	on the achievable speedup. Further, we show that as few

	as eight processors are enough to exploit all of the inherent

	parallelism. However, memory-level data dependence

	resolution and thread management mechanisms of recent

	CMP proposals may impose overheads that severely limit

	the speedup obtained.},
  isbn = {0-7695-1363-8},
  keywords = {limits, speculation, specmt, cmp platforms},
  owner = {Mathias Payer},
  review = {print -> 1},
  timestamp = {2007.10.04},
  url = {http://citeseer.ist.psu.edu/warg01limits.html}
}

@INPROCEEDINGS{watson07tocttou,
  author = {Watson, Robert N.},
  title = {Exploiting Concurrency Vulnerabilities in System Call Wrappers},
  booktitle = {WOOT'07 First USENIX Workshop on Offensive Technologies},
  organization = {USENIX},
  abstract = {System call interposition allows the kernel security model to be extended.
	However, when combined with current operating systems, it is open
	to concurrency vulnerabilities leading to privilege escalation and
	audit bypass. We discuss the theory and practice of system call wrapper
	concurrency vulnerabilities, and demonstrate exploit technques against
	GSWTK, Systrace, and CerbNG.},
  citeulike-article-id = {1664862},
  citeulike-linkout-0 = {http://www.watson.org/\~{}robert/2007woot/2007usenixwoot-exploitingconcurrency.pdf},
  citeulike-linkout-1 = {http://www.watson.org/\~{}robert/2007woot/20070806-woot-concurrency.pdf},
  citeulike-linkout-2 = {http://www.watson.org/\~{}robert/2007woot/},
  keywords = {firewall, multithreading, operating-systems, security},
  owner = {Mathias Payer},
  posted-at = {2007-09-17 08:10:13},
  priority = {4},
  review = {TOCTTOU - time of check to time of use

	TOATTOU - time of audit to time of use

	TORTTOU - time of replacement to time of use


	different concurrency related attacks agains system call authorization
	systems / syscall checkers


	These attacks only work if malicious code is already running on the
	system.},
  timestamp = {2010.09.08},
  url = {http://www.watson.org/\~{}robert/2007woot/2007usenixwoot-exploitingconcurrency.pdf}
}

@INPROCEEDINGS{usenix10watson,
  author = {Robert N. M. Watson and Jonathan Anderson and Ben Laurie and Kris
	Kennaway},
  title = {{Capsicum}: Practical Capabilities for {UNIX}},
  booktitle = {SSYM'10: 19th USENIX Security Symp.},
  year = {2010},
  pages = {29-46},
  abstract = {Capsicum is a lightweight operating system capability and sandbox
	framework planned for inclusion in FreeBSD 9. Capsicum extends, rather
	than replaces, UNIX APIs, providing new kernel primitives (sandboxed
	capability mode and capabilities) and a userspace sandbox API. These
	tools support compartmentalisation of monolithic UNIX applications
	into logical applications, an increasingly common goal supported
	poorly by discretionary and mandatory access control. We demonstrate
	our approach by adapting core FreeBSD utilities and Googleâs Chromium
	web browser to use Capsicum primitives, and compare the complexity
	and robustness of Capsicum with other sandboxing techniques.},
  ee = {http://www.usenix.org/events/sec10/tech/full_papers/Watson.pdf},
  owner = {Mathias Payer},
  review = {Capabilities for Unix (FreeBSD), like secmode with limited number
	of system calls that are allowed


	Similar to Ostia, some system call delegation framework and marshalling
	is needed to execute arbitrary functions.},
  timestamp = {2011.05.05}
}

@INPROCEEDINGS{wei06issse,
  author = {Wei, Jinpeng and Pu, Calton},
  title = {A methodical defense against {TOCTTOU} attacks: the {EDGI} approach},
  booktitle = {ISSSE'06: IEEE Int'l Symp. on Secure Software Engineering},
  year = {2006},
  abstract = {TOCTTOU is a challenging and significant problem, involving two-step
	(check and use) file object access by a victim process and simultaneously
	an attacker access to the same file object in-between the two steps.
	We describe a model-based, event-driven defense mechanism (called
	EDGI), which prevents such attacks by stopping the second process
	in-between the two steps. Our main contribution is the systematic
	design and implementation of EDGI defense and its evaluation. EDGI
	has no false negatives

	and very few false positives. It works without changing application
	code or API. A Linux kernel implementation shows the practicality
	of the EDGI defense, and an experimental evaluation shows low additional
	overhead on representative workloads.},
  owner = {Mathias Payer},
  timestamp = {2011.05.10}
}

@INPROCEEDINGS{wei05fast,
  author = {Wei, Jinpeng and Pu, Calton},
  title = {{TOCTTOU} vulnerabilities in {UNIX}-style file systems: an anatomical
	study},
  booktitle = {FAST'05: Proc. 4th Conf. USENIX Conf. File and Storage Technologies},
  year = {2005},
  pages = {12--12},
  abstract = {Due to their non-deterministic nature, Time of Check To Time of Use
	(TOCTTOU) vulnerabilities in Unix-style file systems (e.g., Linux)
	are difficult to find and prevent. We describe a comprehensive model
	of TOCTTOU vulnerabilities, enumerating 224 file system call pairs
	that may lead to successful TOCTTOU attacks. Based on this model,
	we built kernel monitoring tools that confirmed known vulnerabilities
	and discovered new ones (in often-used system utilities such as rpm,
	vi, and emacs). We evaluated the probability of successfully exploiting
	these newly discovered vulnerabilities and analyzed in detail the
	system events during such attacks. Our performance evaluation shows
	that the dynamic monitoring of system calls introduces non-negligible
	overhead in microbenchmark of those file system calls, but their
	impact on application benchmarks such as Andrew and PostMark is only
	a few percent.},
  acmid = {1251040},
  keywords = {race detection},
  numpages = {1},
  owner = {Mathias Payer},
  review = {Enumerate a list of all system calls, dynamic TOCTTOU detection.


	Dynamic approach, but only check pairs of system calls. Kernel based.},
  timestamp = {2011.05.09},
  url = {http://portal.acm.org/citation.cfm?id=1251028.1251040}
}

@INPROCEEDINGS{mojo,
  author = {Wen-Ke Chen, Sorin Lerner, Ronnie Chaiken and David M. Gillies},
  title = {Mojo: A Dynamic Optimization System},
  booktitle = {ACM Workshop Feedback-directed Dyn. Opt. (FDDO-3)},
  year = {2000},
  owner = {Mathias Payer},
  review = {no optimizations

	small code cache

	thread support},
  timestamp = {2008.09.01}
}

@ARTICLE{williams09sp,
  author = {Daniel Williams and Wei Hu and Jack W. Davidson and Jason D. Hiser
	and John C. Knight and Anh Nguyen-Tuong},
  title = {Security through Diversity: Leveraging Virtual Machine Technology},
  journal = {IEEE Security and Privacy},
  year = {2009},
  volume = {7},
  pages = {26-33},
  abstract = {Biologists have long recognized the dangers of the lack of diversity
	or monocultures in biological systems. Recently, it has been noted
	that much of the fragility of our networked computing systems can
	be attributed to the lack of diversity or monoculture of our software
	systems. The problem is severe. Because it is virtually inevitable
	that software will ship with flaws, our software monoculture leaves
	systems open to large-scale attacks by knowledgeable adversaries.
	Inspired by the resilience of diverse biological systems, the authors
	developed the Genesis Software Development Toolchain. An innovative
	aspect of Genesis is the use of an application-level virtual machine
	technology that enables the application of diversity transforms at
	any point in the software toolchain. Using Genesis, they authors
	demonstrated that diversity, when judiciously applied, is a practical
	and effective defense against two widely used types of attacksâreturn-to-libc
	and code injection.},
  address = {Los Alamitos, CA, USA},
  doi = {http://doi.ieeecomputersociety.org/10.1109/MSP.2009.18},
  issn = {1540-7993},
  owner = {Mathias Payer},
  publisher = {IEEE Computer Society},
  timestamp = {2012.04.18}
}

@INPROCEEDINGS{wolf91,
  author = {M. E. Wolf and M. S. Lam},
  title = {A data locality optimizing algorithm},
  booktitle = {Proc. of the ACM SIGPLAN '91 Conference on Programming Language Design
	and Implementation (PLDI~1991)},
  year = {1991},
  volume = {26},
  number = {6},
  pages = {30--44},
  month = jun,
  journal = {SIGPLAN Notices}
}

@BOOK{wolfe96,
  title = {High Performance Compilers for Parallel Computing},
  publisher = {Addison-Wesly Publishing Co.},
  year = {1996},
  author = {Michael Wolfe}
}

@INPROCEEDINGS{lsm02wright,
  author = {Wright, Chris and Cowan, Crispin and Smalley, Stephen and Morris,
	James and Kroah-Hartman, Greg},
  title = {Linux Security Modules: General Security Support for the Linux Kernel},
  booktitle = {SSYM'02: Proc. 11th USENIX Security Symp.},
  year = {2002},
  abstract = {The access control mechanisms of existing mainstream operating systems
	are inadequate to provide strong system security. Enhanced access
	control mechanisms have failed to win acceptance into mainstream
	operating systems due in part to a lack of consensus within the security
	community on the right solution. Since general-purpose operating
	systems must satisfy a wide range of user requirements, any access
	control mechanism integrated into such a system must be capable of
	supporting many different access control models. The Linux Security
	Modules (LSM) project has developed a lightweight, general purpose,
	access control framework for the mainstream Linux kernel that enables
	many different access control models to be implemented as loadable
	kernel modules. A number of existing enhanced access control implementations,
	including Linux capabilities, Security-Enhanced Linux (SELinux),
	and Domain and Type Enforcement (DTE), have already been adapted
	to use the LSM framework. This paper presents the design and implementation
	of LSM and discusses the challenges in providing a truly general
	solution that minimally impacts the Linux kernel.},
  isbn = {1-931971-00-5},
  owner = {Mathias Payer},
  timestamp = {2010.10.29}
}

@ARTICLE{wright07tos,
  author = {Wright, Charles P. and Spillane, Richard and Sivathanu, Gopalan and
	Zadok, Erez},
  title = {Extending {ACID} semantics to the file system},
  journal = {Trans. Storage},
  year = {2007},
  volume = {3},
  month = {June},
  abstract = {An organization's data is often its most valuable asset, but today's
	file systems provide few facilities to ensure its safety. Databases,
	on the other hand, have long provided transactions. Transactions
	are useful because they provide atomicity, consistency, isolation,
	and durability (ACID). Many applications could make use of these
	semantics, but databases have a wide variety of nonstandard interfaces.
	For example, applications like mail servers currently perform elaborate
	error handling to ensure atomicity and consistency, because it is
	easier than using a DBMS. A transaction-oriented programming model
	eliminates complex error-handling code because failed operations
	can simply be aborted without side effects. We have designed a file
	system that exports ACID transactions to user-level applications,
	while preserving the ubiquitous and convenient POSIX interface. In
	our prototype ACID file system, called Amino, updated applications
	can protect arbitrary sequences of system calls within a transaction.
	Unmodified applications operate without any changes, but each system
	call is transaction protected. We also built a recoverable memory
	library with support for nested transactions to allow applications
	to keep their in-memory data structures consistent with the file
	system. Our performance evaluation shows that ACID semantics can
	be added to applications with acceptable overheads. When Amino adds
	atomicity, consistency, and isolation functionality to an application,
	it performs close to Ext3. Amino achieves durability up to 46% faster
	than Ext3, thanks to improved locality.},
  acmid = {1242521},
  articleno = {4},
  doi = {http://doi.acm.org/10.1145/1242520.1242521},
  issn = {1553-3077},
  issue = {2},
  keywords = {File system transactions, databases, file systems, ptrace monitors,
	recoverable memory},
  owner = {Mathias Payer},
  publisher = {ACM},
  timestamp = {2011.05.10},
  url = {http://doi.acm.org/10.1145/1242520.1242521}
}

@INPROCEEDINGS{1267928,
  author = {Gala Yadgar and Michael Factor and Assaf Schuster},
  title = {Karma: know-it-all replacement for a multilevel cache},
  booktitle = {FAST'07: Proc. 5th USENIX Conf. on File and Storage Technologies},
  year = {2007},
  pages = {25--25},
  abstract = {Multilevel caching, common in many storage configurations, introduces
	new challenges to traditional cache management: data must be kept
	in the appropriate cache and replication avoided across the various
	cache levels. Some existing solutions focus on avoiding replication
	across the levels of the hierarchy, working well without information
	about temporal locality-information missing at all but the highest
	level of the hierarchy. Others use application hints to influence
	cache contents.


	We present Karma, a global non-centralized, dynamic and informed management
	policy for multiple levels of cache. Karma leverages application
	hints to make informed allocation and replacement decisions in all
	cache levels, preserving exclusive caching and adjusting to changes
	in access patterns. We show the superiority of Karma through comparison
	to existing solutions including LRU, 2Q, ARC, MultiQ, LRU-SP, and
	Demote, demonstrating better cache performance than all other solutions
	and up to 85% better performance than LRU on representative workloads.},
  location = {San Jose, CA},
  owner = {Mathias Payer},
  review = {Multilevel-Cache Hierarchies

	Disk(n)->Cache(n-1) -> ... -> Cache(2) -> Cache(1)


	Instrumented programs for better Cache performance


	print -> 1},
  timestamp = {2007.10.05},
  url = {http://portal.acm.org/citation.cfm?id=1267903.1267928}
}

@INPROCEEDINGS{nativeclient,
  author = {Bennet Yee and David Sehr and Gregory Dardyk and J. Bradley Chen
	and Robert Muth and Tavis Ormandy and Shiki Okasaka and Neha Narula
	and Nicholas Fullagar},
  title = {Native Client: A Sandbox for Portable, Untrusted x86 Native Code},
  booktitle = {IEEE S\&P'09},
  abstract = {This paper describes the design, implementation and evaluation of
	Native Client, a sandbox for untrusted x86 native code. Native Client
	aims to give browser-based applications the computational performance
	of native applications without compromising safety. Native Client
	uses software fault isolation and a secure runtime to direct system
	interaction and side effects through interfaces managed by Native
	Client. Native Client provides operating system portability for binary
	code while supporting performance-oriented features generally absent
	from web application programming environments, such as thread support,
	instruction set extensions such as SSE, and use of compiler intrinsics
	and hand-coded assembler. We combine these properties in an open
	architecture that encourages community review and 3rd-party tools.},
  doi = {http://doi.ieeecomputersociety.org/10.1109/SP.2009.25},
  issn = {1081-6011},
  owner = {Mathias Payer},
  review = {+ Limit syscalls -> only subset (brk, threading, files allowed)

	+ chroot -> stay in guard

	+ 'safe' / guard BT code (far calls & segments needed)


	=> use changed binaries


	Folder BT},
  timestamp = {2009.09.09}
}

@INPROCEEDINGS{adaptTSTM08,
  author = {Yoo, Richard M. and Lee, Hsien-Hsin S.},
  title = {Adaptive transaction scheduling for transactional memory systems},
  booktitle = {SPAA'08},
  year = {2008},
  pages = {169--178},
  publisher = {ACM},
  abstract = {Transactional memory systems are expected to enable parallel programming
	at lower programming complexity, while delivering improved performance
	over traditional lock-based systems. Nonetheless, there are certain
	situations where transactional memory systems could actually perform
	worse. Transactional memory systems can outperform locks only when
	the executing workloads contain sufficient parallelism. When the
	workload lacks inherent parallelism, launching excessive transactions
	can adversely degrade performance. These situations are likely to
	become dominant in future workloads when large-scale transactions
	are frequently executed. In this paper, we propose a new paradigm
	called adaptive transaction scheduling to address this issue. Based
	on the parallelism feedback from applications, our adaptive transaction
	scheduler dynamically dispatches and controls the number of concurrently
	executing transactions. In our case study, we show that our low-cost
	mechanism not only guarantees that hardware transactional memory
	systems perform no worse than a single global lock, but also significantly
	improves performance for both hardware and software transactional
	memory systems.},
  doi = {http://doi.acm.org/10.1145/1378533.1378564},
  isbn = {978-1-59593-973-9},
  keywords = {TM, STM,},
  location = {Munich, Germany},
  owner = {Mathias Payer},
  review = {object based tm

	adaptive scheduling.


	if there is high contention then transactions are queued and number
	of parallel threads is limited (locking and waiting for contented
	threads)},
  timestamp = {2010.01.12}
}

@ARTICLE{ziarek08javastm,
  author = {Lukasz Ziarek and Adam Welc and Ali-Reza Adl-Tabatabai and Vijay
	Menon and Tatiana Shpeisman and Suresh Jagannathan},
  title = {A Uniform Transactional Execution Environment for Java},
  journal = {ECOOP 2008 â Object-Oriented Programming},
  year = {2008},
  pages = {129--154},
  abstract = {Transactional memory (TM) has recently emerged as an effective tool
	for extracting fine-grain parallelism from declarative critical sections.
	In order to make STM systems practical, significant effort has been
	made to integrate transactions intoexisting programming languages.
	Unfortunately, existing approaches fail to provide a simple implementation
	that permits lock-basedand transaction-based abstractions to coexist
	seamlessly. Because of the fundamental semantic differences between
	locks andtransactions, legacy applications or libraries written using
	locks can not be transparently used within atomic regions. Toaddress
	these shortcomings, we implement a uniform transactional execution
	environment for Java programs in which transactionscan be integrated
	with more traditional concurrency control constructs. Programmers
	can run arbitrary programs that utilizetraditional mutual-exclusion-based
	programming techniques, execute new programs written with explicit
	transactional constructs,and freely combine abstractions that use
	both coding styles.},
  description = {SpringerLink - Buchkapitel},
  keywords = {Java PhD Proposal, TM, STM},
  owner = {Mathias Payer},
  review = {Transform mutual exclusive sections (locks) into transactions.


	Fallback for I/O threads, special mutual exclusive paradigms that
	cannob be expressed with transactions.


	Timeout -> use locks as backup.


	Clever strategy based on multiple readers, single writers to synchronize
	lock based fallback and transactional approach.},
  timestamp = {2008.11.13},
  url = {http://dx.doi.org/10.1007/978-3-540-70592-5_7}
}

@INPROCEEDINGS{pact10bartokstm,
  author = {Zyulkyarov, Ferad and Stipic, Srdjan and Harris, Tim and Unsal, Osman
	S. and Cristal, Adri\'{a}n and Hur, Ibrahim and Valero, Mateo},
  title = {Discovering and understanding performance bottlenecks in transactional
	applications},
  booktitle = {PACT '10},
  year = {2010},
  pages = {285--294},
  publisher = {ACM},
  abstract = {Many researchers have developed applications using transactionalmemory
	(TM) with the purpose of benchmarking different implementations,
	and studying whether or not TM is easy to use. However, comparatively
	little has been done to provide general-purpose tools for profiling
	and tuning programs which use transactions.


	In this paper we introduce a series of profiling techniques for TM
	applications that provide in-depth and comprehensive information
	about the wasted work caused by aborting transactions. We explore
	three directions: (i) techniques to identify multiple potential conflicts
	from a single program run, (ii) techniques to identify the data structures
	involved in conflicts by using a symbolic path through the heap,
	rather than a machine address, and (iii) visualization techniques
	to summarize how threads spend their time and which of their transactions
	conflict most frequently.


	To examine the effectiveness of the profiling techniques, we provide
	a series of illustrations from the STAMP TM benchmark suite and from
	the synthetic WormBench workload. We show how to use our profiling
	techniques to optimize the performance of the Bayes, Labyrinth and
	Intruder applications.


	We discuss the design and implementation of our techniques in the
	Bartok-STM system. We process data offline or during garbage collection,
	where possible, in order to minimize the probe effect introduced
	by profiling.},
  doi = {http://doi.acm.org/10.1145/1854273.1854311},
  isbn = {978-1-4503-0178-7},
  keywords = {STM, TM, C#, Bartok},
  location = {Vienna, Austria},
  owner = {Mathias Payer},
  review = {Discover bottlenecks and conflicting data structures in bartok STM


	Remember where conflicts happened and add additional analysis about
	data structures (exact location of conflict)


	Additionally different visualization tools to show different conflicts
	and transactional progress


	Case studies for different STAMP benchmarks (that are translated to
	C#)},
  timestamp = {2010.09.24}
}

@MISC{newsyscalls,
  author = {corbet},
  title = {New system calls},
  year = {2005},
  howpublished = {\url{https://lwn.net/Articles/164887/}},
  owner = {Mathias Payer},
  timestamp = {2011.05.10}
}

@MISC{openat,
  author = {{POSIX}},
  title = {openat syscall},
  year = {2008},
  howpublished = {\url{http://linux.die.net/man/2/openat}},
  owner = {Mathias Payer},
  timestamp = {2011.05.10}
}

@MISC{gnulightning,
  title = {Using and porting GNU lightning},
  howpublished = {\url{http://www.gnu.org/s/lightning/}},
  month = {Dec.},
  year = {2011},
  owner = {Mathias Payer},
  timestamp = {2011.12.16}
}

@MISC{intelArchManualBasic,
  author = {Intel Corp.},
  title = {Intel 64 and {IA-32} {Intel Architecture Software Developer's Manual
	Volume 1: Basic Architecture}},
  year = {2012},
  owner = {Mathias Payer},
  publisher = {Intel Corp.},
  timestamp = {2011.07.05}
}

@MISC{intelArchManualInstrSet,
  author = {Intel Corp.},
  title = {Intel 64 and {IA-32} {Intel Architecture Software Developer's Manual
	Combined Volumes 2A and 2B: Instruction Set Reference, A-Z}},
  year = {2012},
  owner = {Mathias Payer},
  publisher = {Intel Corp.},
  timestamp = {2011.07.05}
}

@MISC{intelArchManualSysprog,
  author = {Intel Corp.},
  title = {Intel 64 and {IA-32} {Intel Architecture Software Developer's Manual
	Combined Volumes 3A and 3B: System Programming Guide, Parts 1 and
	2}},
  year = {2012},
  owner = {Mathias Payer},
  publisher = {Intel Corp.},
  timestamp = {2011.07.05}
}

@MISC{intel-P4-vol3,
  title = {{IA-32} {Intel Architecture Software Developer's Manual, Volume 3:
	System Programming Guide}},
  year = {2005},
  owner = {Mathias Payer},
  publisher = {Intel Corp.},
  timestamp = {2011.07.05}
}

@MISC{ubuntuPIE,
  author = {Ubuntu},
  title = {List of programs built with {PIE}},
  howpublished = {\url{https://wiki.ubuntu.com/Security/Features#pie}},
  month = {May},
  year = {2012},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@inproceedings{schwartz11rop,
   author = {Edward J. Schwartz and Thanassis Avgerinos and David Brumley},
   title = {{Q}: Exploit Hardening Made Easy},
   booktitle = {Proceedings of the {USENIX} Security Symposium},
   year = {2011},
   abstract = {
   Prior work has shown that return oriented programming (ROP) can be used to bypass W^X, a software defense that stops shellcode, by reusing instructions from large libraries such as libc. Modern operating systems have since enabled address randomization (ASLR), which randomizes the location of libc, making these techniques unusable in practice. However, modern ASLR implementations leave smaller amounts of executable code unrandomized and it has been unclear whether an attacker can use these small code fragments to construct payloads in the general case.

In this paper, we show defenses as currently deployed can be bypassed with new techniques for automatically creating ROP payloads from small amounts of unrandomized code. We propose using semantic program verification techniques for identifying the functionality of gadgets, and design a ROP compiler that is resistant to missing gadget types. To demonstrate our techniques, we build Q, an end-to-end system that automatically generates ROP payloads for a given binary. Q can produce payloads for 80\% of Linux /usr/bin programs larger than 20KB. We also show that Q can automatically perform exploit hardening: given an exploit that crashes with defenses on, Q outputs an exploit that bypasses both W^X and ASLR. We show that Q can harden nine real-world Linux and Windows exploits, enabling an attacker to automatically bypass defenses as deployed by industry for those programs.
 }
}

@inproceedings{akritidis08sp,
 author = {Akritidis, Periklis and Cadar, Cristian and Raiciu, Costin and Costa, Manuel and Castro, Miguel},
 title = {Preventing Memory Error Exploits with {WIT}},
 booktitle = {SP'08: Proc. 2008 IEEE Symposium on Security and Privacy},
 year = {2008},
 isbn = {978-0-7695-3168-7},
 pages = {263--277},
 numpages = {15},
 url = {http://dx.doi.org/10.1109/SP.2008.30},
 doi = {10.1109/SP.2008.30},
 acmid = {1398074},
 keywords = {static analysis, instrumentation, attack detection, memory errors},
 abstract = {Attacks often exploit memory errors to gain control over the execution of vulnerable programs. These attacks remain a serious problem despite previous research on techniques to prevent them. We present Write Integrity Testing (WIT), a new technique that provides practical protection from these attacks. WIT uses points-to analysis at compile time to compute the control-flow graph and the set of objects that can be written by each instruction in the program. Then it generates code instrumented to prevent instructions from modifying objects that are not in the set computed by the static analysis, and to ensure that indirect control transfers are allowed by the control-flow graph. To improve coverage where the analysis is not precise enough, WIT inserts small guards between the original program objects. We describe an efficient implementation with optimizations to reduce space and time overhead. This implementation can be used in practice because it compiles C and C++ programs without modifications, it has high coverage with no false positives, and it has low overhead. WIT's average runtime overhead is only 7\% across a set of CPU intensive benchmarks and it is negligible when IO is the bottleneck.}
}


@inproceedings{castro09bgi,
  author    = {Miguel Castro and
               Manuel Costa and
               Jean-Philippe Martin and
               Marcus Peinado and
               Periklis Akritidis and
               Austin Donnelly and
               Paul Barham and
               Richard Black},
  title     = {Fast byte-granularity software fault isolation},
  booktitle = {SOSP'09},
  year      = {2009},
  pages     = {45-58},
  ee        = {http://doi.acm.org/10.1145/1629575.1629581},
  abstract = {Bugs in kernel extensions remain one of the main causes of poor operating system reliability despite proposed techniques that isolate extensions in separate protection domains to contain faults. We believe that previous fault isolation techniques are not widely used because they cannot isolate existing kernel extensions with low overhead on standard hardware. This is a hard problem because these extensions communicate with the kernel using a complex interface and they communicate frequently. We present BGI (Byte-Granularity Isolation), a new software fault isolation technique that addresses this problem. BGI uses efficient byte-granularity memory protection to isolate kernel extensions in separate protection domains that share the same address space. BGI ensures type safety for kernel objects and it can detect common types of errors inside domains. Our results show that BGI is practical: it can isolate Windows drivers without requiring changes to the source code and it introduces a CPU overhead between 0 and 16\%. BGI can also find bugs during driver testing. We found 28 new bugs in widely used Windows drivers. }
}

@inproceedings{mao11sosp,
 author = {Mao, Yandong and Chen, Haogang and Zhou, Dong and Wang, Xi and Zeldovich, Nickolai and Kaashoek, M. Frans},
 title = {Software fault isolation with API integrity and multi-principal modules},
 booktitle = {SOSP'11},
 year = {2011},
 isbn = {978-1-4503-0977-6},
 location = {Cascais, Portugal},
 pages = {115--128},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2043556.2043568},
 doi = {10.1145/2043556.2043568},
 acmid = {2043568},
 abstract = {The security of many applications relies on the kernel being secure, but history suggests that kernel vulnerabilities are routinely discovered and exploited. In particular, exploitable vulnerabilities in kernel modules are common. This paper proposes LXFI, a system which isolates kernel modules from the core kernel so that vulnerabilities in kernel modules cannot lead to a privilege escalation attack. To safely give kernel modules access to complex kernel APIs, LXFI introduces the notion of API integrity, which captures the set of contracts assumed by an interface. To partition the privileges within a shared module, LXFI introduces module principals. Programmers specify principals and API integrity rules through capabilities and annotations. Using a compiler plugin, LXFI instruments the generated code to grant, check, and transfer capabilities between modules, according to the programmer's annotations. An evaluation with Linux shows that the annotations required on kernel functions to support a new module are moderate, and that LXFI is able to prevent three known privilege-escalation vulnerabilities. Stress tests of a network driver module also show that isolating this module using LXFI does not hurt TCP throughput but reduces UDP throughput by 35\%, and increases CPU utilization by 2.2-3.7x.
 }
}

@inproceedings{roglia09libc,
  author = {Roglia, Giampaolo Fresi and Martignoni, Lorenzo and Paleari, Roberto and Bruschi, Danilo},
  booktitle = {ACSAC},
  date = {2010-01-11},
  isbn = {978-0-7695-3919-5},
  pages = {60-69},
  publisher = {IEEE Computer Society},
  title = {Surgically Returning to Randomized lib(c).},
  year = 2009
}


@inproceedings{bosman11raid,
 author = {Bosman, Erik and Slowinska, Asia and Bos, Herbert},
 title = {Minemu: the world's fastest taint tracker},
 booktitle = {RAID'11: Proc. 14th conf. on Recent Advances in Intrusion Detection},
 year = {2011},
 isbn = {978-3-642-23643-3},
 pages = {1--20},
 numpages = {20},
 url = {http://dx.doi.org/10.1007/978-3-642-23644-0_1},
 doi = {10.1007/978-3-642-23644-0_1},
 acmid = {2186330},
 keywords = {JIT compilation, dynamic taint tracking, intrusion detection},
}


@article{marathe07toplas,
 author = {Marathe, Jaydeep and Mueller, Frank and Mohan, Tushar and Mckee, Sally A. and
 De Supinski, Bronis R. and Yoo, Andy},
 title = {METRIC: Memory tracing via dynamic binary rewriting to identify cache
 inefficiencies},
 journal = {ACM Trans. Program. Lang. Syst.},
 issue_date = {April 2007},
 volume = {29},
 number = {2},
 month = apr,
 year = {2007},
 issn = {0164-0925},
 articleno = {12},
 url = {http://doi.acm.org/10.1145/1216374.1216380},
 doi = {10.1145/1216374.1216380},
 acmid = {1216380},
 keywords = {Dynamic binary rewriting, cache analysis, data trace compression, data trace
 generation, program instrumentation},
}

@inproceedings{bruening11cgo,
 author = {Bruening, Derek and Zhao, Qin},
 title = {Practical memory checking with Dr. Memory},
 booktitle = {CGO'11},
 year = {2011},
 isbn = {978-1-61284-356-8},
 pages = {213--223},
 numpages = {11},
 url = {http://dl.acm.org/citation.cfm?id=2190025.2190067},
 acmid = {2190067},
 abstract = { Memory corruption, reading uninitialized memory, using freed memory, and other memory-related errors are among the most difficult programming bugs to identify and fix due to the delay and non-determinism linking the error to an observable symptom. Dedicated memory checking tools are invaluable for finding these errors. However, such tools are difficult to build, and because they must monitor all memory accesses by the application, they incur significant overhead. Accuracy is another challenge: memory errors are not always straightforward to identify, and numerous false positive error reports can make a tool unusable. A third obstacle to creating such a tool is that it depends on low-level operating system and architectural details, making it difficult to port to other platforms and difficult to target proprietary systems like Windows. This paper presents Dr. Memory, a memory checking tool that operates on both Windows and Linux applications. Dr. Memory handles the complex and not fully documented Windows environment, and avoids reporting false positive memory leaks that plague traditional leak locating algorithms. Dr. Memory employs efficient instrumentation techniques; a direct comparison with the state-of-the-art Valgrind Memcheck tool reveals that Dr. Memory is twice as fast as Memcheck on average and up to four times faster on individual benchmarks.}
}


@inproceedings{costa05sosp,
author = {Manuel Costa and Jon Crowcroft and Miguel Castro and Antony I. T. Rowstron and Lidong Zhou and Lintao Zhang and Paul Barham},
title = {{Vigilante: End-to-End Containment of Internet Worms}},
booktitle = {SOSP'05},
volume = {39},
year = {2005},
pages = {133--147},
issue = {5},
doi = {10.1145/1095809.1095824},
abstract = {Worm containment must be automatic because worms can spread too fast for humans to respond. Recent work has proposed network-level techniques to automate worm containment; these techniques have limitations because there is no information about the vulnerabilities exploited by worms at the network level. We propose Vigilante, a new end-to-end approach to contain worms automatically that addresses these limitations. Vigilante relies on collaborative worm detection at end hosts, but does not require hosts to trust each other. Hosts run instrumented software to detect worms and broadcast self-certifying alerts (SCAs) upon worm detection. SCAs are proofs of vulnerability that can be inexpensively verified by any vulnerable host. When hosts receive an SCA, they generate filters that block infection by analysing the SCA-guided execution of the vulnerable software. We show that Vigilante can automatically contain fast-spreading worms that exploit unknown vulnerabilities without blocking innocuous traffic.}
}


@inproceedings{clause07issta,
author = {James A. Clause and Wanchun Li and Alessandro Orso},
title = {{Dytan: a generic dynamic taint analysis framework}},
booktitle = {Intl. Symp. on Software Testing and Analysis},
year = {2007},
pages = {196--206},
doi = {10.1145/1273463.1273490},
masid = {4293476}
}

@inproceedings{newsome05ndss,
author ={Newsome, James and Song, Dawn},
title= {Dynamic Taint Analysis for Automatic Detection, Analysis, and Signature Generation of Exploits
on Commodity Software},
booktitle = {NDSS'05},
year = {2005},
abstract = {Software vulnerabilities have had a devastating effect on the Internet. Worms such as CodeRed and Slammer can compromise hundreds of thousands of hosts within hours or even minutes, and cause millions of dollars of damage [26, 43]. To successfully combat these fast automatic Internet attacks, we need fast automatic attack detection and filtering mechanisms.
In this paper we propose dynamic taint analysis for automatic detection of overwrite attacks, which include most types of exploits. This approach does not need source code or special compilation for the monitored program, and hence works on commodity software. To demonstrate this idea, we have implemented TaintCheck, a mechanism that can perform dynamic taint analysis by performing binary rewriting at run time. We show that TaintCheck reliably detects most types of exploits. We found that TaintCheck produced no false positives for any of the many different programs that we tested. Further, we describe how TaintCheck could improve automatic signature generation in several ways.}
}

@inproceedings{ho06eurosys,
 author = {Ho, Alex and Fetterman, Michael and Clark, Christopher and Warfield, Andrew and Hand, Steven},
 title = {Practical taint-based protection using demand emulation},
 booktitle = {EuroSys'06},
 year = {2006},
 isbn = {1-59593-322-0},
 pages = {29--41},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/1217935.1217939},
 doi = {10.1145/1217935.1217939},
 acmid = {1217939},
 keywords = {QEMU, Xen, demand emulation, emulation, false tainting, tainting, virtual machine, virtualization},
 abstract = {Many software attacks are based on injecting malicious code into a target host. This paper demonstrates the use of a well-known technique, data tainting, to track data received from the network as it propagates through a system and to prevent its execution. Unlike past approaches to taint tracking, which track tainted data by running the system completely in an emulator or simulator, resulting in considerable execution overhead, our work demonstrates the ability to dynamically switch a running system between virtualized and emulated execution. Using this technique, we are able to explore hardware support for taint-based protection that is deployable in real-world situations, as emulation is only used when tainted data is being processed by the CPU. By modifying the CPU, memory, and I/O devices to support taint tracking and protection, we guarantee that data received from the network may not be executed, even if it is written to, and later read from disk. We demonstrate near native speeds for workloads where little taint data is present.}
}

@INPROCEEDINGS{portokalidis06eurosys,
    author = {Georgios Portokalidis and Asia Slowinska and Herbert Bos},
    title = {Argos: an emulator for fingerprinting zero-day attacks},
    booktitle = {EuroSys'06},
    year = {2006}
}

@inproceedings{qin06micro,
 author = {Qin, Feng and Wang, Cheng and Li, Zhenmin and Kim, Ho-seop and Zhou, Yuanyuan and Wu, Youfeng},
 title = {LIFT: A Low-Overhead Practical Information Flow Tracking System for Detecting Security Attacks},
 booktitle = {MICRO'06},
 year = {2006},
 isbn = {0-7695-2732-9},
 pages = {135--148},
 numpages = {14},
 url = {http://dx.doi.org/10.1109/MICRO.2006.29},
 doi = {10.1109/MICRO.2006.29},
 abstract = {Computer security is severely threatened by software vulnerabilities. Prior work shows that information flow tracking (also referred to as taint analysis) is a promising technique to detect a wide range of security attacks. However, current information flow tracking systems are not very practical, because they either require program annotations, source code, non-trivial hardware extensions, or incur prohibitive runtime overheads. This paper proposes a low overhead, software-only information flow tracking system, called LIFT, which minimizes run-time overhead by exploiting dynamic binary instrumentation and optimizations for detecting various types of security attacks without requiring any hardware changes. More specifically, LIFT aggressively eliminates unnecessary dynamic information flow tracking, coalesces information checks, and efficiently switches between target programs and instrumented information flow tracking code. We have implemented LIFT on a dynamic binary instrumentation framework on Windows. Our real-system experiments with two real-world server applications, one client application and eighteen attack benchmarks show that LIFT can effectively detect various types of security attacks. LIFT also incurs very low overhead, only 6.2\% for server applications, and 3.6 times on average for seven SPEC INT2000 applications. Our dynamic optimizations are very effective in reducing the overhead by a factor of 5-12 times.}
}

@inproceedings{kemerlis12vee,
 author = {Kemerlis, Vasileios P. and Portokalidis, Georgios and Jee, Kangkook and Keromytis, Angelos D.},
 title = {libdft: practical dynamic data flow tracking for commodity systems},
 booktitle = {VEE'12},
 year = {2012},
 isbn = {978-1-4503-1176-2},
 pages = {121--132},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/2151024.2151042},
 doi = {10.1145/2151024.2151042},
 acmid = {2151042},
 keywords = {data flow tracking, dynamic binary instrumentation, exploit prevention, information leak detection, taint analysis},
}


@inproceedings{saxena08cgo,
 author = {Saxena, Prateek and Sekar, R and Puranik, Varun},
 title = {Efficient fine-grained binary instrumentationwith applications to taint-tracking},
 booktitle = {CGO'08},
 year = {2008},
 isbn = {978-1-59593-978-4},
 pages = {74--83},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1356058.1356069},
 doi = {10.1145/1356058.1356069},
 acmid = {1356069},
 keywords = {binary analysis/rewriting, information flow, taint tracking},
 abstract = {Fine-grained binary instrumentations, such as those for taint-tracking, have become very popular in computer security due to their applications in exploit detection, sandboxing, malware analysis, etc. However, practical application of taint-tracking has been limited by high performance overheads. For instance, previous software based techniques for taint-tracking on binary code have typically slowed down programs by a factor of 3 or more. In contrast, source-code based techniques have achieved better performance using high level optimizations. Unfortunately, these optimizations are difficult to perform on binaries since much of the high level program structure required by such static analyses is lost during the compilation process. In this paper, we address this challenge by developing static techniques that can recover some of the higher level structure from x86 binaries. Our new static analysis enables effective optimizations, which are applied in the context of taint tracking. As a result, we achieve a substantial reduction in performance overheads as compared to previous works.}
}

@techreport{ermolinskiy10tr,
    Author = {Ermolinskiy, Andrey and Katti, Sachin and Shenker, Scott and Fowler, Lisa L and McCauley, Murphy},
    Title = {Towards Practical Taint Tracking},
    Institution = {EECS Department, University of California, Berkeley},
    Year = {2010},
    Month = {Jun},
    URL = {http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-92.html},
    Number = {UCB/EECS-2010-92},
    Abstract = {This report proposes several technical measures that significantly improve performance and largely limit kernel taint explosion in a Xen- and QEMU-based taint tracking system.}
}


@inproceedings{yin07ccs,
 author = {Yin, Heng and Song, Dawn and Egele, Manuel and Kruegel, Christopher and Kirda, Engin},
 title = {Panorama: capturing system-wide information flow for malware detection and analysis},
 booktitle = {CCS'07},
 year = {2007},
 isbn = {978-1-59593-703-2},
 pages = {116--127},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1315245.1315261},
 doi = {10.1145/1315245.1315261},
 acmid = {1315261},
 keywords = {dynamic taint analysis, malware analysis, malware detection, spyware},
 abstract ={Malicious programs spy on users' behavior and compromise their privacy. Even software from reputable vendors, such as Google Desktop and Sony DRM media player, may perform undesirable actions. Unfortunately, existing techniques for detecting malware and analyzing unknown code samples are insufficient and have significant shortcomings. We observe that malicious information access and processing behavior is the fundamental trait of numerous malware categories breaching users' privacy (including keyloggers, password thieves, network sniffers, stealth backdoors, spyware and rootkits), which separates these malicious applications from benign software. We propose a system, Panorama, to detect and analyze malware by capturing this fundamental trait. In our extensive experiments, Panorama successfully detected all the malware samples and had very few false positives. Furthermore, by using Google Desktop as a case study, we show that our system can accurately capture its information access and processing behavior, and we can confirm that it does send back sensitive information to remote servers in certain settings. We believe that a system such as Panorama will offer indispensable assistance to code analysts and malware researchers by enabling them to quickly comprehend the behavior and innerworkings of an unknown sample.}
}


@incollection{wang07acsa,
   author = {Wang, Cheng and Hu, Shiliang and Kim, Ho-seop and Nair, Sreekumar and Breternitz, Mauricio and Ying, Zhiwei and Wu, Youfeng},
   affiliation = {Programming Systems Lab, Intel Corporation, 2200 Mission College Blvd, Santa Clara, CA 95052 USA},
   title = {StarDBT: An Efficient Multi-platform Dynamic Binary Translation System},
   booktitle = {Advances in Computer Systems Architecture},
   isbn = {978-3-540-74308-8},
   pages = {4-15},
   volume = {4697},
   url = {http://dx.doi.org/10.1007/978-3-540-74309-5\_3},
   abstract = {This paper describes the design and implementation of a research dynamic binary translation system, StarDBT, which runs many real-world applications. StarDBT is a multi-platform translation system that is capable of translating application level binaries on either Windows or Linux OSes. A system-level variant of StarDBT can also run on a bare machine by translating the whole system code. We evaluate performance of a user-mode system using both SPEC2000 and some challenging Windows applications. StarDBT runs the SPEC2000 benchmark competitively to other state-of-the-art binary translators. For Windows applications that are typically multi-threaded GUI-based interactive applications with large code footprint, the StarDBT system provides acceptable performance in many cases. However, there are important scenarios in which dynamic translation still incurs significant runtime overhead, raising issues for further research. The major overheads are caused by the translation overhead of large volume of infrequently-executed code and by the emulation overhead for indirect branches.},
   year = {2007}
}

@inproceedings{greathouse12asplos,
 author = {Greathouse, Joseph L. and Xin, Hongyi and Luo, Yixin and Austin, Todd},
 title = {A case for unlimited watchpoints},
 booktitle = {ASPLOS'12},
 year = {2012},
 isbn = {978-1-4503-0759-8},
 pages = {159--172},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2150976.2150994},
 doi = {10.1145/2150976.2150994},
 acmid = {2150994},
 keywords = {data race detection, demand-driven analysis, deterministic concurrent execution, taint analysis, watchpoints},
 abstract = {Numerous tools have been proposed to help developers fix software errors and inefficiencies. Widely-used techniques such as memory checking suffer from overheads that limit their use to pre-deployment testing, while more advanced systems have such severe performance impacts that they may require special-purpose hardware. Previous works have described hardware that can accelerate individual analyses, but such specialization stymies adoption; generalized mechanisms are more likely to be added to commercial processors. This paper demonstrates that the ability to set an unlimited number of fine-grain data watchpoints can reduce the runtime overheads of numerous dynamic software analysis techniques. We detail the watchpoint capabilities required to accelerate these analyses while remaining general enough to be useful in the future. We describe a hardware design that stores watchpoints in main memory and utilizes two different on-chip caches to accelerate performance. The first is a bitmap lookaside buffer that stores fine-grained watchpoints, while the second is a range cache that can efficiently hold large contiguous regions of watchpoints. As an example of the power of such a system, it is possible to use watchpoints to accelerate read/write set checks in a software data race detector by nearly 9x.}
}

@inproceedings{zhao10cgo,
 author = {Zhao, Qin and Bruening, Derek and Amarasinghe, Saman},
 title = {Umbra: efficient and scalable memory shadowing},
 booktitle = {CGO'10},
 year = {2010},
 isbn = {978-1-60558-635-9},
 pages = {22--31},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1772954.1772960},
 doi = {10.1145/1772954.1772960},
 acmid = {1772960},
 keywords = {dynamic optimization, shadow memory},
 abstract = {Shadow value tools use metadata to track properties of application data at the granularity of individual machine instructions. These tools provide effective means of monitoring and analyzing the runtime behavior of applications. However, the high runtime overhead stemming from fine-grained monitoring often limits the use of such tools. Furthermore, 64-bit architectures pose a new challenge to the building of efficient memory shadowing tools. Current tools are not able to efficiently monitor the full 64-bit address space due to limitations in their shadow metadata translation.

This paper presents an efficient and scalable memory shadowing framework called Umbra. Employing a novel translation scheme, Umbra supports efficient mapping from application data to shadow metadata for both 32-bit and 64-bit applications. Umbra's translation scheme does not rely on any platform features and is not restricted to any specific shadow memory size. We also present several mapping optimizations and general dynamic instrumentation techniques that substantially reduce runtime overhead, and demonstrate their effectiveness on a real-world shadow value tool. We show that shadow memory translation overhead can be reduced to just 133\% on average.}
}

@inproceedings{nethercote07vee,
 author = {Nethercote, Nicholas and Seward, Julian},
 title = {How to shadow every byte of memory used by a program},
 booktitle = {VEE'07},
 year = {2007},
 isbn = {978-1-59593-630-1},
 pages = {65--74},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1254810.1254820},
 doi = {10.1145/1254810.1254820},
 acmid = {1254820},
 keywords = {dynamic binary analysis, dynamic binary instrumentation, memcheck, shadow memory, valgrind},
 abstract = {Several existing dynamic binary analysis tools use shadowmemory-they shadow, in software, every byte of memory used by a program with another value that says something about it. Shadow memory is difficult to implement both efficiently and robustly. Nonetheless, existing shadow memory implementations have not been studied in detail. This is unfortunate, because shadow memory is powerful-for example, some of the existing tools that use it detect critical errors such as bad memory accesses, data races, and uses of uninitialised or untrusted data. In this paper we describe the implementation of shadow memory in Memcheck, a popular memory checker built with Valgrind, a dynamic binary instrumentation framework. This implementation has several novel features that make it efficient: carefully chosen data structures and operations result in a mean slow-down factor of only 22.2 and moderate memory usage. This may sound slow, but we show it is 8.9 times faster and 8.5 times smaller on average than a naive implementation, and shadow memory operations account for only about half of Memcheck's execution time. Equally importantly, unlike some tools, Memcheck's shadow memory implementation is robust: it is used on Linux by thousands of programmers on sizeable programs such as Mozilla and OpenOffice, and is suited to almost any memory configuration. This is the first detailed description of a robust shadow memory implementation, and the first detailed experimental evaluation of any shadow memory implementation. The ideas within are applicable to any shadow memory tool built with any instrumentation framework.}
}

@MISC{gloger97ptmalloc,
  author = {Wolfram Gloger},
  title = {Dynamic memory allocator implementations in Linux system libraries},
  howpublished = {\url{http://www.dent.med.uni-muenchen.de/~wmglo/malloc-slides.html}},
  month = {May},
  year = {1997},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}


@article{blondel08louvain,
  author={Vincent D Blondel and Jean-Loup Guillaume and Renaud Lambiotte and Etienne Lefebvre},
  title={Fast unfolding of communities in large networks},
  journal={Journal of Statistical Mechanics: Theory and Experiment},
  volume={2008},
  number={10},
  pages={P10008},
  url={http://stacks.iop.org/1742-5468/2008/i=10/a=P10008},
  year={2008},
  abstract={We propose a simple method to extract the community structure of large networks. Our method is a heuristic method that is based on modularity optimization. It is shown to outperform all other known community detection methods in terms of computation time. Moreover, the quality of the communities detected is very good, as measured by the so-called modularity. This is shown first by identifying language communities in a Belgian mobile phone network of 2 million customers and by analysing a web graph of 118 million nodes and more than one billion links. The accuracy of our algorithm is also verified on ad hoc modular networks.}
}

@inproceedings{suh04asplos,
 author = {Suh, G. Edward and Lee, Jae W. and Zhang, David and Devadas, Srinivas},
 title = {Secure program execution via dynamic information flow tracking},
 booktitle = {ASPLOS'04},
 year = {2004},
 isbn = {1-58113-804-0},
 pages = {85--96},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1024393.1024404},
 doi = {10.1145/1024393.1024404},
 acmid = {1024404},
 keywords = {buffer overflow, format string, hardware tagging},
 abstract ={We present a simple architectural mechanism called dynamic information flow tracking that can significantly improve the security of computing systems with negligible performance overhead. Dynamic information flow tracking protects programs against malicious software attacks by identifying spurious information flows from untrusted I/O and restricting the usage of the spurious information.Every security attack to take control of a program needs to transfer the program's control to malevolent code. In our approach, the operating system identifies a set of input channels as spurious, and the processor tracks all information flows from those inputs. A broad range of attacks are effectively defeated by checking the use of the spurious values as instructions and pointers.Our protection is transparent to users or application programmers; the executables can be used without any modification. Also, our scheme only incurs, on average, a memory overhead of 1.4\% and a performance overhead of 1.1\%.}
}

@MISC{gdbrsp2010,
  author = {GDB},
  title = {{GDB} Remote Serial Protocol},
  howpublished = {\url{http://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html}},
  year = {2010},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@inproceedings{adl-tabatabai98pldi,
 author = {Adl-Tabatabai, Ali-Reza and Cierniak, Micha\l and Lueh, Guei-Yuan and Parikh,
Vishesh M. and Stichnoth, James M.},
 title = {Fast, effective code generation in a just-in-time Java compiler},
 booktitle = {PLDI'98},
 year = {1998},
 isbn = {0-89791-987-4},
 pages = {280--290},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/277650.277740},
 doi = {10.1145/277650.277740},
 acmid = {277740},
 abstract ={A "Just-In-Time" (JIT) Java compiler produces native code from Java byte code instructions during program execution. As such, compilation speed is more important in a Java JIT compiler than in a traditional compiler, requiring optimization algorithms to be lightweight and effective. We present the structure of a Java JIT compiler for the Intel Architecture, describe the lightweight implementation of JIT compiler optimizations (e.g., common subexpression elimination, register allocation, and elimination of array bounds checking), and evaluate the performance benefits and tradeoffs of the optimizations. This JIT compiler has been shipped with version 2.5 of Intel's VTune for Java product.}
}

@inproceedings{alpern02jvm,
  author    = {Bowen Alpern and
               Maria A. Butrico and
               Anthony Cocchi and
               Julian Dolby and
               Stephen J. Fink and
               David Grove and
               Ton Ngo},
  title     = {Experiences Porting the Jikes RVM to Linux/IA32},
  booktitle = {Java Virtual Machine Research and Technology Symposium},
  year      = {2002},
  pages     = {51-64},
  ee        = {http://www.usenix.org/publications/library/proceedings/javavm02/alpern.html},
  abstract = {This paper describes our experiences in porting the Jikes Research Virtual Machine from its first platform, AIX/PowerPC, to its second, Linux/IA32. We discuss the main issues in realizing both an initial functional port, and then tuning efforts to achieve competitive performance. The paper presents software engineering issues in building a portable runtime system and compilers, as well as specific optimizations to improve performance on IA32.
  }
}

@inproceedings{wimmer10cgo,
 author = {Wimmer, Christian and Franz, Michael},
 title = {Linear scan register allocation on SSA form},
 booktitle = {CGO'10},
 year = {2010},
 isbn = {978-1-60558-635-9},
 pages = {170--179},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1772954.1772979},
 doi = {10.1145/1772954.1772979},
 acmid = {1772979},
 keywords = {Java, SSA form, SSA form deconstruction, just-in-time compilation, lifetime
 analysis, linear scan, register allocation},
 abstract = {The linear scan algorithm for register allocation provides a good register assignment with a low compilation overhead and is thus frequently used for just-in-time compilers. Although most of these compilers use static single assignment (SSA) form, the algorithm has not yet been applied on SSA form, i.e., SSA form is usually deconstructed before register allocation. However, the structural properties of SSA form can be used to simplify the algorithm.

With only one definition per variable, lifetime intervals (the main data structure) can be constructed without data flow analysis. During allocation, some tests of interval intersection can be skipped because SSA form guarantees non-intersection. Finally, deconstruction of SSA form after register allocation can be integrated into the resolution phase of the register allocator without much additional code.

We modified the linear scan register allocator of the Java HotSpot client compiler so that it operates on SSA form. The evaluation shows that our simpler and faster version generates equally good or slightly better machine code.}
}

@MISC{vmware09segmentation,
  author = {VMWare},
  title = {Software and Hardware Techniques for x86 Virtualization},
  howpublished = {\url{http://www.vmware.com/files/pdf/software_hardware_tech_x86_virt.pdf}},
  year = {2009},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@article{frei2010modeling,
  title={Modeling the security ecosystem-the dynamics of (in) security},
  author={Frei, S. and Schatzmann, D. and Plattner, B. and Trammell, B.},
  journal={Economics Info. Sec. Privacy},
  pages={79--106},
  year={2010},
  publisher={Springer}
}

@MISC{netcraft13webserver,
  author = {Netcraft},
  title = {March 2013 WebServer study},
  howpublished = {\url{http://news.netcraft.com/archives/2013/03/01/march-2013-web-server-survey.html}},
  year = {2009},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@INPROCEEDINGS{sidiroglou07hotdep,
  author = {Stelios Sidiroglou and Sotiris Ioannidis and Angelos D. Keromytis},
  title = {Band-aid Patching},
  booktitle = {HotDep'07: Hot Topics in System Dependability},
  owner = {Mathias Payer},
  timestamp = {2008.07.30},
}

@article{bernat12wcre,
author = {Andrew R. Bernat and Barton P. Miller},
title = {Structured Binary Editing with a CFG Transformation Algebra},
journal ={WCRE'12: Working Conf. on Reverse Engineering},
doi = {http://doi.ieeecomputersociety.org/10.1109/WCRE.2012.11},
}

@inproceedings{perkins09sosp,
 author = {Perkins, Jeff H. and Kim, Sunghun and Larsen, Sam and Amarasinghe, Saman and Bachrach, Jonathan and Carbin, Michael and Pacheco, Carlos and Sherwood, Frank and Sidiroglou, Stelios and Sullivan, Greg and Wong, Weng-Fai and Zibin, Yoav and Ernst, Michael D. and Rinard, Martin},
 title = {Automatically patching errors in deployed software},
 booktitle = {SOSP'09},
 url = {http://doi.acm.org/10.1145/1629575.1629585},
}
@inproceedings{DBLP:conf/uss/KruegelRVV04,
  author    = {Christopher Kr{\"u}gel and
               William K. Robertson and
               Fredrik Valeur and
               Giovanni Vigna},
  title     = {Static Disassembly of Obfuscated Binaries},
  booktitle = {USENIX Security Symposium},
  year      = {2004},
  pages     = {255-270},
  ee        = {http://www.usenix.org/publications/library/proceedings/sec04/tech/kruegel.html},
  crossref  = {DBLP:conf/uss/2004},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@inproceedings{DBLP:conf/woot/MohanH12,
  author    = {Vishwath Mohan and
               Kevin W. Hamlen},
  title     = {Frankenstein: Stitching Malware from Benign Binaries},
  booktitle = {WOOT},
  year      = {2012},
  pages     = {77-84},
  ee        = {http://www.usenix.org/conference/woot12/frankenstein-stitching-malware-benign-binaries},
  crossref  = {DBLP:conf/woot/2012},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}
@proceedings{DBLP:conf/woot/2012,
  editor    = {Elie Bursztein and
               Thomas Dullien},
  title     = {6th USENIX Workshop on Offensive Technologies, August 6-7,
               2012, Bellevue, WA, USA, Proceedings},
  booktitle = {WOOT},
  publisher = {USENIX Association},
  year      = {2012},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@proceedings{DBLP:conf/uss/2004,
  title     = {Proceedings of the 13th USENIX Security Symposium, August
               9-13, 2004, San Diego, CA, USA},
  booktitle = {USENIX Security Symposium},
  publisher = {USENIX},
  year      = {2004},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}


@INPROCEEDINGS{Massalin1987,
  author = {Massalin, H.},
  title = {Superoptimizer: a look at the smallest program},
  booktitle = {Proceedings of the Second International Conference on Architectual
	Support for Programming Languages and Operating Systems},
  year = {1987},
  pages = {122--126},
  acmid = {36194},
  doi = {http://dx.doi.org/10.1145/36206.36194},
  isbn = {0-8186-0805-6},
  location = {Palo Alto, California, United States},
  numpages = {5},
  url = {http://dx.doi.org/10.1145/36206.36194}
}

@techreport{collberg97,
   author = {Collberg, Christian and Thomborson, Clark and Low, Douglas},
   institution = {Department of Computer Science, University of Auckland, New Zealand},
   month = jul,
   number = {148},
   type = {Technical Report},
   title = {A Taxonomy of Obfuscating Transformations},
   year = {1997},
}

@MISC{botnetop12,
  author = {Anonymous},
  title = {IAmA a malware coder and botnet operator, AMA},
  howpublished = {\url{http://www.reddit.com/r/IAmA/comments/sq7cy/iama_a_malware_coder_and_botnet_operator_ama/}},
  month = {May},
  year = {2012},
  owner = {Mathias Payer},
  timestamp = {2012.01.24}
}

@inproceedings{kolbitsch+11,
  author    = {Clemens Kolbitsch and
               Engin Kirda and
               Christopher Kruegel},
  title     = {The power of procrastination: detection and mitigation of
               execution-stalling malicious code},
  booktitle = {ACM Conference on Computer and Communications Security},
  year      = {2011},
  pages     = {285-296},
  ee        = {http://doi.acm.org/10.1145/2046707.2046740},
}

@inproceedings{oberheide09woot,
 author = {Oberheide, Jon and Bailey, Michael and Jahanian, Farnam},
 title = {{PolyPack}: an automated online packing service for optimal antivirus evasion},
 booktitle = {Proceedings of the 3rd USENIX conference on Offensive technologies},
 series = {WOOT'09},
 year = {2009},
}

@inproceedings{royal06acsac,
 author = {Royal, Paul and Halpin, Mitch and Dagon, David and Edmonds, Robert and Lee, Wenke},
 title = {{PolyUnpack}: Automating the Hidden-Code Extraction of Unpack-Executing Malware},
 booktitle = {Proceedings of the 22nd Annual Computer Security Applications Conference},
 series = {ACSAC '06},
 year = {2006},
}

@article{perdisci08patternrec,
 author = {Perdisci, Roberto and Lanzi, Andrea and Lee, Wenke},
 title = {Classification of packed executables for accurate computer virus detection},
 journal = {Pattern Recogn. Lett.},
 issue_date = {October, 2008},
 volume = {29},
 number = {14},
 month = oct,
 year = {2008},
}

@TECHREPORT{christodorescu05malwarenormalization,
  author = {Mihai Christodorescu and Johannes Kinder and Somesh Jha and Stefan Katzenbeisser and Helmut Veith},
  title = {Malware normalization},
  institution = {Technische Universit{\"a}t M{\"u}nchen},
  year = {2005}
}

@INPROCEEDINGS{martignoni07acsac,
    author = {Lorenzo Martignoni and Mihai Christodorescu and Somesh Jha},
    title = {Omniunpack: Fast, generic, and safe unpacking of malware},
    booktitle = {In Proceedings of the Annual Computer Security Applications Conference (ACSAC},
    year = {2007}
}

@inproceedings{kang07worm,
 author = {Kang, Min Gyung and Poosankam, Pongsin and Yin, Heng},
 title = {Renovo: a hidden code extractor for packed executables},
 booktitle = {Proceedings of the 2007 ACM workshop on Recurring malcode},
 series = {WORM '07},
 year = {2007},
}

@inproceedings{multicompiler,
  author    = {Andrei Homescu and
               Steven Neisius and
               Per Larsen and
               Stefan Brunthaler and
               Michael Franz},
  title     = {Profile-guided automated software diversity},
  booktitle = {Proceedings of the 2013 IEEE/ACM International Symposium
               on Code Generation and Optimization},
  series = {CGO'13},
  year      = {2013},
}

@inproceedings{stone.gross09ccs,
  author    = {Brett Stone-Gross and
               Marco Cova and
               Lorenzo Cavallaro and
               Bob Gilbert and
               Martin Szydlowski and
               Richard A. Kemmerer and
               Christopher Kruegel and
               Giovanni Vigna},
  title     = {Your botnet is my botnet: analysis of a botnet takeover},
  booktitle = {Proceedings of the 2009 ACM Conference on Computer and Communications
               Security},
  year      = {2009},
  series    = {CCS'09},
  pages     = {635-647},  
}

@article{coppens13taco,
  author    = {Bart Coppens and
               Bjorn De Sutter and
               Jonas Maebe},
  title     = {Feedback-driven binary code diversification},
  journal   = {TACO},
  volume    = {9},
  number    = {4},
  year      = {2013},
  pages     = {24},
  ee        = {http://doi.acm.org/10.1145/2400682.2400683},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@misc{payer14syscan,
  author = {Mathias Payer},
  year = {2014},
  title = {{Embracing the New Threat: Towards Automatically Self-Diversifying Malware}},
  howpublished = {\url{https://nebelwelt.net/publications/14SYSCAN/}},
  owner = {gannimo},
}

@inproceedings{collberg12acsac,
 author = {Collberg, Christian and Martin, Sam and Myers, Jonathan and Nagra, Jasvir},
 title = {Distributed Application Tamper Detection via Continuous Software Updates},
 booktitle = {Proceedings of the 28th Annual Computer Security Applications Conference},
 series = {ACSAC '12},
 year = {2012},
 isbn = {978-1-4503-1312-4},
 location = {Orlando, Florida},
 pages = {319--328},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/2420950.2420997},
 doi = {10.1145/2420950.2420997},
 acmid = {2420997},
 keywords = {defense-in-depth, distributed systems, diversity, obfuscation, renewability, security, software protection,
tamperproofing},
} 

@inproceedings{schrittwieser13ccs,
 author = {Schrittwieser, Sebastian and Katzenbeisser, Stefan and Kieseberg, Peter and Huber, Markus and Leithner, Manuel and
Mulazzani, Martin and Weippl, Edgar},
 title = {Covert Computation: Hiding Code in Code for Obfuscation Purposes},
 booktitle = {Proceedings of the 8th ACM SIGSAC Symposium on Information, Computer and Communications Security},
 series = {ASIA CCS '13},
 year = {2013},
 isbn = {978-1-4503-1767-2},
 location = {Hangzhou, China},
 pages = {529--534},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/2484313.2484384},
 doi = {10.1145/2484313.2484384},
 acmid = {2484384},
 keywords = {code obfuscation, malware detection, side effects},
} 

@inproceedings{Hiser12SP,
  author    = {Jason Hiser and
               Anh Nguyen-Tuong and
               Michele Co and
               Matthew Hall and
               Jack W. Davidson},
  title     = {ILR: Where'd My Gadgets Go?},
  booktitle = {IEEE Symposium on Security and Privacy},
  year      = {2012},
  pages     = {571-585},
  ee        = {http://doi.ieeecomputersociety.org/10.1109/SP.2012.39},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@inproceedings{Pappas12SP,
  author    = {Vasilis Pappas and
               Michalis Polychronakis and
               Angelos D. Keromytis},
  title     = {Smashing the Gadgets: Hindering Return-Oriented Programming
               Using In-place Code Randomization},
  booktitle = {IEEE Symposium on Security and Privacy},
  year      = {2012},
  pages     = {601-615},
  ee        = {http://doi.ieeecomputersociety.org/10.1109/SP.2012.41},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@inproceedings{Giuffrida12SEC,
 author = {Giuffrida, Cristiano and Kuijsten, Anton and Tanenbaum, Andrew S.},
 title = {Enhanced Operating System Security Through Efficient and Fine-grained Address Space Randomization},
 booktitle = {Proceedings of the 21st USENIX Conference on Security Symposium},
 series = {Security'12},
 year = {2012},
 location = {Bellevue, WA},
 pages = {40--40},
 numpages = {1},
 url = {http://dl.acm.org/citation.cfm?id=2362793.2362833},
 acmid = {2362833},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
} 

@inproceedings{Lin09DIMVA,
 author = {Lin, Zhiqiang and Riley, Ryan D. and Xu, Dongyan},
 title = {Polymorphing Software by Randomizing Data Structure Layout},
 booktitle = {Proceedings of the 6th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment},
 series = {DIMVA '09},
 year = {2009},
 isbn = {978-3-642-02917-2},
 location = {Como, Italy},
 pages = {107--126},
 numpages = {20},
 url = {http://dx.doi.org/10.1007/978-3-642-02918-9_7},
 doi = {10.1007/978-3-642-02918-9_7},
 acmid = {1575543},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
} 

@misc{symantec14av,
  author = {Brian Dye},
  year = {2014},
  title = {{Symantec Develops New Attack on Cyberhacking}},
  howpublished = {\url{http://online.wsj.com/news/articles/SB10001424052702303417104579542140235850578}},
  owner = {gannimo},
}

